{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"react\"), require(\"lodash\"), require(\"prop-types\"));else if (typeof define === 'function' && define.amd) define(\"reactXarrow\", [\"react\", \"lodash\", \"prop-types\"], factory);else if (typeof exports === 'object') exports[\"reactXarrow\"] = factory(require(\"react\"), require(\"lodash\"), require(\"prop-types\"));else root[\"reactXarrow\"] = factory(root[\"react\"], root[\"lodash\"], root[\"prop-types\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_lodash__, __WEBPACK_EXTERNAL_MODULE_prop_types__) {\n  return (/******/function () {\n      // webpackBootstrap\n      /******/\n      \"use strict\";\n\n      /******/\n      var __webpack_modules__ = {\n        /***/\"./src/Xarrow/utils/buzzier.js\":\n        /*!*************************************!*\\\n          !*** ./src/Xarrow/utils/buzzier.js ***!\n          \\*************************************/\n        /***/\n        function srcXarrowUtilsBuzzierJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n          __webpack_require__.r(__webpack_exports__);\n          /* harmony export */\n          __webpack_require__.d(__webpack_exports__, {\n            /* harmony export */\"bzFunction\": function bzFunction() {\n              return (/* binding */_bzFunction\n              );\n            },\n            /* harmony export */\"buzzierMinSols\": function buzzierMinSols() {\n              return (/* binding */_buzzierMinSols\n              );\n            }\n            /* harmony export */\n          });\n          // Buzier curve calculations\n\n          /**\r\n           * returns buzzier curve function with 2 controls points\r\n           * bzCurve with 2 control points function(4 points total):  bz = (1−t)^3*p1 + 3(1−t)^2*t*p2 +3(1−t)*t^2*p3 + t^3*p4\r\n           */\n          var _bzFunction = function bzFunction(p1, p2, p3, p4) {\n            return function (t) {\n              return Math.pow(1 - t, 3) * p1 + 3 * Math.pow(1 - t, 2) * t * p2 + 3 * (1 - t) * Math.pow(t, 2) * p3 + Math.pow(t, 3) * p4;\n            };\n          };\n          /**\r\n           * returns 2 solutions from extram points for buzzier curve with 2 controls points\r\n           */\n\n          var _buzzierMinSols = function buzzierMinSols(p1, p2, p3, p4) {\n            var bz = _bzFunction(p1, p2, p3, p4); // dt(bz) = -3 p1 (1 - t)^2 + 3 p2 (1 - t)^2 - 6 p2 (1 - t) t + 6 p3 (1 - t) t - 3 p3 t^2 + 3 p4 t^2\n            // when p1=(x1,y1),p2=(cpx1,cpy1),p3=(cpx2,cpy2),p4=(x2,y2)\n            // then extrema points is when dt(bz) = 0\n            // solutions =>  t = ((-6 p1 + 12 p2 - 6 p3) ± sqrt((6 p1 - 12 p2 + 6 p3)^2 - 4 (3 p2 - 3 p1) (-3 p1 + 9 p2 - 9 p3 + 3 p4)))/(2 (-3 p1 + 9 p2 - 9 p3 + 3 p4))  when (p1 + 3 p3!=3 p2 + p4)\n            // if we mark A=(-6 p1 + 12 p2 - 6 p3) and B=(6 p1 - 12 p2 + 6 p3)^2 - 4 (3 p2 - 3 p1) (-3 p1 + 9 p2 - 9 p3 + 3 p4)) and C =(2 (-3 p1 + 9 p2 - 9 p3 + 3 p4) then\n            // tSol = A ± sqrt(B)\n            // then solution we want is: bz(tSol)\n\n            var A = -6 * p1 + 12 * p2 - 6 * p3;\n            var B = Math.pow(-6 * p1 + 12 * p2 - 6 * p3, 2) - 4 * (3 * p2 - 3 * p1) * (-3 * p1 + 9 * p2 - 9 * p3 + 3 * p4);\n            var C = 2 * (-3 * p1 + 9 * p2 - 9 * p3 + 3 * p4);\n            var sol1 = bz((A + Math.sqrt(B)) / C);\n            var sol2 = bz((A - Math.sqrt(B)) / C);\n            return [sol1, sol2];\n          };\n\n          /***/\n        },\n\n        /***/\"./src/Xarrow/Xarrow.tsx\":\n        /*!*******************************!*\\\n          !*** ./src/Xarrow/Xarrow.tsx ***!\n          \\*******************************/\n        /***/\n        function srcXarrowXarrowTsx(__unused_webpack_module, exports, __webpack_require__) {\n          var __assign = this && this.__assign || function () {\n            __assign = Object.assign || function (t) {\n              for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n              }\n              return t;\n            };\n            return __assign.apply(this, arguments);\n          };\n          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            Object.defineProperty(o, k2, {\n              enumerable: true,\n              get: function get() {\n                return m[k];\n              }\n            });\n          } : function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            o[k2] = m[k];\n          });\n          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n            Object.defineProperty(o, \"default\", {\n              enumerable: true,\n              value: v\n            });\n          } : function (o, v) {\n            o[\"default\"] = v;\n          });\n          var __importStar = this && this.__importStar || function (mod) {\n            if (mod && mod.__esModule) return mod;\n            var result = {};\n            if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n            __setModuleDefault(result, mod);\n            return result;\n          };\n          var __spreadArray = this && this.__spreadArray || function (to, from) {\n            for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n            return to;\n          };\n          var __importDefault = this && this.__importDefault || function (mod) {\n            return mod && mod.__esModule ? mod : {\n              \"default\": mod\n            };\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          var react_1 = __importStar(__webpack_require__( /*! react */\"react\"));\n          var useXarrowProps_1 = __importDefault(__webpack_require__( /*! ./useXarrowProps */\"./src/Xarrow/useXarrowProps.ts\"));\n          var Xwrapper_1 = __webpack_require__( /*! ../Xwrapper */\"./src/Xwrapper.tsx\");\n          var propTypes_1 = __importDefault(__webpack_require__( /*! ./propTypes */\"./src/Xarrow/propTypes.ts\"));\n          var GetPosition_1 = __webpack_require__( /*! ./utils/GetPosition */\"./src/Xarrow/utils/GetPosition.tsx\");\n          var log = console.log;\n          var Xarrow = function Xarrow(props) {\n            // log('xarrow update');\n            var _a;\n            var mainRef = react_1.useRef({\n              svgRef: react_1.useRef(null),\n              lineRef: react_1.useRef(null),\n              headRef: react_1.useRef(null),\n              tailRef: react_1.useRef(null),\n              lineDrawAnimRef: react_1.useRef(null),\n              lineDashAnimRef: react_1.useRef(null),\n              headOpacityAnimRef: react_1.useRef(null)\n            });\n            var _b = mainRef.current,\n              svgRef = _b.svgRef,\n              lineRef = _b.lineRef,\n              headRef = _b.headRef,\n              tailRef = _b.tailRef,\n              lineDrawAnimRef = _b.lineDrawAnimRef,\n              lineDashAnimRef = _b.lineDashAnimRef,\n              headOpacityAnimRef = _b.headOpacityAnimRef;\n            react_1.useContext(Xwrapper_1.XarrowContext);\n            var xProps = useXarrowProps_1.default(props, mainRef.current);\n            var propsRefs = xProps[0];\n            var labels = propsRefs.labels,\n              lineColor = propsRefs.lineColor,\n              headColor = propsRefs.headColor,\n              tailColor = propsRefs.tailColor,\n              strokeWidth = propsRefs.strokeWidth,\n              showHead = propsRefs.showHead,\n              showTail = propsRefs.showTail,\n              dashness = propsRefs.dashness,\n              headShape = propsRefs.headShape,\n              tailShape = propsRefs.tailShape,\n              showXarrow = propsRefs.showXarrow,\n              animateDrawing = propsRefs.animateDrawing,\n              zIndex = propsRefs.zIndex,\n              passProps = propsRefs.passProps,\n              arrowBodyProps = propsRefs.arrowBodyProps,\n              arrowHeadProps = propsRefs.arrowHeadProps,\n              arrowTailProps = propsRefs.arrowTailProps,\n              SVGcanvasProps = propsRefs.SVGcanvasProps,\n              divContainerProps = propsRefs.divContainerProps,\n              divContainerStyle = propsRefs.divContainerStyle,\n              SVGcanvasStyle = propsRefs.SVGcanvasStyle,\n              _debug = propsRefs._debug,\n              shouldUpdatePosition = propsRefs.shouldUpdatePosition;\n            animateDrawing = props.animateDrawing;\n            var _c = react_1.useState(!animateDrawing),\n              drawAnimEnded = _c[0],\n              setDrawAnimEnded = _c[1];\n            var _d = react_1.useState({}),\n              setRender = _d[1];\n            var forceRerender = function forceRerender() {\n              return setRender({});\n            };\n            var _e = react_1.useState({\n                //initial state\n                cx0: 0,\n                cy0: 0,\n                cw: 0,\n                ch: 0,\n                x1: 0,\n                y1: 0,\n                x2: 0,\n                y2: 0,\n                dx: 0,\n                dy: 0,\n                absDx: 0,\n                absDy: 0,\n                cpx1: 0,\n                cpy1: 0,\n                cpx2: 0,\n                cpy2: 0,\n                headOrient: 0,\n                tailOrient: 0,\n                arrowHeadOffset: {\n                  x: 0,\n                  y: 0\n                },\n                arrowTailOffset: {\n                  x: 0,\n                  y: 0\n                },\n                headOffset: 0,\n                excRight: 0,\n                excLeft: 0,\n                excUp: 0,\n                excDown: 0,\n                startPoints: [],\n                endPoints: [],\n                mainDivPos: {\n                  x: 0,\n                  y: 0\n                },\n                xSign: 1,\n                ySign: 1,\n                lineLength: 0,\n                fHeadSize: 1,\n                fTailSize: 1,\n                arrowPath: \"\",\n                labelStartPos: {\n                  x: 0,\n                  y: 0\n                },\n                labelMiddlePos: {\n                  x: 0,\n                  y: 0\n                },\n                labelEndPos: {\n                  x: 0,\n                  y: 0\n                }\n              }),\n              st = _e[0],\n              setSt = _e[1];\n            /**\r\n             * The Main logic of path calculation for the arrow.\r\n             * calculate new path, adjusting canvas, and set state based on given properties.\r\n             * */\n            react_1.useLayoutEffect(function () {\n              if (shouldUpdatePosition.current) {\n                // log('xarrow getPosition');\n                var pos = GetPosition_1.getPosition(xProps, mainRef);\n                // log('pos', pos);\n                setSt(pos);\n                shouldUpdatePosition.current = false;\n              }\n            });\n            // log('st', st);\n            var xOffsetHead = st.x2 - st.arrowHeadOffset.x;\n            var yOffsetHead = st.y2 - st.arrowHeadOffset.y;\n            var xOffsetTail = st.x1 - st.arrowTailOffset.x;\n            var yOffsetTail = st.y1 - st.arrowTailOffset.y;\n            var dashoffset = dashness.strokeLen + dashness.nonStrokeLen;\n            var animDirection = 1;\n            if (dashness.animation < 0) {\n              dashness.animation *= -1;\n              animDirection = -1;\n            }\n            var dashArray,\n              animation,\n              animRepeatCount,\n              animStartValue,\n              animEndValue = 0;\n            if (animateDrawing && drawAnimEnded == false) {\n              if (typeof animateDrawing === 'boolean') animateDrawing = 1;\n              animation = animateDrawing + 's';\n              dashArray = st.lineLength;\n              animStartValue = st.lineLength;\n              animRepeatCount = 1;\n              if (animateDrawing < 0) {\n                _a = [animEndValue, animStartValue], animStartValue = _a[0], animEndValue = _a[1];\n                animation = animateDrawing * -1 + 's';\n              }\n            } else {\n              dashArray = dashness.strokeLen + \" \" + dashness.nonStrokeLen;\n              animation = 1 / dashness.animation + \"s\";\n              animStartValue = dashoffset * animDirection;\n              animRepeatCount = 'indefinite';\n              animEndValue = 0;\n            }\n            // handle draw animation\n            react_1.useLayoutEffect(function () {\n              if (lineRef.current) setSt(function (prevSt) {\n                var _a, _b;\n                return __assign(__assign({}, prevSt), {\n                  lineLength: (_b = (_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.getTotalLength()) !== null && _b !== void 0 ? _b : 0\n                });\n              });\n            }, [lineRef.current]);\n            // set all props on first render\n            react_1.useEffect(function () {\n              var monitorDOMchanges = function monitorDOMchanges() {\n                window.addEventListener('resize', forceRerender);\n                var handleDrawAmimEnd = function handleDrawAmimEnd() {\n                  var _a, _b;\n                  setDrawAnimEnded(true);\n                  // @ts-ignore\n                  (_a = headOpacityAnimRef.current) === null || _a === void 0 ? void 0 : _a.beginElement();\n                  // @ts-ignore\n                  (_b = lineDashAnimRef.current) === null || _b === void 0 ? void 0 : _b.beginElement();\n                };\n                var handleDrawAmimBegin = function handleDrawAmimBegin() {\n                  return headRef.current.style.opacity = '0';\n                };\n                if (lineDrawAnimRef.current && headRef.current) {\n                  lineDrawAnimRef.current.addEventListener('endEvent', handleDrawAmimEnd);\n                  lineDrawAnimRef.current.addEventListener('beginEvent', handleDrawAmimBegin);\n                }\n                return function () {\n                  window.removeEventListener('resize', forceRerender);\n                  if (lineDrawAnimRef.current) {\n                    lineDrawAnimRef.current.removeEventListener('endEvent', handleDrawAmimEnd);\n                    if (headRef.current) lineDrawAnimRef.current.removeEventListener('beginEvent', handleDrawAmimBegin);\n                  }\n                };\n              };\n              var cleanMonitorDOMchanges = monitorDOMchanges();\n              return function () {\n                setDrawAnimEnded(false);\n                cleanMonitorDOMchanges();\n              };\n            }, [showXarrow]);\n            //todo: could make some advanced generic typescript inferring. for example get type from headShape.elem:T and\n            // tailShape.elem:K force the type for passProps,arrowHeadProps,arrowTailProps property. for now `as any` is used to\n            // avoid typescript conflicts\n            // so todo- fix all the `passProps as any` assertions\n            return react_1.default.createElement(\"div\", __assign({}, divContainerProps, {\n              style: __assign({\n                position: 'absolute',\n                zIndex: zIndex\n              }, divContainerStyle)\n            }), showXarrow ? react_1.default.createElement(react_1.default.Fragment, null, react_1.default.createElement(\"svg\", __assign({\n              ref: svgRef,\n              width: st.cw,\n              height: st.ch,\n              style: __assign({\n                position: 'absolute',\n                left: st.cx0,\n                top: st.cy0,\n                pointerEvents: 'none',\n                border: _debug ? '1px dashed yellow' : null\n              }, SVGcanvasStyle),\n              overflow: \"auto\"\n            }, SVGcanvasProps), react_1.default.createElement(\"path\", __assign({\n              ref: lineRef,\n              d: st.arrowPath,\n              stroke: lineColor,\n              strokeDasharray: dashArray,\n              // strokeDasharray={'0 0'}\n              strokeWidth: strokeWidth,\n              fill: \"transparent\",\n              pointerEvents: \"visibleStroke\"\n            }, passProps, arrowBodyProps), react_1.default.createElement(react_1.default.Fragment, null, drawAnimEnded ? react_1.default.createElement(react_1.default.Fragment, null, dashness.animation ? react_1.default.createElement(\"animate\", {\n              ref: lineDashAnimRef,\n              attributeName: \"stroke-dashoffset\",\n              values: dashoffset * animDirection + \";0\",\n              dur: 1 / dashness.animation + \"s\",\n              repeatCount: \"indefinite\"\n            }) : null) : react_1.default.createElement(react_1.default.Fragment, null, animateDrawing ? react_1.default.createElement(\"animate\", {\n              ref: lineDrawAnimRef,\n              id: \"svgEndAnimate\",\n              attributeName: \"stroke-dashoffset\",\n              values: animStartValue + \";\" + animEndValue,\n              dur: animation,\n              repeatCount: animRepeatCount\n            }) : null))), showTail ? react_1.default.createElement(\"g\", __assign({\n              fill: tailColor,\n              pointerEvents: \"auto\",\n              transform: \"translate(\" + xOffsetTail + \",\" + yOffsetTail + \") rotate(\" + st.tailOrient + \") scale(\" + st.fTailSize + \")\"\n            }, passProps, arrowTailProps), tailShape.svgElem) : null, showHead ? react_1.default.createElement(\"g\", __assign({\n              ref: headRef,\n              // d={normalArrowShape}\n              fill: headColor,\n              pointerEvents: \"auto\",\n              transform: \"translate(\" + xOffsetHead + \",\" + yOffsetHead + \") rotate(\" + st.headOrient + \") scale(\" + st.fHeadSize + \")\",\n              opacity: animateDrawing && !drawAnimEnded ? 0 : 1\n            }, passProps, arrowHeadProps), react_1.default.createElement(\"animate\", {\n              ref: headOpacityAnimRef,\n              dur: '0.4',\n              attributeName: \"opacity\",\n              from: \"0\",\n              to: \"1\",\n              begin: \"indefinite\",\n              repeatCount: \"0\",\n              fill: \"freeze\"\n            }), headShape.svgElem) : null, _debug ? react_1.default.createElement(react_1.default.Fragment, null, react_1.default.createElement(\"circle\", {\n              r: \"5\",\n              cx: st.cpx1,\n              cy: st.cpy1,\n              fill: \"green\"\n            }), react_1.default.createElement(\"circle\", {\n              r: \"5\",\n              cx: st.cpx2,\n              cy: st.cpy2,\n              fill: \"blue\"\n            }), react_1.default.createElement(\"rect\", {\n              x: st.excLeft,\n              y: st.excUp,\n              width: st.absDx,\n              height: st.absDy,\n              fill: \"none\",\n              stroke: \"pink\",\n              strokeWidth: \"2px\"\n            })) : null), labels.start ? react_1.default.createElement(\"div\", {\n              style: {\n                transform: st.dx < 0 ? 'translate(-100% , -50%)' : 'translate(-0% , -50%)',\n                width: 'max-content',\n                position: 'absolute',\n                left: st.cx0 + st.labelStartPos.x,\n                top: st.cy0 + st.labelStartPos.y - strokeWidth - 5\n              }\n            }, labels.start) : null, labels.middle ? react_1.default.createElement(\"div\", {\n              style: {\n                display: 'table',\n                width: 'max-content',\n                transform: 'translate(-50% , -50%)',\n                position: 'absolute',\n                left: st.cx0 + st.labelMiddlePos.x,\n                top: st.cy0 + st.labelMiddlePos.y\n              }\n            }, labels.middle) : null, labels.end ? react_1.default.createElement(\"div\", {\n              style: {\n                transform: st.dx > 0 ? 'translate(-100% , -50%)' : 'translate(-0% , -50%)',\n                width: 'max-content',\n                position: 'absolute',\n                left: st.cx0 + st.labelEndPos.x,\n                top: st.cy0 + st.labelEndPos.y + strokeWidth + 5\n              }\n            }, labels.end) : null, _debug ? react_1.default.createElement(react_1.default.Fragment, null, __spreadArray(__spreadArray([], st.startPoints), st.endPoints).map(function (p, i) {\n              return react_1.default.createElement(\"div\", {\n                key: i,\n                style: {\n                  background: 'gray',\n                  opacity: 0.5,\n                  borderRadius: '50%',\n                  transform: 'translate(-50%, -50%)',\n                  height: 5,\n                  width: 5,\n                  position: 'absolute',\n                  left: p.x - st.mainDivPos.x,\n                  top: p.y - st.mainDivPos.y\n                }\n              });\n            })) : null) : null);\n          };\n          //////////////////////////////\n          // propTypes\n          Xarrow.propTypes = propTypes_1.default;\n          exports.default = Xarrow;\n\n          /***/\n        },\n\n        /***/\"./src/Xarrow/anchors.ts\":\n        /*!*******************************!*\\\n          !*** ./src/Xarrow/anchors.ts ***!\n          \\*******************************/\n        /***/\n        function srcXarrowAnchorsTs(module, exports, __webpack_require__) {\n          /* module decorator */module = __webpack_require__.nmd(module);\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.calcAnchors = void 0;\n          var getAnchorsDefaultOffsets = function getAnchorsDefaultOffsets(width, height) {\n            return {\n              middle: {\n                x: width * 0.5,\n                y: height * 0.5\n              },\n              left: {\n                x: 0,\n                y: height * 0.5\n              },\n              right: {\n                x: width,\n                y: height * 0.5\n              },\n              top: {\n                x: width * 0.5,\n                y: 0\n              },\n              bottom: {\n                x: width * 0.5,\n                y: height\n              }\n            };\n          };\n          var calcAnchors = function calcAnchors(anchors, anchorPos) {\n            // now prepare this list of anchors to object expected by the `getShortestLine` function\n            return anchors.map(function (anchor) {\n              var defsOffsets = getAnchorsDefaultOffsets(anchorPos.right - anchorPos.x, anchorPos.bottom - anchorPos.y);\n              var _a = defsOffsets[anchor.position],\n                x = _a.x,\n                y = _a.y;\n              return {\n                x: anchorPos.x + x + anchor.offset.x,\n                y: anchorPos.y + y + anchor.offset.y,\n                anchor: anchor\n              };\n            });\n          };\n          exports.calcAnchors = calcAnchors;\n          if (__webpack_require__.c[__webpack_require__.s] === module) {\n            // const res = parseAnchor(['auto'], {\n            //   x: 0,\n            //   y: 0,\n            //   bottom: 10,\n            //   right: 20,\n            // });\n            // console.log(res);\n          }\n\n          /***/\n        },\n\n        /***/\"./src/Xarrow/propTypes.ts\":\n        /*!*********************************!*\\\n          !*** ./src/Xarrow/propTypes.ts ***!\n          \\*********************************/\n        /***/\n        function srcXarrowPropTypesTs(__unused_webpack_module, exports, __webpack_require__) {\n          var __importDefault = this && this.__importDefault || function (mod) {\n            return mod && mod.__esModule ? mod : {\n              \"default\": mod\n            };\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          var prop_types_1 = __importDefault(__webpack_require__( /*! prop-types */\"prop-types\"));\n          var constants_1 = __webpack_require__( /*! ../constants */\"./src/constants.tsx\");\n          var pAnchorPositionType = prop_types_1.default.oneOf(constants_1.cAnchorEdge);\n          var pAnchorCustomPositionType = prop_types_1.default.exact({\n            position: pAnchorPositionType.isRequired,\n            offset: prop_types_1.default.exact({\n              x: prop_types_1.default.number,\n              y: prop_types_1.default.number\n            }).isRequired\n          });\n          var _pAnchorType = prop_types_1.default.oneOfType([pAnchorPositionType, pAnchorCustomPositionType]);\n          var pAnchorType = prop_types_1.default.oneOfType([_pAnchorType, prop_types_1.default.arrayOf(_pAnchorType)]);\n          var pRefType = prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.exact({\n            current: prop_types_1.default.any\n          })]);\n          var _pLabelType = prop_types_1.default.oneOfType([prop_types_1.default.element, prop_types_1.default.string]);\n          var pLabelsType = prop_types_1.default.exact({\n            start: _pLabelType,\n            middle: _pLabelType,\n            end: _pLabelType\n          });\n          var pSvgEdgeShapeType = prop_types_1.default.oneOf(Object.keys(constants_1.arrowShapes));\n          // const pSvgElemType = PT.oneOf(cSvgElems);\n          var pSvgElemType = prop_types_1.default.any;\n          var pSvgEdgeType = prop_types_1.default.oneOfType([pSvgEdgeShapeType, prop_types_1.default.exact({\n            svgElem: pSvgElemType,\n            offsetForward: prop_types_1.default.number\n          }).isRequired]);\n          var XarrowPropTypes = {\n            start: pRefType.isRequired,\n            end: pRefType.isRequired,\n            startAnchor: pAnchorType,\n            endAnchor: pAnchorType,\n            labels: prop_types_1.default.oneOfType([_pLabelType, pLabelsType]),\n            color: prop_types_1.default.string,\n            lineColor: prop_types_1.default.string,\n            showHead: prop_types_1.default.bool,\n            headColor: prop_types_1.default.string,\n            headSize: prop_types_1.default.number,\n            tailSize: prop_types_1.default.number,\n            tailColor: prop_types_1.default.string,\n            strokeWidth: prop_types_1.default.number,\n            showTail: prop_types_1.default.bool,\n            path: prop_types_1.default.oneOf(constants_1.cPaths),\n            showXarrow: prop_types_1.default.bool,\n            curveness: prop_types_1.default.number,\n            gridBreak: prop_types_1.default.string,\n            dashness: prop_types_1.default.oneOfType([prop_types_1.default.bool, prop_types_1.default.object]),\n            headShape: pSvgEdgeType,\n            tailShape: pSvgEdgeType,\n            animateDrawing: prop_types_1.default.oneOfType([prop_types_1.default.bool, prop_types_1.default.number]),\n            zIndex: prop_types_1.default.number,\n            passProps: prop_types_1.default.object,\n            arrowBodyProps: prop_types_1.default.object,\n            arrowHeadProps: prop_types_1.default.object,\n            arrowTailProps: prop_types_1.default.object,\n            SVGcanvasProps: prop_types_1.default.object,\n            divContainerProps: prop_types_1.default.object,\n            _extendSVGcanvas: prop_types_1.default.number,\n            _debug: prop_types_1.default.bool,\n            _cpx1Offset: prop_types_1.default.number,\n            _cpy1Offset: prop_types_1.default.number,\n            _cpx2Offset: prop_types_1.default.number,\n            _cpy2Offset: prop_types_1.default.number\n          };\n          exports.default = XarrowPropTypes;\n\n          /***/\n        },\n\n        /***/\"./src/Xarrow/useXarrowProps.ts\":\n        /*!**************************************!*\\\n          !*** ./src/Xarrow/useXarrowProps.ts ***!\n          \\**************************************/\n        /***/\n        function srcXarrowUseXarrowPropsTs(__unused_webpack_module, exports, __webpack_require__) {\n          var __assign = this && this.__assign || function () {\n            __assign = Object.assign || function (t) {\n              for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n              }\n              return t;\n            };\n            return __assign.apply(this, arguments);\n          };\n          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            Object.defineProperty(o, k2, {\n              enumerable: true,\n              get: function get() {\n                return m[k];\n              }\n            });\n          } : function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            o[k2] = m[k];\n          });\n          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n            Object.defineProperty(o, \"default\", {\n              enumerable: true,\n              value: v\n            });\n          } : function (o, v) {\n            o[\"default\"] = v;\n          });\n          var __importStar = this && this.__importStar || function (mod) {\n            if (mod && mod.__esModule) return mod;\n            var result = {};\n            if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n            __setModuleDefault(result, mod);\n            return result;\n          };\n          var __importDefault = this && this.__importDefault || function (mod) {\n            return mod && mod.__esModule ? mod : {\n              \"default\": mod\n            };\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          var react_1 = __importStar(__webpack_require__( /*! react */\"react\"));\n          var utils_1 = __webpack_require__( /*! ./utils */\"./src/Xarrow/utils/index.ts\");\n          var lodash_1 = __importDefault(__webpack_require__( /*! lodash */\"lodash\"));\n          var constants_1 = __webpack_require__( /*! ../constants */\"./src/constants.tsx\");\n          var parseLabels = function parseLabels(label) {\n            var parsedLabel = {\n              start: null,\n              middle: null,\n              end: null\n            };\n            if (label) {\n              if (typeof label === 'string' || react_1.default.isValidElement(label)) parsedLabel.middle = label;else {\n                for (var key in label) {\n                  parsedLabel[key] = label[key];\n                }\n              }\n            }\n            return parsedLabel;\n          };\n          var parseAnchor = function parseAnchor(anchor) {\n            // convert to array\n            var anchorChoice = Array.isArray(anchor) ? anchor : [anchor];\n            //convert to array of objects\n            var anchorChoice2 = anchorChoice.map(function (anchorChoice) {\n              if (typeof anchorChoice === 'string') {\n                return {\n                  position: anchorChoice\n                };\n              } else return anchorChoice;\n            });\n            //remove any invalid anchor names\n            anchorChoice2 = anchorChoice2.filter(function (an) {\n              return constants_1.cAnchorEdge.includes(an.position);\n            });\n            if (anchorChoice2.length == 0) anchorChoice2 = [{\n              position: 'auto'\n            }];\n            //replace any 'auto' with ['left','right','bottom','top']\n            var autosAncs = anchorChoice2.filter(function (an) {\n              return an.position === 'auto';\n            });\n            if (autosAncs.length > 0) {\n              anchorChoice2 = anchorChoice2.filter(function (an) {\n                return an.position !== 'auto';\n              });\n              anchorChoice2.push.apply(anchorChoice2, autosAncs.flatMap(function (anchorObj) {\n                return ['left', 'right', 'top', 'bottom'].map(function (anchorName) {\n                  return __assign(__assign({}, anchorObj), {\n                    position: anchorName\n                  });\n                });\n              }));\n            }\n            // default values\n            var anchorChoice3 = anchorChoice2.map(function (anchorChoice) {\n              if (typeof anchorChoice === 'object') {\n                var anchorChoiceCustom = anchorChoice;\n                if (!anchorChoiceCustom.position) anchorChoiceCustom.position = 'auto';\n                if (!anchorChoiceCustom.offset) anchorChoiceCustom.offset = {\n                  x: 0,\n                  y: 0\n                };\n                if (!anchorChoiceCustom.offset.y) anchorChoiceCustom.offset.y = 0;\n                if (!anchorChoiceCustom.offset.x) anchorChoiceCustom.offset.x = 0;\n                anchorChoiceCustom = anchorChoiceCustom;\n                return anchorChoiceCustom;\n              } else return anchorChoice;\n            });\n            return anchorChoice3;\n          };\n          var parseDashness = function parseDashness(dashness, props) {\n            var dashStroke = 0,\n              dashNone = 0,\n              animDashSpeed,\n              animDirection = 1;\n            if (typeof dashness === 'object') {\n              dashStroke = dashness.strokeLen || props.strokeWidth * 2;\n              dashNone = dashness.strokeLen ? dashness.nonStrokeLen : props.strokeWidth;\n              animDashSpeed = dashness.animation ? dashness.animation : null;\n            } else if (typeof dashness === 'boolean' && dashness) {\n              dashStroke = props.strokeWidth * 2;\n              dashNone = props.strokeWidth;\n              animDashSpeed = null;\n            }\n            return {\n              strokeLen: dashStroke,\n              nonStrokeLen: dashNone,\n              animation: animDashSpeed,\n              animDirection: animDirection\n            };\n          };\n          var parseEdgeShape = function parseEdgeShape(svgEdge) {\n            if (typeof svgEdge == 'string') {\n              if (svgEdge in constants_1.arrowShapes) svgEdge = constants_1.arrowShapes[svgEdge];else {\n                console.warn(\"'\" + svgEdge + \"' is not supported arrow shape. the supported arrow shapes is one of \" + constants_1.cArrowShapes + \".\\n           reverting to default shape.\");\n                svgEdge = constants_1.arrowShapes['arrow1'];\n              }\n            }\n            svgEdge = svgEdge;\n            if ((svgEdge === null || svgEdge === void 0 ? void 0 : svgEdge.offsetForward) === undefined) svgEdge.offsetForward = 0.25;\n            if ((svgEdge === null || svgEdge === void 0 ? void 0 : svgEdge.svgElem) === undefined) svgEdge.svgElem = 'path';\n            // if (svgEdge?.svgProps === undefined) svgEdge.svgProps = arrowShapes.arrow1.svgProps;\n            return svgEdge;\n          };\n          var parseGridBreak = function parseGridBreak(gridBreak) {\n            var resGridBreak = utils_1.xStr2absRelative(gridBreak);\n            if (!resGridBreak) resGridBreak = {\n              relative: 0.5,\n              abs: 0\n            };\n            return resGridBreak;\n          };\n          /**\r\n           * should be wrapped with any changed prop that is affecting the points path positioning\r\n           * @param propVal\r\n           * @param updateRef\r\n           */\n          var withUpdate = function withUpdate(propVal, updateRef) {\n            if (updateRef) updateRef.current = true;\n            return propVal;\n          };\n          var noParse = function noParse(userProp) {\n            return userProp;\n          };\n          var noParseWithUpdatePos = function noParseWithUpdatePos(userProp, _, updatePos) {\n            return withUpdate(userProp, updatePos);\n          };\n          var parseNumWithUpdatePos = function parseNumWithUpdatePos(userProp, _, updatePos) {\n            return withUpdate(Number(userProp), updatePos);\n          };\n          var parseNum = function parseNum(userProp) {\n            return Number(userProp);\n          };\n          var parsePropsFuncs = {\n            start: function start(userProp) {\n              return utils_1.getElementByPropGiven(userProp);\n            },\n            end: function end(userProp) {\n              return utils_1.getElementByPropGiven(userProp);\n            },\n            startAnchor: function startAnchor(userProp, _, updatePos) {\n              return withUpdate(parseAnchor(userProp), updatePos);\n            },\n            endAnchor: function endAnchor(userProp, _, updatePos) {\n              return withUpdate(parseAnchor(userProp), updatePos);\n            },\n            labels: function labels(userProp) {\n              return parseLabels(userProp);\n            },\n            color: noParse,\n            lineColor: function lineColor(userProp, propsRefs) {\n              return userProp || propsRefs.color;\n            },\n            headColor: function headColor(userProp, propsRefs) {\n              return userProp || propsRefs.color;\n            },\n            tailColor: function tailColor(userProp, propsRefs) {\n              return userProp || propsRefs.color;\n            },\n            strokeWidth: parseNumWithUpdatePos,\n            showHead: noParseWithUpdatePos,\n            headSize: parseNumWithUpdatePos,\n            showTail: noParseWithUpdatePos,\n            tailSize: parseNumWithUpdatePos,\n            path: noParseWithUpdatePos,\n            curveness: parseNumWithUpdatePos,\n            gridBreak: function gridBreak(userProp, _, updatePos) {\n              return withUpdate(parseGridBreak(userProp), updatePos);\n            },\n            // // gridRadius = strokeWidth * 2, //todo\n            dashness: function dashness(userProp, propsRefs) {\n              return parseDashness(userProp, propsRefs);\n            },\n            headShape: function headShape(userProp) {\n              return parseEdgeShape(userProp);\n            },\n            tailShape: function tailShape(userProp) {\n              return parseEdgeShape(userProp);\n            },\n            showXarrow: noParse,\n            animateDrawing: noParse,\n            zIndex: parseNum,\n            passProps: noParse,\n            arrowBodyProps: noParseWithUpdatePos,\n            arrowHeadProps: noParseWithUpdatePos,\n            arrowTailProps: noParseWithUpdatePos,\n            SVGcanvasProps: noParseWithUpdatePos,\n            divContainerProps: noParseWithUpdatePos,\n            divContainerStyle: noParseWithUpdatePos,\n            SVGcanvasStyle: noParseWithUpdatePos,\n            _extendSVGcanvas: noParseWithUpdatePos,\n            _debug: noParseWithUpdatePos,\n            _cpx1Offset: noParseWithUpdatePos,\n            _cpy1Offset: noParseWithUpdatePos,\n            _cpx2Offset: noParseWithUpdatePos,\n            _cpy2Offset: noParseWithUpdatePos\n          };\n          //build dependencies\n          var propsDeps = {};\n          //each prop depends on himself\n          for (var propName in parsePropsFuncs) {\n            propsDeps[propName] = [propName];\n          }\n          // 'lineColor', 'headColor', 'tailColor' props also depends on 'color' prop\n          for (var _i = 0, _a = ['lineColor', 'headColor', 'tailColor']; _i < _a.length; _i++) {\n            var propName = _a[_i];\n            propsDeps[propName].push('color');\n          }\n          var parseGivenProps = function parseGivenProps(props, propsRef) {\n            var _a;\n            for (var _i = 0, _b = Object.entries(props); _i < _b.length; _i++) {\n              var _c = _b[_i],\n                name_1 = _c[0],\n                val = _c[1];\n              propsRef[name_1] = (_a = parsePropsFuncs === null || parsePropsFuncs === void 0 ? void 0 : parsePropsFuncs[name_1]) === null || _a === void 0 ? void 0 : _a.call(parsePropsFuncs, val, propsRef);\n            }\n            return propsRef;\n          };\n          var defaultProps = {\n            start: null,\n            end: null,\n            startAnchor: 'auto',\n            endAnchor: 'auto',\n            labels: null,\n            color: 'CornflowerBlue',\n            lineColor: null,\n            headColor: null,\n            tailColor: null,\n            strokeWidth: 4,\n            showHead: true,\n            headSize: 6,\n            showTail: false,\n            tailSize: 6,\n            path: 'smooth',\n            curveness: 0.8,\n            gridBreak: '50%',\n            // gridRadius : strokeWidth * 2, //todo\n            dashness: false,\n            headShape: 'arrow1',\n            tailShape: 'arrow1',\n            showXarrow: true,\n            animateDrawing: false,\n            zIndex: 0,\n            passProps: {},\n            arrowBodyProps: {},\n            arrowHeadProps: {},\n            arrowTailProps: {},\n            SVGcanvasProps: {},\n            divContainerProps: {},\n            divContainerStyle: {},\n            SVGcanvasStyle: {},\n            _extendSVGcanvas: 0,\n            _debug: false,\n            _cpx1Offset: 0,\n            _cpy1Offset: 0,\n            _cpx2Offset: 0,\n            _cpy2Offset: 0\n          };\n          var initialParsedProps = {};\n          initialParsedProps = parseGivenProps(defaultProps, initialParsedProps);\n          var initialValVars = {\n            startPos: {\n              x: 0,\n              y: 0,\n              right: 0,\n              bottom: 0\n            },\n            endPos: {\n              x: 0,\n              y: 0,\n              right: 0,\n              bottom: 0\n            }\n          };\n          // const parseAllProps = () => parseGivenProps(defaultProps, initialParsedProps);\n          function deepCompareEquals(a, b) {\n            return lodash_1.default.isEqual(a, b);\n          }\n          function useDeepCompareMemoize(value) {\n            var ref = react_1.useRef();\n            // it can be done by using useMemo as well\n            // but useRef is rather cleaner and easier\n            if (!deepCompareEquals(value, ref.current)) {\n              ref.current = value;\n            }\n            return ref.current;\n          }\n          function useDeepCompareEffect(callback, dependencies) {\n            react_1.useLayoutEffect(callback, dependencies.map(useDeepCompareMemoize));\n          }\n          /**\r\n           * smart hook that provides parsed props to Xarrow and will trigger rerender whenever given prop is changed.\r\n           */\n          var useXarrowProps = function useXarrowProps(userProps, refs) {\n            var _a = react_1.useState(initialParsedProps),\n              propsRefs = _a[0],\n              setPropsRefs = _a[1];\n            var shouldUpdatePosition = react_1.useRef(false);\n            // const _propsRefs = useRef(initialParsedProps);\n            // const propsRefs = _propsRefs.current;\n            propsRefs['shouldUpdatePosition'] = shouldUpdatePosition;\n            var curProps = __assign(__assign({}, defaultProps), userProps);\n            var _loop_1 = function _loop_1(propName) {\n              react_1.useLayoutEffect(function () {\n                var _a;\n                propsRefs[propName] = (_a = parsePropsFuncs === null || parsePropsFuncs === void 0 ? void 0 : parsePropsFuncs[propName]) === null || _a === void 0 ? void 0 : _a.call(parsePropsFuncs, curProps[propName], propsRefs, shouldUpdatePosition);\n                // console.log('prop update:', propName, 'with value', propsRefs[propName]);\n                setPropsRefs(__assign({}, propsRefs));\n              }, propsDeps[propName].map(function (name) {\n                return userProps[name];\n              }));\n            };\n            // react states the number of hooks per render must stay constant,\n            // this is ok we are using these hooks in a loop, because the number of props in defaultProps is constant,\n            // so the number of hook we will fire each render will always be the same.\n            // update the value of the ref that represents the corresponding prop\n            // for example: if given 'start' prop would change call getElementByPropGiven(props.start) and save value into propsRefs.start.current\n            // why to save refs to props parsed values? some of the props require relatively expensive computations(like 'start' and 'startAnchor').\n            // this will always run in the same order and THAT'S WAY ITS LEGAL\n            for (var propName in defaultProps) {\n              _loop_1(propName);\n            }\n            // rerender whenever position of start element or end element changes\n            var _b = react_1.useState(initialValVars),\n              valVars = _b[0],\n              setValVars = _b[1];\n            var startPos = utils_1.getElemPos(propsRefs.start);\n            useDeepCompareEffect(function () {\n              valVars.startPos = startPos;\n              shouldUpdatePosition.current = true;\n              setValVars(__assign({}, valVars));\n              // console.log('start update pos', startPos);\n            }, [startPos]);\n            var endPos = utils_1.getElemPos(propsRefs.end);\n            useDeepCompareEffect(function () {\n              valVars.endPos = endPos;\n              shouldUpdatePosition.current = true;\n              setValVars(__assign({}, valVars));\n              // console.log('end update pos', endPos);\n            }, [endPos]);\n            react_1.useLayoutEffect(function () {\n              // console.log('svg shape changed!');\n              shouldUpdatePosition.current = true;\n              setValVars(__assign({}, valVars));\n            }, [propsRefs.headShape.svgElem, propsRefs.tailShape.svgElem]);\n            return [propsRefs, valVars];\n          };\n          exports.default = useXarrowProps;\n\n          /***/\n        },\n\n        /***/\"./src/Xarrow/utils/GetPosition.tsx\":\n        /*!******************************************!*\\\n          !*** ./src/Xarrow/utils/GetPosition.tsx ***!\n          \\******************************************/\n        /***/\n        function srcXarrowUtilsGetPositionTsx(__unused_webpack_module, exports, __webpack_require__) {\n          var __importDefault = this && this.__importDefault || function (mod) {\n            return mod && mod.__esModule ? mod : {\n              \"default\": mod\n            };\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.getPosition = void 0;\n          var anchors_1 = __webpack_require__( /*! ../anchors */\"./src/Xarrow/anchors.ts\");\n          var index_1 = __webpack_require__( /*! ./index */\"./src/Xarrow/utils/index.ts\");\n          var lodash_1 = __importDefault(__webpack_require__( /*! lodash */\"lodash\"));\n          var constants_1 = __webpack_require__( /*! ../../constants */\"./src/constants.tsx\");\n          var buzzier_1 = __webpack_require__( /*! ./buzzier */\"./src/Xarrow/utils/buzzier.js\");\n          /**\r\n           * The Main logic of path calculation for the arrow.\r\n           * calculate new path, adjusting canvas, and set state based on given properties.\r\n           * */\n          var getPosition = function getPosition(xProps, mainRef) {\n            var _a, _b;\n            var _c, _d;\n            var propsRefs = xProps[0],\n              valVars = xProps[1];\n            var startAnchor = propsRefs.startAnchor,\n              endAnchor = propsRefs.endAnchor,\n              strokeWidth = propsRefs.strokeWidth,\n              showHead = propsRefs.showHead,\n              headSize = propsRefs.headSize,\n              showTail = propsRefs.showTail,\n              tailSize = propsRefs.tailSize,\n              path = propsRefs.path,\n              curveness = propsRefs.curveness,\n              gridBreak = propsRefs.gridBreak,\n              headShape = propsRefs.headShape,\n              tailShape = propsRefs.tailShape,\n              _extendSVGcanvas = propsRefs._extendSVGcanvas,\n              _cpx1Offset = propsRefs._cpx1Offset,\n              _cpy1Offset = propsRefs._cpy1Offset,\n              _cpx2Offset = propsRefs._cpx2Offset,\n              _cpy2Offset = propsRefs._cpy2Offset;\n            var startPos = valVars.startPos,\n              endPos = valVars.endPos;\n            var _e = mainRef.current,\n              svgRef = _e.svgRef,\n              lineRef = _e.lineRef;\n            var headOrient = 0;\n            var tailOrient = 0;\n            // convert startAnchor and endAnchor to list of objects represents allowed anchors.\n            var startPoints = anchors_1.calcAnchors(startAnchor, startPos);\n            var endPoints = anchors_1.calcAnchors(endAnchor, endPos);\n            // choose the smallest path for 2 points from these possibilities.\n            var _f = index_1.getShortestLine(startPoints, endPoints),\n              chosenStart = _f.chosenStart,\n              chosenEnd = _f.chosenEnd;\n            var startAnchorPosition = chosenStart.anchor.position,\n              endAnchorPosition = chosenEnd.anchor.position;\n            var startPoint = lodash_1.default.pick(chosenStart, ['x', 'y']),\n              endPoint = lodash_1.default.pick(chosenEnd, ['x', 'y']);\n            var mainDivPos = index_1.getSvgPos(svgRef);\n            var cx0 = Math.min(startPoint.x, endPoint.x) - mainDivPos.x;\n            var cy0 = Math.min(startPoint.y, endPoint.y) - mainDivPos.y;\n            var dx = endPoint.x - startPoint.x;\n            var dy = endPoint.y - startPoint.y;\n            var absDx = Math.abs(endPoint.x - startPoint.x);\n            var absDy = Math.abs(endPoint.y - startPoint.y);\n            var xSign = dx > 0 ? 1 : -1;\n            var ySign = dy > 0 ? 1 : -1;\n            var _g = [headShape.offsetForward, tailShape.offsetForward],\n              headOffset = _g[0],\n              tailOffset = _g[1];\n            var fHeadSize = headSize * strokeWidth; //factored head size\n            var fTailSize = tailSize * strokeWidth; //factored head size\n            // const { current: _headBox } = headBox;\n            var xHeadOffset = 0;\n            var yHeadOffset = 0;\n            var xTailOffset = 0;\n            var yTailOffset = 0;\n            var _headOffset = fHeadSize * headOffset;\n            var _tailOffset = fTailSize * tailOffset;\n            var cu = Number(curveness);\n            // gridRadius = Number(gridRadius);\n            if (!constants_1.cPaths.includes(path)) path = 'smooth';\n            if (path === 'straight') {\n              cu = 0;\n              path = 'smooth';\n            }\n            var biggerSide = headSize > tailSize ? headSize : tailSize;\n            var _calc = strokeWidth + strokeWidth * biggerSide / 2;\n            var excRight = _calc;\n            var excLeft = _calc;\n            var excUp = _calc;\n            var excDown = _calc;\n            excLeft += Number(_extendSVGcanvas);\n            excRight += Number(_extendSVGcanvas);\n            excUp += Number(_extendSVGcanvas);\n            excDown += Number(_extendSVGcanvas);\n            ////////////////////////////////////\n            // arrow point to point calculations\n            var x1 = 0,\n              x2 = absDx,\n              y1 = 0,\n              y2 = absDy;\n            if (dx < 0) _a = [x2, x1], x1 = _a[0], x2 = _a[1];\n            if (dy < 0) _b = [y2, y1], y1 = _b[0], y2 = _b[1];\n            ////////////////////////////////////\n            // arrow curviness and arrowhead placement calculations\n            if (cu === 0) {\n              // in case of straight path\n              var headAngel = Math.atan(absDy / absDx);\n              if (showHead) {\n                x2 -= fHeadSize * (1 - headOffset) * xSign * Math.cos(headAngel);\n                y2 -= fHeadSize * (1 - headOffset) * ySign * Math.sin(headAngel);\n                headAngel *= ySign;\n                if (xSign < 0) headAngel = (Math.PI - headAngel * xSign) * xSign;\n                xHeadOffset = Math.cos(headAngel) * _headOffset - Math.sin(headAngel) * fHeadSize / 2;\n                yHeadOffset = Math.cos(headAngel) * fHeadSize / 2 + Math.sin(headAngel) * _headOffset;\n                headOrient = headAngel * 180 / Math.PI;\n              }\n              var tailAngel = Math.atan(absDy / absDx);\n              if (showTail) {\n                x1 += fTailSize * (1 - tailOffset) * xSign * Math.cos(tailAngel);\n                y1 += fTailSize * (1 - tailOffset) * ySign * Math.sin(tailAngel);\n                tailAngel *= -ySign;\n                if (xSign > 0) tailAngel = (Math.PI - tailAngel * xSign) * xSign;\n                xTailOffset = Math.cos(tailAngel) * _tailOffset - Math.sin(tailAngel) * fTailSize / 2;\n                yTailOffset = Math.cos(tailAngel) * fTailSize / 2 + Math.sin(tailAngel) * _tailOffset;\n                tailOrient = tailAngel * 180 / Math.PI;\n              }\n            } else {\n              // in case of smooth path\n              if (endAnchorPosition === 'middle') {\n                // in case a middle anchor is chosen for endAnchor choose from which side to attach to the middle of the element\n                if (absDx > absDy) {\n                  endAnchorPosition = xSign ? 'left' : 'right';\n                } else {\n                  endAnchorPosition = ySign ? 'top' : 'bottom';\n                }\n              }\n              if (showHead) {\n                if (['left', 'right'].includes(endAnchorPosition)) {\n                  xHeadOffset += _headOffset * xSign;\n                  x2 -= fHeadSize * (1 - headOffset) * xSign; //same!\n                  yHeadOffset += fHeadSize * xSign / 2;\n                  if (endAnchorPosition === 'left') {\n                    headOrient = 0;\n                    if (xSign < 0) headOrient += 180;\n                  } else {\n                    headOrient = 180;\n                    if (xSign > 0) headOrient += 180;\n                  }\n                } else if (['top', 'bottom'].includes(endAnchorPosition)) {\n                  xHeadOffset += fHeadSize * -ySign / 2;\n                  yHeadOffset += _headOffset * ySign;\n                  y2 -= fHeadSize * ySign - yHeadOffset;\n                  if (endAnchorPosition === 'top') {\n                    headOrient = 270;\n                    if (ySign > 0) headOrient += 180;\n                  } else {\n                    headOrient = 90;\n                    if (ySign < 0) headOrient += 180;\n                  }\n                }\n              }\n            }\n            if (showTail && cu !== 0) {\n              if (['left', 'right'].includes(startAnchorPosition)) {\n                xTailOffset += _tailOffset * -xSign;\n                x1 += fTailSize * xSign + xTailOffset;\n                yTailOffset += -(fTailSize * xSign) / 2;\n                if (startAnchorPosition === 'left') {\n                  tailOrient = 180;\n                  if (xSign < 0) tailOrient += 180;\n                } else {\n                  tailOrient = 0;\n                  if (xSign > 0) tailOrient += 180;\n                }\n              } else if (['top', 'bottom'].includes(startAnchorPosition)) {\n                yTailOffset += _tailOffset * -ySign;\n                y1 += fTailSize * ySign + yTailOffset;\n                xTailOffset += fTailSize * ySign / 2;\n                if (startAnchorPosition === 'top') {\n                  tailOrient = 90;\n                  if (ySign > 0) tailOrient += 180;\n                } else {\n                  tailOrient = 270;\n                  if (ySign < 0) tailOrient += 180;\n                }\n              }\n            }\n            var arrowHeadOffset = {\n              x: xHeadOffset,\n              y: yHeadOffset\n            };\n            var arrowTailOffset = {\n              x: xTailOffset,\n              y: yTailOffset\n            };\n            var cpx1 = x1,\n              cpy1 = y1,\n              cpx2 = x2,\n              cpy2 = y2;\n            var curvesPossibilities = {};\n            if (path === 'smooth') curvesPossibilities = {\n              hh: function hh() {\n                //horizontal - from right to left or the opposite\n                cpx1 += absDx * cu * xSign;\n                cpx2 -= absDx * cu * xSign;\n              },\n              vv: function vv() {\n                //vertical - from top to bottom or opposite\n                cpy1 += absDy * cu * ySign;\n                cpy2 -= absDy * cu * ySign;\n              },\n              hv: function hv() {\n                // start horizontally then vertically\n                // from v side to h side\n                cpx1 += absDx * cu * xSign;\n                cpy2 -= absDy * cu * ySign;\n              },\n              vh: function vh() {\n                // start vertically then horizontally\n                // from h side to v side\n                cpy1 += absDy * cu * ySign;\n                cpx2 -= absDx * cu * xSign;\n              }\n            };else if (path === 'grid') {\n              curvesPossibilities = {\n                hh: function hh() {\n                  cpx1 += (absDx * gridBreak.relative + gridBreak.abs) * xSign;\n                  cpx2 -= (absDx * (1 - gridBreak.relative) - gridBreak.abs) * xSign;\n                  if (showHead) {\n                    cpx1 -= fHeadSize * (1 - headOffset) / 2 * xSign;\n                    cpx2 += fHeadSize * (1 - headOffset) / 2 * xSign;\n                  }\n                  if (showTail) {\n                    cpx1 -= fTailSize * (1 - tailOffset) / 2 * xSign;\n                    cpx2 += fTailSize * (1 - tailOffset) / 2 * xSign;\n                  }\n                },\n                vv: function vv() {\n                  cpy1 += (absDy * gridBreak.relative + gridBreak.abs) * ySign;\n                  cpy2 -= (absDy * (1 - gridBreak.relative) - gridBreak.abs) * ySign;\n                  if (showHead) {\n                    cpy1 -= fHeadSize * (1 - headOffset) / 2 * ySign;\n                    cpy2 += fHeadSize * (1 - headOffset) / 2 * ySign;\n                  }\n                  if (showTail) {\n                    cpy1 -= fTailSize * (1 - tailOffset) / 2 * ySign;\n                    cpy2 += fTailSize * (1 - tailOffset) / 2 * ySign;\n                  }\n                },\n                hv: function hv() {\n                  cpx1 = x2;\n                },\n                vh: function vh() {\n                  cpy1 = y2;\n                }\n              };\n            }\n            // smart select best curve for the current anchors\n            var selectedCurviness = '';\n            if (['left', 'right'].includes(startAnchorPosition)) selectedCurviness += 'h';else if (['bottom', 'top'].includes(startAnchorPosition)) selectedCurviness += 'v';else if (startAnchorPosition === 'middle') selectedCurviness += 'm';\n            if (['left', 'right'].includes(endAnchorPosition)) selectedCurviness += 'h';else if (['bottom', 'top'].includes(endAnchorPosition)) selectedCurviness += 'v';else if (endAnchorPosition === 'middle') selectedCurviness += 'm';\n            if (absDx > absDy) selectedCurviness = selectedCurviness.replace(/m/g, 'h');else selectedCurviness = selectedCurviness.replace(/m/g, 'v');\n            curvesPossibilities[selectedCurviness]();\n            cpx1 += _cpx1Offset;\n            cpy1 += _cpy1Offset;\n            cpx2 += _cpx2Offset;\n            cpy2 += _cpy2Offset;\n            ////////////////////////////////////\n            // canvas smart size adjustments\n            var _h = buzzier_1.buzzierMinSols(x1, cpx1, cpx2, x2),\n              xSol1 = _h[0],\n              xSol2 = _h[1];\n            var _j = buzzier_1.buzzierMinSols(y1, cpy1, cpy2, y2),\n              ySol1 = _j[0],\n              ySol2 = _j[1];\n            if (xSol1 < 0) excLeft += -xSol1;\n            if (xSol2 > absDx) excRight += xSol2 - absDx;\n            if (ySol1 < 0) excUp += -ySol1;\n            if (ySol2 > absDy) excDown += ySol2 - absDy;\n            if (path === 'grid') {\n              excLeft += _calc;\n              excRight += _calc;\n              excUp += _calc;\n              excDown += _calc;\n            }\n            x1 += excLeft;\n            x2 += excLeft;\n            y1 += excUp;\n            y2 += excUp;\n            cpx1 += excLeft;\n            cpx2 += excLeft;\n            cpy1 += excUp;\n            cpy2 += excUp;\n            var cw = absDx + excLeft + excRight,\n              ch = absDy + excUp + excDown;\n            cx0 -= excLeft;\n            cy0 -= excUp;\n            //labels\n            var bzx = buzzier_1.bzFunction(x1, cpx1, cpx2, x2);\n            var bzy = buzzier_1.bzFunction(y1, cpy1, cpy2, y2);\n            var labelStartPos = {\n              x: bzx(0.01),\n              y: bzy(0.01)\n            };\n            var labelMiddlePos = {\n              x: bzx(0.5),\n              y: bzy(0.5)\n            };\n            var labelEndPos = {\n              x: bzx(0.99),\n              y: bzy(0.99)\n            };\n            var arrowPath;\n            if (path === 'grid') {\n              // todo: support gridRadius\n              //  arrowPath = `M ${x1} ${y1} L  ${cpx1 - 10} ${cpy1} a10,10 0 0 1 10,10\n              // L ${cpx2} ${cpy2 - 10} a10,10 0 0 0 10,10 L  ${x2} ${y2}`;\n              arrowPath = \"M \" + x1 + \" \" + y1 + \" L  \" + cpx1 + \" \" + cpy1 + \" L \" + cpx2 + \" \" + cpy2 + \" \" + x2 + \" \" + y2;\n            } else if (path === 'smooth') arrowPath = \"M \" + x1 + \" \" + y1 + \" C \" + cpx1 + \" \" + cpy1 + \", \" + cpx2 + \" \" + cpy2 + \", \" + x2 + \" \" + y2;\n            return {\n              cx0: cx0,\n              cy0: cy0,\n              x1: x1,\n              x2: x2,\n              y1: y1,\n              y2: y2,\n              cw: cw,\n              ch: ch,\n              cpx1: cpx1,\n              cpy1: cpy1,\n              cpx2: cpx2,\n              cpy2: cpy2,\n              dx: dx,\n              dy: dy,\n              absDx: absDx,\n              absDy: absDy,\n              headOrient: headOrient,\n              tailOrient: tailOrient,\n              labelStartPos: labelStartPos,\n              labelMiddlePos: labelMiddlePos,\n              labelEndPos: labelEndPos,\n              excLeft: excLeft,\n              excRight: excRight,\n              excUp: excUp,\n              excDown: excDown,\n              headOffset: _headOffset,\n              arrowHeadOffset: arrowHeadOffset,\n              arrowTailOffset: arrowTailOffset,\n              startPoints: startPoints,\n              endPoints: endPoints,\n              mainDivPos: mainDivPos,\n              xSign: xSign,\n              ySign: ySign,\n              lineLength: (_d = (_c = lineRef.current) === null || _c === void 0 ? void 0 : _c.getTotalLength()) !== null && _d !== void 0 ? _d : 0,\n              fHeadSize: fHeadSize,\n              fTailSize: fTailSize,\n              arrowPath: arrowPath\n            };\n          };\n          exports.getPosition = getPosition;\n\n          /***/\n        },\n\n        /***/\"./src/Xarrow/utils/index.ts\":\n        /*!***********************************!*\\\n          !*** ./src/Xarrow/utils/index.ts ***!\n          \\***********************************/\n        /***/\n        function srcXarrowUtilsIndexTs(__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.getSvgPos = exports.getElemPos = exports.getShortestLine = exports.xStr2absRelative = exports.factorDpathStr = exports.getElementByPropGiven = void 0;\n          var getElementByPropGiven = function getElementByPropGiven(ref) {\n            var myRef;\n            if (typeof ref === 'string') {\n              // myRef = document.getElementById(ref);\n              myRef = document.getElementById(ref);\n            } else myRef = ref === null || ref === void 0 ? void 0 : ref.current;\n            return myRef;\n          };\n          exports.getElementByPropGiven = getElementByPropGiven;\n          // receives string representing a d path and factoring only the numbers\n          var factorDpathStr = function factorDpathStr(d, factor) {\n            var l = d.split(/(\\d+(?:\\.\\d+)?)/);\n            l = l.map(function (s) {\n              if (Number(s)) return (Number(s) * factor).toString();else return s;\n            });\n            return l.join('');\n          };\n          exports.factorDpathStr = factorDpathStr;\n          // return relative,abs\n          var xStr2absRelative = function xStr2absRelative(str) {\n            if (typeof str !== 'string') return {\n              abs: 0,\n              relative: 0.5\n            };\n            var sp = str.split('%');\n            var absLen = 0,\n              percentLen = 0;\n            if (sp.length == 1) {\n              var p = parseFloat(sp[0]);\n              if (!isNaN(p)) {\n                absLen = p;\n                return {\n                  abs: absLen,\n                  relative: 0\n                };\n              }\n            } else if (sp.length == 2) {\n              var _a = [parseFloat(sp[0]), parseFloat(sp[1])],\n                p1 = _a[0],\n                p2 = _a[1];\n              if (!isNaN(p1)) percentLen = p1 / 100;\n              if (!isNaN(p2)) absLen = p2;\n              if (!isNaN(p1) || !isNaN(p2)) return {\n                abs: absLen,\n                relative: percentLen\n              };\n            }\n          };\n          exports.xStr2absRelative = xStr2absRelative;\n          var dist = function dist(p1, p2) {\n            //length of line\n            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n          };\n          var getShortestLine = function getShortestLine(sPoints, ePoints) {\n            // closes tPair Of Points which feet to the specified anchors\n            var minDist = Infinity,\n              d = Infinity;\n            var closestPair;\n            sPoints.forEach(function (sp) {\n              ePoints.forEach(function (ep) {\n                d = dist(sp, ep);\n                if (d < minDist) {\n                  minDist = d;\n                  closestPair = {\n                    chosenStart: sp,\n                    chosenEnd: ep\n                  };\n                }\n              });\n            });\n            return closestPair;\n          };\n          exports.getShortestLine = getShortestLine;\n          var getElemPos = function getElemPos(elem) {\n            if (!elem) return {\n              x: 0,\n              y: 0,\n              right: 0,\n              bottom: 0\n            };\n            var pos = elem.getBoundingClientRect();\n            return {\n              x: pos.left,\n              y: pos.top,\n              right: pos.right,\n              bottom: pos.bottom\n            };\n          };\n          exports.getElemPos = getElemPos;\n          var getSvgPos = function getSvgPos(svgRef) {\n            if (!svgRef.current) return {\n              x: 0,\n              y: 0\n            };\n            var _a = svgRef.current.getBoundingClientRect(),\n              xarrowElemX = _a.left,\n              xarrowElemY = _a.top;\n            var xarrowStyle = getComputedStyle(svgRef.current);\n            var xarrowStyleLeft = Number(xarrowStyle.left.slice(0, -2));\n            var xarrowStyleTop = Number(xarrowStyle.top.slice(0, -2));\n            return {\n              x: xarrowElemX - xarrowStyleLeft,\n              y: xarrowElemY - xarrowStyleTop\n            };\n          };\n          exports.getSvgPos = getSvgPos;\n\n          /***/\n        },\n\n        /***/\"./src/Xwrapper.tsx\":\n        /*!**************************!*\\\n          !*** ./src/Xwrapper.tsx ***!\n          \\**************************/\n        /***/\n        function srcXwrapperTsx(__unused_webpack_module, exports, __webpack_require__) {\n          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            Object.defineProperty(o, k2, {\n              enumerable: true,\n              get: function get() {\n                return m[k];\n              }\n            });\n          } : function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            o[k2] = m[k];\n          });\n          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n            Object.defineProperty(o, \"default\", {\n              enumerable: true,\n              value: v\n            });\n          } : function (o, v) {\n            o[\"default\"] = v;\n          });\n          var __importStar = this && this.__importStar || function (mod) {\n            if (mod && mod.__esModule) return mod;\n            var result = {};\n            if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n            __setModuleDefault(result, mod);\n            return result;\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.XarrowContext = exports.XelemContext = void 0;\n          var react_1 = __importStar(__webpack_require__( /*! react */\"react\"));\n          exports.XelemContext = react_1.default.createContext(null);\n          exports.XarrowContext = react_1.default.createContext(null);\n          var updateRef = {};\n          var updateRefCount = 0;\n          var log = console.log;\n          var XarrowProvider = function XarrowProvider(_a) {\n            var children = _a.children,\n              instanceCount = _a.instanceCount;\n            var _b = react_1.useState({}),\n              setRender = _b[1];\n            var updateXarrow = function updateXarrow() {\n              return setRender({});\n            };\n            react_1.useEffect(function () {\n              instanceCount.current = updateRefCount; // so this instance would know what is id\n              updateRef[instanceCount.current] = updateXarrow;\n            }, []);\n            // log('XarrowProvider', updateRefCount);\n            return react_1.default.createElement(exports.XarrowContext.Provider, {\n              value: updateXarrow\n            }, children);\n          };\n          var XelemProvider = function XelemProvider(_a) {\n            var children = _a.children,\n              instanceCount = _a.instanceCount;\n            return react_1.default.createElement(exports.XelemContext.Provider, {\n              value: updateRef[instanceCount.current]\n            }, children);\n          };\n          var Xwrapper = function Xwrapper(_a) {\n            var children = _a.children;\n            var instanceCount = react_1.useRef(updateRefCount);\n            var _b = react_1.useState({}),\n              setRender = _b[1];\n            react_1.useEffect(function () {\n              updateRefCount++;\n              setRender({});\n              return function () {\n                delete updateRef[instanceCount.current];\n              };\n            }, []);\n            return react_1.default.createElement(XelemProvider, {\n              instanceCount: instanceCount\n            }, react_1.default.createElement(XarrowProvider, {\n              instanceCount: instanceCount\n            }, children));\n          };\n          exports.default = Xwrapper;\n\n          /***/\n        },\n\n        /***/\"./src/constants.tsx\":\n        /*!***************************!*\\\n          !*** ./src/constants.tsx ***!\n          \\***************************/\n        /***/\n        function srcConstantsTsx(__unused_webpack_module, exports, __webpack_require__) {\n          var __importDefault = this && this.__importDefault || function (mod) {\n            return mod && mod.__esModule ? mod : {\n              \"default\": mod\n            };\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.cArrowShapes = exports.arrowShapes = exports.cSvgElems = exports.cPaths = exports.cAnchorEdge = void 0;\n          // constants used for typescript and proptypes definitions\n          var react_1 = __importDefault(__webpack_require__( /*! react */\"react\"));\n          exports.cAnchorEdge = ['middle', 'left', 'right', 'top', 'bottom', 'auto'];\n          exports.cPaths = ['smooth', 'grid', 'straight'];\n          exports.cSvgElems = ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'];\n          //default arrows svgs\n          exports.arrowShapes = {\n            arrow1: {\n              svgElem: react_1.default.createElement(\"path\", {\n                d: \"M 0 0 L 1 0.5 L 0 1 L 0.25 0.5 z\"\n              }),\n              offsetForward: 0.25\n            },\n            heart: {\n              svgElem: react_1.default.createElement(\"path\", {\n                d: \"M 0,0.25 A 0.125,0.125 0,0,1 0.5,0.25 A 0.125,0.125 0,0,1 1,0.25 Q 1,0.625 0.5,1 Q 0,0.625 0,0.25 z\"\n              }),\n              offsetForward: 0.1\n            },\n            circle: {\n              svgElem: react_1.default.createElement(\"circle\", {\n                r: 0.5,\n                cx: 0.5,\n                cy: 0.5\n              }),\n              offsetForward: 0\n            }\n          };\n          exports.cArrowShapes = Object.keys(exports.arrowShapes);\n\n          /***/\n        },\n\n        /***/\"./src/index.tsx\":\n        /*!***********************!*\\\n          !*** ./src/index.tsx ***!\n          \\***********************/\n        /***/\n        function srcIndexTsx(__unused_webpack_module, exports, __webpack_require__) {\n          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            Object.defineProperty(o, k2, {\n              enumerable: true,\n              get: function get() {\n                return m[k];\n              }\n            });\n          } : function (o, m, k, k2) {\n            if (k2 === undefined) k2 = k;\n            o[k2] = m[k];\n          });\n          var __exportStar = this && this.__exportStar || function (m, exports) {\n            for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n          };\n          var __importDefault = this && this.__importDefault || function (mod) {\n            return mod && mod.__esModule ? mod : {\n              \"default\": mod\n            };\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.useXarrow = exports.Xwrapper = exports.default = void 0;\n          var Xarrow_1 = __webpack_require__( /*! ./Xarrow/Xarrow */\"./src/Xarrow/Xarrow.tsx\");\n          Object.defineProperty(exports, \"default\", {\n            enumerable: true,\n            get: function get() {\n              return __importDefault(Xarrow_1).default;\n            }\n          });\n          __exportStar(__webpack_require__( /*! ./types */\"./src/types.ts\"), exports);\n          __exportStar(__webpack_require__( /*! ./constants */\"./src/constants.tsx\"), exports);\n          var Xwrapper_1 = __webpack_require__( /*! ./Xwrapper */\"./src/Xwrapper.tsx\");\n          Object.defineProperty(exports, \"Xwrapper\", {\n            enumerable: true,\n            get: function get() {\n              return __importDefault(Xwrapper_1).default;\n            }\n          });\n          var useXarrow_1 = __webpack_require__( /*! ./useXarrow */\"./src/useXarrow.tsx\");\n          Object.defineProperty(exports, \"useXarrow\", {\n            enumerable: true,\n            get: function get() {\n              return __importDefault(useXarrow_1).default;\n            }\n          });\n\n          /***/\n        },\n\n        /***/\"./src/types.ts\":\n        /*!**********************!*\\\n          !*** ./src/types.ts ***!\n          \\**********************/\n        /***/\n        function srcTypesTs(__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n\n          /***/\n        },\n\n        /***/\"./src/useXarrow.tsx\":\n        /*!***************************!*\\\n          !*** ./src/useXarrow.tsx ***!\n          \\***************************/\n        /***/\n        function srcUseXarrowTsx(__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          var react_1 = __webpack_require__( /*! react */\"react\");\n          var Xwrapper_1 = __webpack_require__( /*! ./Xwrapper */\"./src/Xwrapper.tsx\");\n          var useXarrow = function useXarrow() {\n            var _a = react_1.useState({}),\n              setRender = _a[1];\n            var reRender = function reRender() {\n              return setRender({});\n            };\n            var updateXarrow = react_1.useContext(Xwrapper_1.XelemContext);\n            if (!updateXarrow) updateXarrow = function updateXarrow() {};\n            // throw new Error(\n            //   \"'Xwrapper' is required around element using 'useXarrow' hook! wrap your xarrows and connected elements with Xwrapper! \"\n            // );\n            react_1.useLayoutEffect(function () {\n              updateXarrow();\n            });\n            return reRender;\n          };\n          exports.default = useXarrow;\n\n          /***/\n        },\n\n        /***/\"lodash\":\n        /*!*************************!*\\\n          !*** external \"lodash\" ***!\n          \\*************************/\n        /***/\n        function lodash(module) {\n          module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;\n\n          /***/\n        },\n\n        /***/\"prop-types\":\n        /*!*****************************!*\\\n          !*** external \"prop-types\" ***!\n          \\*****************************/\n        /***/\n        function propTypes(module) {\n          module.exports = __WEBPACK_EXTERNAL_MODULE_prop_types__;\n\n          /***/\n        },\n\n        /***/\"react\":\n        /*!************************!*\\\n          !*** external \"react\" ***!\n          \\************************/\n        /***/\n        function react(module) {\n          module.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n\n          /***/\n        }\n\n        /******/\n      };\n      /************************************************************************/\n      /******/ // The module cache\n      /******/\n      var __webpack_module_cache__ = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __webpack_require__(moduleId) {\n        /******/ // Check if module is in cache\n        /******/var cachedModule = __webpack_module_cache__[moduleId];\n        /******/\n        if (cachedModule !== undefined) {\n          /******/return cachedModule.exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/id: moduleId,\n          /******/loaded: false,\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.loaded = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /******/ // expose the module cache\n      /******/\n      __webpack_require__.c = __webpack_module_cache__;\n      /******/\n      /************************************************************************/\n      /******/ /* webpack/runtime/define property getters */\n      /******/\n      !function () {\n        /******/ // define getter functions for harmony exports\n        /******/__webpack_require__.d = function (exports, definition) {\n          /******/for (var key in definition) {\n            /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n              /******/Object.defineProperty(exports, key, {\n                enumerable: true,\n                get: definition[key]\n              });\n              /******/\n            }\n            /******/\n          }\n          /******/\n        };\n        /******/\n      }();\n      /******/\n      /******/ /* webpack/runtime/hasOwnProperty shorthand */\n      /******/\n      !function () {\n        /******/__webpack_require__.o = function (obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        };\n        /******/\n      }();\n      /******/\n      /******/ /* webpack/runtime/make namespace object */\n      /******/\n      !function () {\n        /******/ // define __esModule on exports\n        /******/__webpack_require__.r = function (exports) {\n          /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            /******/Object.defineProperty(exports, Symbol.toStringTag, {\n              value: 'Module'\n            });\n            /******/\n          }\n          /******/\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          /******/\n        };\n        /******/\n      }();\n      /******/\n      /******/ /* webpack/runtime/node module decorator */\n      /******/\n      !function () {\n        /******/__webpack_require__.nmd = function (module) {\n          /******/module.paths = [];\n          /******/\n          if (!module.children) module.children = [];\n          /******/\n          return module;\n          /******/\n        };\n        /******/\n      }();\n      /******/\n      /************************************************************************/\n      /******/\n      /******/ // module cache are used so entry inlining is disabled\n      /******/ // startup\n      /******/ // Load entry module and return exports\n      /******/\n      var __webpack_exports__ = __webpack_require__(__webpack_require__.s = \"./src/index.tsx\");\n      /******/\n      /******/\n      return __webpack_exports__;\n      /******/\n    }()\n  );\n});","map":null,"metadata":{},"sourceType":"script"}