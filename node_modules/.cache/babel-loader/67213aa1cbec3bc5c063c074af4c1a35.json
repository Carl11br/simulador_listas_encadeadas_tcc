{"ast":null,"code":"export var insereFuncaoSimples = {\n  executionOrder: [{\n    line: 6,\n    animation: '',\n    description: 'A função \"InsereInicio\" recebe o ponteiro para a lista e o valor a ser inserido como parâmetros. Ela retornará a lista com o novo elemento;'\n  }, {\n    line: 7,\n    animation: 'createNewPointer',\n    description: 'O ponteiro(*) \"novo\" é declarado e chama a função \"CriarElemento\" passando o valor recebido como parâmetro.'\n  }, {\n    line: 0,\n    animation: '',\n    description: 'A função \"CriarElemento\" recebe um valor e retorna um ponteiro para o novo elemento criado.'\n  }, {\n    line: 1,\n    animation: 'createNewElement',\n    description: 'O ponteiro(*) \"resp\" é declarado e recebe o endereço de memória alocado para o novo elemento.'\n  }, {\n    line: 2,\n    animation: 'attributeValueToNewElement',\n    description: 'Através do ponteiro \"resp\" é atribuído ao novo elemento o valor recebido.'\n  }, {\n    line: 3,\n    animation: 'pointNewElementToNull',\n    description: 'Através do ponteiro \"resp\" é atribuído ao novo elemento o próximo elemento (que até o momento é NULL).'\n  }, {\n    line: 4,\n    animation: 'pointNewPointerToNewElement',\n    description: 'O ponteiro \"resp\" (que aponta para o novo elemento) é retornado pela função \"CriarElemento\".'\n  }, {\n    line: 8,\n    animation: 'pointNewElementToPosition',\n    description: 'Agora que o ponteiro \"novo\" recebeu o novo elemento e como estamos inserindo no início da lista, diremos que o próximo elemento após o novo elemento vai ser o atual primeiro elemento da lista.'\n  }, {\n    line: 9,\n    animation: 'pointAntToNewElement',\n    description: 'Depois disso, diremos que o primeiro elemento da lista vai ser o novo elemento.'\n  }, {\n    line: 10,\n    animation: '',\n    description: 'Por fim, retornamos a lista já com o novo elemento inserido.'\n  }],\n  code: ['struct elemento *CriaElemento(int numero){', '   struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));', '   resp->valor = numero;', '   resp->prox = NULL;', '   return resp;', '}', 'struct elemento *InsereInicio(elemento *lista, int numero){', '   struct elemento *novo = CriaElemento(numero);', '   novo->prox = lista;', '   lista = novo;', '   return lista;', '}']\n};\nexport var insereFimFuncaoSimples = {\n  executionOrder: [{\n    line: 6,\n    animation: '',\n    description: 'A função \"InsereFim\" recebe o ponteiro para a lista e o valor a ser inserido como parâmetros. Ela retornará a lista com o novo elemento;'\n  }, {\n    line: 7,\n    animation: '',\n    description: 'O ponteiro(*) \"aux\" é declarado'\n  }, {\n    line: 8,\n    animation: 'createNewPointer',\n    description: 'O ponteiro(*) \"novo\" é declarado e chama a função \"CriarElemento\" passando o valor recebido como parâmetro.'\n  }, {\n    line: 0,\n    animation: '',\n    description: 'A função \"CriarElemento\" recebe um valor e retorna um ponteiro para o novo elemento criado.'\n  }, {\n    line: 1,\n    animation: 'createNewElement',\n    description: 'O ponteiro(*) \"resp\" é declarado e recebe o endereço de memória alocado para o novo elemento.'\n  }, {\n    line: 2,\n    animation: 'attributeValueToNewElement',\n    description: 'Através do ponteiro \"resp\" é atribuído ao novo elemento o valor recebido.'\n  }, {\n    line: 3,\n    animation: 'pointNewElementToNull',\n    description: 'Através do ponteiro \"resp\" é atribuído ao novo elemento o próximo elemento (que até o momento é NULL).'\n  }, {\n    line: 4,\n    animation: 'pointNewPointerToNewElement',\n    description: 'O ponteiro \"resp\" (que aponta para o novo elemento) é retornado pela função \"CriarElemento\".'\n  }, {\n    line: 5,\n    animation: '',\n    description: ''\n  }, {\n    line: 9,\n    animation: 'if-verifyEmptyList-12',\n    description: 'Verifica se a lista está vazia, se estiver, o primeiro elemento da lista vai ser o novo elemento.'\n  }, {\n    line: 10,\n    animation: 'pointAntToNewElement',\n    description: ''\n  }, {\n    line: 11,\n    animation: 'jumpToLine-17',\n    description: ''\n  }, {\n    line: 12,\n    animation: '',\n    description: ''\n  }, {\n    line: 13,\n    animation: 'pointAuxToPosition-0',\n    description: ''\n  }, {\n    line: 14,\n    animation: 'searchIndex',\n    description: 'Busca o último elemento da lista.'\n  }, {\n    line: 15,\n    animation: 'pointAntToNewElement',\n    description: 'Ao encontrar o último elemento, o próximo elemento dele vai ser o novo elemento.'\n  }, {\n    line: 16,\n    animation: '',\n    description: ''\n  }, {\n    line: 17,\n    animation: '',\n    description: 'Retorna a lista com o novo elemento inserido.'\n  }],\n  code: ['struct elemento *CriaElemento(int numero){', '    struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));', '    resp->valor = numero;', '    resp->prox = NULL;', '    return resp;', '}', 'struct elemento *InsereFim(struct elemento *lista, int numero){', '    struct elemento *aux;', '    struct elemento *novo = CriaElemento(numero);', '    if (lista == NULL){', '       lista = novo;', '    }', '    else{', '        aux = lista;', \"        while (aux->prox != NULL){\\n                aux = aux->prox;\\n            }\", '        aux->prox = novo;', '    }', '    return lista;', '}']\n};\nexport var insereIndiceFuncaoSimples = {\n  executionOrder: [{\n    line: 6,\n    animation: '',\n    description: 'A função \"InsereIndice\" recebe o ponteiro para a lista e o valor a ser inserido como parâmetros. Ela retornará a lista com o novo elemento;'\n  }, {\n    line: 7,\n    animation: '',\n    description: 'O ponteiro(*) \"aux\" é declarado'\n  }, {\n    line: 8,\n    animation: 'createNewPointer',\n    description: 'O ponteiro(*) \"novo\" é declarado e chama a função \"CriarElemento\" passando o valor recebido como parâmetro.'\n  }, {\n    line: 0,\n    animation: '',\n    description: 'A função \"CriarElemento\" recebe um valor e retorna um ponteiro para o novo elemento criado.'\n  }, {\n    line: 1,\n    animation: 'createNewElement',\n    description: 'O ponteiro(*) \"resp\" é declarado e recebe o endereço de memória alocado para o novo elemento.'\n  }, {\n    line: 2,\n    animation: 'attributeValueToNewElement',\n    description: 'Através do ponteiro \"resp\" é atribuído ao novo elemento o valor recebido.'\n  }, {\n    line: 3,\n    animation: 'pointNewElementToNull',\n    description: 'Através do ponteiro \"resp\" é atribuído ao novo elemento o próximo elemento (que até o momento é NULL).'\n  }, {\n    line: 4,\n    animation: 'pointNewPointerToNewElement',\n    description: 'O ponteiro \"resp\" (que aponta para o novo elemento) é retornado pela função \"CriarElemento\".'\n  }, {\n    line: 5,\n    animation: '',\n    description: ''\n  }, {\n    line: 9,\n    animation: '',\n    description: 'A variável indiceAtual é criada e inicializada com o valor 1, ou seja, a segunda posição da lista.'\n  }, {\n    line: 10,\n    animation: 'if-verifyEmptyList-13',\n    description: 'Verifica se a lista está vazia, se estiver, o primeiro elemento da lista vai ser o novo elemento.'\n  }, {\n    line: 11,\n    animation: 'pointAntToNewElement',\n    description: 'Se a lista estiver vazia, insere o elemento na primeira posição.'\n  }, {\n    line: 12,\n    animation: 'jumpToLine-24',\n    description: ''\n  }, {\n    line: 13,\n    animation: 'if-indexEqualsStart-17',\n    description: 'Verifica se índice que o elemento deve ser inserido é o começo da lista.'\n  }, {\n    line: 14,\n    animation: 'pointNewElementToPosition',\n    description: 'Aponta o proxímo elemento do novo elemento como o primeiro elemento da lista.'\n  }, {\n    line: 15,\n    animation: 'pointAntToNewElement',\n    description: 'Aponta o início da lista para o novo elemento.'\n  }, {\n    line: 16,\n    animation: 'jumpToLine-24',\n    description: ''\n  }, {\n    line: 17,\n    animation: '',\n    description: 'Caso contrário, busca o índice a ser inserido na lista.'\n  }, {\n    line: 18,\n    animation: 'pointAntToPosition-0',\n    description: 'Aponta o ponteiro \"ant\" para o primeiro elemento da lista.'\n  }, {\n    line: 19,\n    animation: 'pointAuxToPosition-1',\n    description: 'Aponta o ponteiro \"aux\" para o segundo elemento da lista.'\n  }, {\n    line: 20,\n    animation: 'searchIndex-nullable-withAnt',\n    description: 'Enquanto o ponteiro \"aux\" não for nulo e o índice atual for diferente do índice a ser inserido, o ponteiro \"ant\" aponta para o elemento que o ponteiro \"aux\" aponta e o ponteiro \"aux\" aponta para o próximo elemento.'\n  }, {\n    line: 21,\n    animation: 'pointAntToNewElement',\n    description: 'Aponta o elemento novo como próximo elemento do índice anterior ao qual ele deve ser inserido'\n  }, {\n    line: 22,\n    animation: 'pointNewElementToPosition',\n    description: 'Aponta o próximo elemento do novo elemento para o elemento que o ponteiro \"aux\" aponta.'\n  }, {\n    line: 23,\n    animation: '',\n    description: ''\n  }, {\n    line: 24,\n    animation: '',\n    description: 'Retorna a lista com o novo elemento inserido.'\n  }],\n  code: ['struct elemento *CriaElemento(int numero){', '    struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));', '    resp->valor = numero;', '    resp->prox = NULL;', '    return resp;', '}', 'struct elemento *InsereIndice(struct elemento *lista, int numero, int indice){', ' struct elemento *aux;', ' struct elemento *novo = CriaElemento(numero);', ' int indiceAtual = 1;', ' if (lista == NULL){', '   lista = novo;', ' }', ' else if (indice == 0){', '   novo->prox = lista;', '   lista = novo;', ' }', ' else {', '   ant = lista;', '   aux = lista->prox;', \"   while (aux != NULL && indiceAtual != indice){\\n          ant = aux;\\n          aux = aux->prox;\\n          indiceAtual++;\\n        }\", '   ant->prox = novo;', '   novo->prox = aux;', ' }', ' return lista;', '}']\n};\nexport var buscarPorValorSimples = {\n  executionOrder: [{\n    line: 0,\n    animation: '',\n    description: 'A função \"BuscaPorValor\" recebe o ponteiro para a lista e o valor a ser buscado como parâmetros. Ela retornará o elemento encontrado ou o valor NULL;'\n  }, {\n    line: 1,\n    animation: 'pointAuxToPosition-0',\n    description: 'O ponteiro(*) \"aux\" é declarado apontando para o primeiro elemento da lista'\n  }, {\n    line: 2,\n    animation: 'searchValue-nullable',\n    description: 'Enquanto não chegar ao fim da lista e enquanto o valor não for encontrado, o ponteiro(*) \"aux\" será atualizado para apontar para o próximo elemento.'\n  }, {\n    line: 3,\n    animation: 'showElementFound',\n    description: 'Retorna o ponteiro(*) \"aux\", que pode estar apontando para o elemento encontrado ou para NULL, caso o elemento não tenha sido encontrado.'\n  }],\n  code: ['struct elemento *BuscaPorValor(struct elemento *lista, int numero){', ' struct elemento *aux = lista;', \" while (aux != NULL && aux->valor != numero),\\n          aux = aux->prox;\", ' return aux;', '}']\n};\nexport var buscarPorIndiceSimples = {\n  executionOrder: [{\n    line: 0,\n    animation: '',\n    description: 'A função \"BuscaPorIndice\" recebe o ponteiro para a lista e o índice a ser buscado como parâmetros. Ela retornará o elemento encontrado ou o valor NULL;'\n  }, {\n    line: 1,\n    animation: '',\n    description: 'A variável indiceAtual, que armazena em qual indice o ponteiro \"aux\" está, é inicializada com o valor 0.'\n  }, {\n    line: 2,\n    animation: 'pointAuxToPosition-0',\n    description: 'O ponteiro(*) \"aux\" é declarado apontando para o primeiro elemento da lista'\n  }, {\n    line: 3,\n    animation: 'searchIndex-nullable--showElement',\n    description: 'Enquanto não chegar ao fim da lista e enquanto o índice não for encontrado, o ponteiro(*) \"aux\" será atualizado para apontar para o próximo elemento e o indiceAtual será incrementado em uma unidade.'\n  }, {\n    line: 4,\n    animation: 'showElementFound',\n    description: 'Retorna o ponteiro(*) \"aux\", que pode estar apontando para o elemento encontrado ou para NULL, caso o elemento não tenha sido encontrado.'\n  }],\n  code: ['struct elemento *BuscaPorIndice(struct elemento *lista, int indice){', '  int indiceAtual = 0;', '  struct elemento *aux = lista;', \"  while (aux != NULL && indiceAtual != indice){\\n          aux = aux->prox;\\n          indiceAtual++;\", '  return aux;', '}']\n};\nexport var removerPorValorSimples = {\n  executionOrder: [{\n    line: 0,\n    animation: '',\n    description: 'A função \"RemovePorValor\" recebe o ponteiro para a lista e o valor do elemento a ser revomido como parâmetros. Ela retornará a lista sem o elemento;'\n  }, {\n    line: 1,\n    animation: 'if-verifyEmptyList-4',\n    description: 'Verifica se a lista está vazia e, caso esteja, não terá elemento a ser removido.'\n  }, {\n    line: 2,\n    animation: 'jumpToLine-20',\n    description: 'Retorna a própria lista, já que não há elemento a ser removido.'\n  }, {\n    line: 3,\n    animation: '',\n    description: ''\n  }, {\n    line: 4,\n    animation: 'pointAntToPosition-0',\n    description: 'O ponteiro(*) \"ant\" é declarado apontando para o primeiro elemento da lista'\n  }, {\n    line: 5,\n    animation: 'pointAuxToPosition-1',\n    description: 'O ponteiro(*) \"aux\" é declarado apontando para o segundo elemento da lista'\n  }, {\n    line: 6,\n    animation: 'if-antEqualElement-10',\n    description: 'Verifica se o primeiro elemento (apontado por \"ant\") é o elemento a ser removido. Caso seja, o ponteiro \"ant\" apontará para o segundo elemento da lista e o primeiro elemento será removido.'\n  }, {\n    line: 7,\n    animation: 'pointListToAux',\n    description: 'Já que o primeiro elemento da lista é o elemento a ser removido, aponta o inicio da lista para o segundo elemento.'\n  }, {\n    line: 8,\n    animation: 'freeAnt',\n    description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"ant\", removendo o elemento da lista.'\n  }, {\n    line: 9,\n    animation: 'jumpToLine-18',\n    description: ''\n  }, {\n    line: 10,\n    animation: '',\n    description: 'Caso o primeiro elemento não seja o elemento a ser removido, o elemento deve ser procurado na lista.'\n  }, {\n    line: 11,\n    animation: 'searchValue-nullable-withAnt',\n    description: 'Enquanto não chegarmos ao fim da lista ou encontrarmos o elemento, avaçamos cada ponteiro(*) para o respectivo próximo elemento.'\n  }, {\n    line: 12,\n    animation: 'if-auxNotNull-18',\n    description: 'Se saírmos da busca e \"aux\" for diferente de NULL, significa que o elemento foi encontrado.'\n  }, {\n    line: 13,\n    animation: 'antElementPointsToAuxProx',\n    description: 'Ligamos o elemento anterior ao elemento que será excluído, com o elemento posterior ao elemento que será excluído. Desvinculando esse elemento da lista.'\n  }, {\n    line: 14,\n    animation: 'freeAux',\n    description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"aux\", removendo o elemento da lista.'\n  }, {\n    line: 15,\n    animation: '',\n    description: ''\n  }, {\n    line: 16,\n    animation: '',\n    description: ''\n  }, {\n    line: 17,\n    animation: '',\n    description: ''\n  }, {\n    line: 18,\n    animation: '',\n    description: 'Retorna retorna a lista sem o elemento removido.'\n  }],\n  code: ['struct elemento *RemovePorValor(struct elemento *lista, int numero){', ' if (lista == NULL){', '  return NULL; ', ' }', ' struct elemento *ant = lista;', ' struct elemento *aux = ant->prox;', ' if (ant->valor == numero){', '   lista = aux;', '   free(ant);', ' }', ' else{', \"   while (aux != NULL && aux->valor != numero){\\n          ant = aux;\\n          aux = aux->prox;\\n        }\", '   if (aux != NULL){', '     ant->prox = aux->prox;', '     free(aux);', '   }', ' }', ' return lista;', '}']\n};\nexport var removerPorIndiceSimples = {\n  executionOrder: [{\n    line: 0,\n    animation: '',\n    description: 'A função \"RemovePorIndice\" recebe o ponteiro para a lista e o índice do elemento a ser revomido como parâmetros. Ela retornará a lista sem o elemento;'\n  }, {\n    line: 1,\n    animation: 'if-verifyEmptyList-4',\n    description: 'Verifica se a lista está vazia e, caso esteja, não terá elemento a ser removido.'\n  }, {\n    line: 2,\n    animation: 'jumpToLine-20',\n    description: 'Retorna a própria lista, já que não há elemento a ser removido.'\n  }, {\n    line: 3,\n    animation: '',\n    description: ''\n  }, {\n    line: 4,\n    animation: '',\n    description: 'Seta o índice inicial para o segundo elemento da lista.'\n  }, {\n    line: 5,\n    animation: 'pointAntToPosition-0',\n    description: 'O ponteiro(*) \"ant\" é declarado apontando para o primeiro elemento da lista'\n  }, {\n    line: 6,\n    animation: 'pointAuxToPosition-1',\n    description: 'O ponteiro(*) \"aux\" é declarado apontando para o segundo elemento da lista'\n  }, {\n    line: 7,\n    animation: 'if-antEqualIndex-11',\n    description: 'Verifica se o primeiro elemento (apontado por \"ant\") está no índice a ser removido. Caso esteja, o ponteiro \"lista\"(início da lista) apontará para o segundo elemento da lista e o primeiro elemento será removido.'\n  }, {\n    line: 8,\n    animation: 'pointListToAux',\n    description: 'Já que o primeiro elemento da lista é o elemento a ser removido, aponta o inicio da lista para o segundo elemento.'\n  }, {\n    line: 9,\n    animation: 'freeAnt',\n    description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"ant\", removendo o elemento da lista.'\n  }, {\n    line: 10,\n    animation: 'jumpToLine-18',\n    description: ''\n  }, {\n    line: 11,\n    animation: '',\n    description: 'Caso o primeiro elemento não seja o elemento a ser removido, o índice deve ser procurado na lista.'\n  }, {\n    line: 12,\n    animation: 'searchIndex-nullable-withAnt',\n    description: 'Enquanto não chegarmos ao fim da lista ou encontrarmos o índice, avaçamos cada ponteiro(*) para o respectivo próximo elemento.'\n  }, {\n    line: 13,\n    animation: 'if-auxNotNull-18',\n    description: 'Se saírmos da busca e \"aux\" for diferente de NULL, significa que o índice foi encontrado.'\n  }, {\n    line: 14,\n    animation: 'antElementPointsToAuxProx',\n    description: 'Ligamos o elemento anterior ao elemento que será excluído, com o elemento posterior ao elemento que será excluído. Desvinculando esse elemento da lista.'\n  }, {\n    line: 15,\n    animation: 'freeAux',\n    description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"aux\", removendo o elemento da lista.'\n  }, {\n    line: 16,\n    animation: '',\n    description: ''\n  }, {\n    line: 17,\n    animation: '',\n    description: ''\n  }, {\n    line: 18,\n    animation: '',\n    description: 'Retorna retorna a lista sem o elemento removido.'\n  }],\n  code: ['struct elemento * RemovePorIndice(struct elemento * lista, int indice){', ' if(lista == NULL){', '   return NULL;', ' }', ' int indiceAtual = 1;', ' struct elemento *ant = lista;', ' struct elemento *aux = ant-> prox;', ' if (indice == 0) {', '    lista = aux;', '    free(ant);', '  }', '  else {', \"    while (aux != NULL && indiceAtual != indice) {\\n          ant = aux;\\n          aux = aux -> prox;\\n          indiceAtual++;\\n        }\", '   if (aux != NULL) {', '      ant->prox = aux->prox;', '      free(aux);', '    }', '  }', '  return lista;', '}']\n};\nexport var criaListaSimples = {\n  executionOrder: [{\n    line: 0,\n    animation: '',\n    description: 'A função \"CriaLista\" não recebe parâmetros. Ela retornará a lista vazia.'\n  }, {\n    line: 1,\n    animation: 'createList',\n    description: 'Declaração do ponteiro para o início da lista.'\n  }, {\n    line: 2,\n    animation: '',\n    description: 'Retorna a lista vazia.'\n  }],\n  code: ['struct elemento * CriaLista(){', ' struct elemento *lista = NULL;', ' return lista;', '}']\n};\nexport var destroiListaFuncaoSimples = {\n  executionOrder: [{\n    line: 0,\n    animation: '',\n    description: 'A função \"DestroiLista\" recebe o ponteiro para a lista como parâmetro. Ela retornará a lista vazia.'\n  }, {\n    line: 1,\n    animation: '',\n    description: 'Declaração do ponteiro auxiliar.'\n  }, {\n    line: 2,\n    animation: 'destroyList',\n    description: 'Verifica se a lista está vazia e, caso esteja, não terá elemento a ser removido. Senão, percorre a lista removendo os elementos.'\n  }, {\n    line: 3,\n    animation: '',\n    description: 'retorna a lista vazia.'\n  }],\n  code: ['struct elemento * DestroiLista(struct elemento * lista){', ' struct elemento *aux;', \" while(lista != NULL) {\\n        aux = lista -> prox;\\n        free(lista);\\n        lista = aux;\\n      }\", ' return NULL;', '}']\n};","map":{"version":3,"names":["insereFuncaoSimples","executionOrder","line","animation","description","code","insereFimFuncaoSimples","insereIndiceFuncaoSimples","buscarPorValorSimples","buscarPorIndiceSimples","removerPorValorSimples","removerPorIndiceSimples","criaListaSimples","destroiListaFuncaoSimples"],"sources":["/home/carloslm/Documents/GitHub/simulador_de_listas_encadeadas/src/components/Animations.js"],"sourcesContent":["export const insereFuncaoSimples = {\n  executionOrder: [\n    {\n      line: 6,\n      animation: '',\n      description:\n        'A função \"InsereInicio\" recebe o ponteiro para a lista e o valor a ser inserido como parâmetros. Ela retornará a lista com o novo elemento;',\n    },\n    {\n      line: 7,\n      animation: 'createNewPointer',\n      description:\n        'O ponteiro(*) \"novo\" é declarado e chama a função \"CriarElemento\" passando o valor recebido como parâmetro.',\n    },\n    {\n      line: 0,\n      animation: '',\n      description:\n        'A função \"CriarElemento\" recebe um valor e retorna um ponteiro para o novo elemento criado.',\n    },\n    {\n      line: 1,\n      animation: 'createNewElement',\n      description:\n        'O ponteiro(*) \"resp\" é declarado e recebe o endereço de memória alocado para o novo elemento.',\n    },\n    {\n      line: 2,\n      animation: 'attributeValueToNewElement',\n      description:\n        'Através do ponteiro \"resp\" é atribuído ao novo elemento o valor recebido.',\n    },\n    {\n      line: 3,\n      animation: 'pointNewElementToNull',\n      description:\n        'Através do ponteiro \"resp\" é atribuído ao novo elemento o próximo elemento (que até o momento é NULL).',\n    },\n    {\n      line: 4,\n      animation: 'pointNewPointerToNewElement',\n      description:\n        'O ponteiro \"resp\" (que aponta para o novo elemento) é retornado pela função \"CriarElemento\".',\n    },\n    {\n      line: 8,\n      animation: 'pointNewElementToPosition',\n      description:\n        'Agora que o ponteiro \"novo\" recebeu o novo elemento e como estamos inserindo no início da lista, diremos que o próximo elemento após o novo elemento vai ser o atual primeiro elemento da lista.',\n    },\n    {\n      line: 9,\n      animation: 'pointAntToNewElement',\n      description:\n        'Depois disso, diremos que o primeiro elemento da lista vai ser o novo elemento.',\n    },\n    {\n      line: 10,\n      animation: '',\n      description:\n        'Por fim, retornamos a lista já com o novo elemento inserido.',\n    },\n  ],\n\n  code: [\n    'struct elemento *CriaElemento(int numero){',\n    '   struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));',\n    '   resp->valor = numero;',\n    '   resp->prox = NULL;',\n    '   return resp;',\n    '}',\n    'struct elemento *InsereInicio(elemento *lista, int numero){',\n    '   struct elemento *novo = CriaElemento(numero);',\n    '   novo->prox = lista;',\n    '   lista = novo;',\n    '   return lista;',\n    '}',\n  ],\n};\n\nexport const insereFimFuncaoSimples = {\n  executionOrder: [\n    {\n      line: 6,\n      animation: '',\n      description: 'A função \"InsereFim\" recebe o ponteiro para a lista e o valor a ser inserido como parâmetros. Ela retornará a lista com o novo elemento;',\n    },\n    {\n      line: 7,\n      animation: '',\n      description: 'O ponteiro(*) \"aux\" é declarado',\n    },\n    {\n      line: 8,\n      animation: 'createNewPointer',\n      description:\n        'O ponteiro(*) \"novo\" é declarado e chama a função \"CriarElemento\" passando o valor recebido como parâmetro.',\n    },\n    {\n      line: 0,\n      animation: '',\n      description:\n        'A função \"CriarElemento\" recebe um valor e retorna um ponteiro para o novo elemento criado.',\n    },\n    {\n      line: 1,\n      animation: 'createNewElement',\n      description:\n        'O ponteiro(*) \"resp\" é declarado e recebe o endereço de memória alocado para o novo elemento.',\n    },\n    {\n      line: 2,\n      animation: 'attributeValueToNewElement',\n      description:\n        'Através do ponteiro \"resp\" é atribuído ao novo elemento o valor recebido.',\n    },\n    {\n      line: 3,\n      animation: 'pointNewElementToNull',\n      description:\n        'Através do ponteiro \"resp\" é atribuído ao novo elemento o próximo elemento (que até o momento é NULL).',\n    },\n    {\n      line: 4,\n      animation: 'pointNewPointerToNewElement',\n      description:\n        'O ponteiro \"resp\" (que aponta para o novo elemento) é retornado pela função \"CriarElemento\".',\n    },\n    {\n      line: 5,\n      animation: '',\n      description: '',\n    },\n    {\n      line: 9,\n      animation: 'if-verifyEmptyList-12',\n      description:\n        'Verifica se a lista está vazia, se estiver, o primeiro elemento da lista vai ser o novo elemento.',\n    },\n    { line: 10, animation: 'pointAntToNewElement', description: '' },\n    { line: 11, animation: 'jumpToLine-17', description: '' },\n    { line: 12, animation: '', description: '' },\n    { line: 13, animation: 'pointAuxToPosition-0', description: '' },\n    { line: 14, animation: 'searchIndex', description: 'Busca o último elemento da lista.' },\n    { line: 15, animation: 'pointAntToNewElement', description: 'Ao encontrar o último elemento, o próximo elemento dele vai ser o novo elemento.' },\n    { line: 16, animation: '', description: '' },\n    { line: 17, animation: '', description: 'Retorna a lista com o novo elemento inserido.' },\n\n  ],\n  code: [\n    'struct elemento *CriaElemento(int numero){',\n    '    struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));',\n    '    resp->valor = numero;',\n    '    resp->prox = NULL;',\n    '    return resp;',\n    '}',\n    'struct elemento *InsereFim(struct elemento *lista, int numero){',\n    '    struct elemento *aux;',\n    '    struct elemento *novo = CriaElemento(numero);',\n    '    if (lista == NULL){',\n    '       lista = novo;',\n    '    }',\n    '    else{',\n    '        aux = lista;',\n    `        while (aux->prox != NULL){\n                aux = aux->prox;\n            }`,\n    '        aux->prox = novo;',\n    '    }',\n    '    return lista;',\n    '}'\n  ]\n};\n\nexport const insereIndiceFuncaoSimples = {\n  executionOrder: [\n    {\n      line: 6,\n      animation: '',\n      description: 'A função \"InsereIndice\" recebe o ponteiro para a lista e o valor a ser inserido como parâmetros. Ela retornará a lista com o novo elemento;',\n    },\n    {\n      line: 7,\n      animation: '',\n      description: 'O ponteiro(*) \"aux\" é declarado',\n    },\n    {\n      line: 8,\n      animation: 'createNewPointer',\n      description:\n        'O ponteiro(*) \"novo\" é declarado e chama a função \"CriarElemento\" passando o valor recebido como parâmetro.',\n    },\n    {\n      line: 0,\n      animation: '',\n      description:\n        'A função \"CriarElemento\" recebe um valor e retorna um ponteiro para o novo elemento criado.',\n    },\n    {\n      line: 1,\n      animation: 'createNewElement',\n      description:\n        'O ponteiro(*) \"resp\" é declarado e recebe o endereço de memória alocado para o novo elemento.',\n    },\n    {\n      line: 2,\n      animation: 'attributeValueToNewElement',\n      description:\n        'Através do ponteiro \"resp\" é atribuído ao novo elemento o valor recebido.',\n    },\n    {\n      line: 3,\n      animation: 'pointNewElementToNull',\n      description:\n        'Através do ponteiro \"resp\" é atribuído ao novo elemento o próximo elemento (que até o momento é NULL).',\n    },\n    {\n      line: 4,\n      animation: 'pointNewPointerToNewElement',\n      description:\n        'O ponteiro \"resp\" (que aponta para o novo elemento) é retornado pela função \"CriarElemento\".',\n    },\n    { line: 5, animation: '', description: '' },\n    {\n      line: 9,\n      animation: '',\n      description:\n        'A variável indiceAtual é criada e inicializada com o valor 1, ou seja, a segunda posição da lista.',\n    },\n    {\n      line: 10,\n      animation: 'if-verifyEmptyList-13',\n      description:\n        'Verifica se a lista está vazia, se estiver, o primeiro elemento da lista vai ser o novo elemento.',\n    },\n    { line: 11, animation: 'pointAntToNewElement', description: 'Se a lista estiver vazia, insere o elemento na primeira posição.' },\n    { line: 12, animation: 'jumpToLine-24', description: '' },\n    { line: 13, animation: 'if-indexEqualsStart-17', description: 'Verifica se índice que o elemento deve ser inserido é o começo da lista.' },\n    { line: 14, animation: 'pointNewElementToPosition', description: 'Aponta o proxímo elemento do novo elemento como o primeiro elemento da lista.' },\n    { line: 15, animation: 'pointAntToNewElement', description: 'Aponta o início da lista para o novo elemento.' },\n    { line: 16, animation: 'jumpToLine-24', description: '' },\n    { line: 17, animation: '', description: 'Caso contrário, busca o índice a ser inserido na lista.' },\n    { line: 18, animation: 'pointAntToPosition-0', description: 'Aponta o ponteiro \"ant\" para o primeiro elemento da lista.' },\n    { line: 19, animation: 'pointAuxToPosition-1', description: 'Aponta o ponteiro \"aux\" para o segundo elemento da lista.' },\n    { line: 20, animation: 'searchIndex-nullable-withAnt', description: 'Enquanto o ponteiro \"aux\" não for nulo e o índice atual for diferente do índice a ser inserido, o ponteiro \"ant\" aponta para o elemento que o ponteiro \"aux\" aponta e o ponteiro \"aux\" aponta para o próximo elemento.' },\n    { line: 21, animation: 'pointAntToNewElement', description: 'Aponta o elemento novo como próximo elemento do índice anterior ao qual ele deve ser inserido' },\n    { line: 22, animation: 'pointNewElementToPosition', description: 'Aponta o próximo elemento do novo elemento para o elemento que o ponteiro \"aux\" aponta.' },\n    { line: 23, animation: '', description: '' },\n    { line: 24, animation: '', description: 'Retorna a lista com o novo elemento inserido.' },\n\n  ],\n  code: [\n    'struct elemento *CriaElemento(int numero){',\n    '    struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));',\n    '    resp->valor = numero;',\n    '    resp->prox = NULL;',\n    '    return resp;',\n    '}',\n    'struct elemento *InsereIndice(struct elemento *lista, int numero, int indice){',\n    ' struct elemento *aux;',\n    ' struct elemento *novo = CriaElemento(numero);',\n    ' int indiceAtual = 1;',\n    ' if (lista == NULL){',\n    '   lista = novo;',\n    ' }',\n    ' else if (indice == 0){',\n    '   novo->prox = lista;',\n    '   lista = novo;',\n    ' }',\n    ' else {',\n    '   ant = lista;',\n    '   aux = lista->prox;',\n    `   while (aux != NULL && indiceAtual != indice){\n          ant = aux;\n          aux = aux->prox;\n          indiceAtual++;\n        }`,\n    '   ant->prox = novo;',\n    '   novo->prox = aux;',\n    ' }',\n    ' return lista;',\n    '}'\n  ]\n};\n\nexport const buscarPorValorSimples = {\n  executionOrder: [\n    {\n      line: 0,\n      animation: '',\n      description: 'A função \"BuscaPorValor\" recebe o ponteiro para a lista e o valor a ser buscado como parâmetros. Ela retornará o elemento encontrado ou o valor NULL;',\n    },\n    {\n      line: 1,\n      animation: 'pointAuxToPosition-0',\n      description: 'O ponteiro(*) \"aux\" é declarado apontando para o primeiro elemento da lista',\n    },\n    {\n      line: 2,\n      animation: 'searchValue-nullable',\n      description: 'Enquanto não chegar ao fim da lista e enquanto o valor não for encontrado, o ponteiro(*) \"aux\" será atualizado para apontar para o próximo elemento.',\n    },\n    {\n      line: 3,\n      animation: 'showElementFound',\n      description: 'Retorna o ponteiro(*) \"aux\", que pode estar apontando para o elemento encontrado ou para NULL, caso o elemento não tenha sido encontrado.',\n    },\n\n  ],\n  code: [\n    'struct elemento *BuscaPorValor(struct elemento *lista, int numero){',\n    ' struct elemento *aux = lista;',\n    ` while (aux != NULL && aux->valor != numero),\n          aux = aux->prox;`,\n    ' return aux;',\n    '}'\n  ]\n};\n\nexport const buscarPorIndiceSimples = {\n  executionOrder: [\n    {\n      line: 0,\n      animation: '',\n      description: 'A função \"BuscaPorIndice\" recebe o ponteiro para a lista e o índice a ser buscado como parâmetros. Ela retornará o elemento encontrado ou o valor NULL;',\n    },\n    {\n      line: 1,\n      animation: '',\n      description: 'A variável indiceAtual, que armazena em qual indice o ponteiro \"aux\" está, é inicializada com o valor 0.',\n    },\n    {\n      line: 2,\n      animation: 'pointAuxToPosition-0',\n      description: 'O ponteiro(*) \"aux\" é declarado apontando para o primeiro elemento da lista',\n    },\n    {\n      line: 3,\n      animation: 'searchIndex-nullable--showElement',\n      description: 'Enquanto não chegar ao fim da lista e enquanto o índice não for encontrado, o ponteiro(*) \"aux\" será atualizado para apontar para o próximo elemento e o indiceAtual será incrementado em uma unidade.',\n    },\n    {\n      line: 4,\n      animation: 'showElementFound',\n      description: 'Retorna o ponteiro(*) \"aux\", que pode estar apontando para o elemento encontrado ou para NULL, caso o elemento não tenha sido encontrado.',\n    },\n\n  ],\n  code: [\n    'struct elemento *BuscaPorIndice(struct elemento *lista, int indice){',\n    '  int indiceAtual = 0;',\n    '  struct elemento *aux = lista;',\n    `  while (aux != NULL && indiceAtual != indice){\n          aux = aux->prox;\n          indiceAtual++;`,\n    '  return aux;',\n    '}'\n  ]\n};\n\nexport const removerPorValorSimples = {\n  executionOrder: [\n    {\n      line: 0,\n      animation: '',\n      description: 'A função \"RemovePorValor\" recebe o ponteiro para a lista e o valor do elemento a ser revomido como parâmetros. Ela retornará a lista sem o elemento;',\n    },\n    {\n      line: 1,\n      animation: 'if-verifyEmptyList-4',\n      description: 'Verifica se a lista está vazia e, caso esteja, não terá elemento a ser removido.',\n    },\n    {\n      line: 2,\n      animation: 'jumpToLine-20',\n      description: 'Retorna a própria lista, já que não há elemento a ser removido.',\n    },\n    {\n      line: 3,\n      animation: '',\n      description: '',\n    },\n    {\n      line: 4,\n      animation: 'pointAntToPosition-0',\n      description: 'O ponteiro(*) \"ant\" é declarado apontando para o primeiro elemento da lista',\n    },\n    {\n      line: 5,\n      animation: 'pointAuxToPosition-1',\n      description: 'O ponteiro(*) \"aux\" é declarado apontando para o segundo elemento da lista',\n    }, {\n      line: 6,\n      animation: 'if-antEqualElement-10',\n      description: 'Verifica se o primeiro elemento (apontado por \"ant\") é o elemento a ser removido. Caso seja, o ponteiro \"ant\" apontará para o segundo elemento da lista e o primeiro elemento será removido.',\n    }, {\n      line: 7,\n      animation: 'pointListToAux',\n      description: 'Já que o primeiro elemento da lista é o elemento a ser removido, aponta o inicio da lista para o segundo elemento.',\n    }, {\n      line: 8,\n      animation: 'freeAnt',\n      description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"ant\", removendo o elemento da lista.',\n    }, {\n      line: 9,\n      animation: 'jumpToLine-18',\n      description: '',\n    }, {\n      line: 10,\n      animation: '',\n      description: 'Caso o primeiro elemento não seja o elemento a ser removido, o elemento deve ser procurado na lista.',\n    }, {\n      line: 11,\n      animation: 'searchValue-nullable-withAnt',\n      description: 'Enquanto não chegarmos ao fim da lista ou encontrarmos o elemento, avaçamos cada ponteiro(*) para o respectivo próximo elemento.',\n    }, {\n      line: 12,\n      animation: 'if-auxNotNull-18',\n      description: 'Se saírmos da busca e \"aux\" for diferente de NULL, significa que o elemento foi encontrado.',\n    }, {\n      line: 13,\n      animation: 'antElementPointsToAuxProx',\n      description: 'Ligamos o elemento anterior ao elemento que será excluído, com o elemento posterior ao elemento que será excluído. Desvinculando esse elemento da lista.',\n    }, {\n      line: 14,\n      animation: 'freeAux',\n      description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"aux\", removendo o elemento da lista.',\n    }, {\n      line: 15,\n      animation: '',\n      description: '',\n    }, {\n      line: 16,\n      animation: '',\n      description: '',\n    }, {\n      line: 17,\n      animation: '',\n      description: '',\n    }, {\n      line: 18,\n      animation: '',\n      description: 'Retorna retorna a lista sem o elemento removido.',\n    },\n\n  ],\n  code: [\n    'struct elemento *RemovePorValor(struct elemento *lista, int numero){',\n    ' if (lista == NULL){',\n    '  return NULL; ',\n    ' }',\n    ' struct elemento *ant = lista;',\n    ' struct elemento *aux = ant->prox;',\n    ' if (ant->valor == numero){',\n    '   lista = aux;',\n    '   free(ant);',\n    ' }',\n    ' else{',\n    `   while (aux != NULL && aux->valor != numero){\n          ant = aux;\n          aux = aux->prox;\n        }`,\n    '   if (aux != NULL){',\n    '     ant->prox = aux->prox;',\n    '     free(aux);',\n    '   }',\n    ' }',\n    ' return lista;',\n    '}'\n  ]\n};\n\nexport const removerPorIndiceSimples = {\n  executionOrder: [\n    {\n      line: 0,\n      animation: '',\n      description: 'A função \"RemovePorIndice\" recebe o ponteiro para a lista e o índice do elemento a ser revomido como parâmetros. Ela retornará a lista sem o elemento;',\n    }, {\n      line: 1,\n      animation: 'if-verifyEmptyList-4',\n      description: 'Verifica se a lista está vazia e, caso esteja, não terá elemento a ser removido.',\n    }, {\n      line: 2,\n      animation: 'jumpToLine-20',\n      description: 'Retorna a própria lista, já que não há elemento a ser removido.',\n    }, {\n      line: 3,\n      animation: '',\n      description: '',\n    }, {\n      line: 4,\n      animation: '',\n      description: 'Seta o índice inicial para o segundo elemento da lista.',\n    }, {\n      line: 5,\n      animation: 'pointAntToPosition-0',\n      description: 'O ponteiro(*) \"ant\" é declarado apontando para o primeiro elemento da lista',\n    },\n    {\n      line: 6,\n      animation: 'pointAuxToPosition-1',\n      description: 'O ponteiro(*) \"aux\" é declarado apontando para o segundo elemento da lista',\n    }, {\n      line: 7,\n      animation: 'if-antEqualIndex-11',\n      description: 'Verifica se o primeiro elemento (apontado por \"ant\") está no índice a ser removido. Caso esteja, o ponteiro \"lista\"(início da lista) apontará para o segundo elemento da lista e o primeiro elemento será removido.',\n    }, {\n      line: 8,\n      animation: 'pointListToAux',\n      description: 'Já que o primeiro elemento da lista é o elemento a ser removido, aponta o inicio da lista para o segundo elemento.',\n    }, {\n      line: 9,\n      animation: 'freeAnt',\n      description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"ant\", removendo o elemento da lista.',\n    }, {\n      line: 10,\n      animation: 'jumpToLine-18',\n      description: '',\n    }, {\n      line: 11,\n      animation: '',\n      description: 'Caso o primeiro elemento não seja o elemento a ser removido, o índice deve ser procurado na lista.',\n    }, {\n      line: 12,\n      animation: 'searchIndex-nullable-withAnt',\n      description: 'Enquanto não chegarmos ao fim da lista ou encontrarmos o índice, avaçamos cada ponteiro(*) para o respectivo próximo elemento.',\n    }, {\n      line: 13,\n      animation: 'if-auxNotNull-18',\n      description: 'Se saírmos da busca e \"aux\" for diferente de NULL, significa que o índice foi encontrado.',\n    }, {\n      line: 14,\n      animation: 'antElementPointsToAuxProx',\n      description: 'Ligamos o elemento anterior ao elemento que será excluído, com o elemento posterior ao elemento que será excluído. Desvinculando esse elemento da lista.',\n    }, {\n      line: 15,\n      animation: 'freeAux',\n      description: 'O comando \"free\" libera o espaço de memória alocado para o elemento apontado por \"aux\", removendo o elemento da lista.',\n    }, {\n      line: 16,\n      animation: '',\n      description: '',\n    }, {\n      line: 17,\n      animation: '',\n      description: '',\n    }, {\n      line: 18,\n      animation: '',\n      description: 'Retorna retorna a lista sem o elemento removido.',\n    },\n  ],\n  code: [\n    'struct elemento * RemovePorIndice(struct elemento * lista, int indice){',\n    ' if(lista == NULL){',\n    '   return NULL;',\n    ' }',\n    ' int indiceAtual = 1;',\n    ' struct elemento *ant = lista;',\n    ' struct elemento *aux = ant-> prox;',\n    ' if (indice == 0) {',\n    '    lista = aux;',\n    '    free(ant);',\n    '  }',\n    '  else {',\n    `    while (aux != NULL && indiceAtual != indice) {\n          ant = aux;\n          aux = aux -> prox;\n          indiceAtual++;\n        }`,\n    '   if (aux != NULL) {',\n    '      ant->prox = aux->prox;',\n    '      free(aux);',\n    '    }',\n    '  }',\n    '  return lista;',\n    '}',\n  ]\n}\n\nexport const criaListaSimples = {\n  executionOrder: [\n    { line: 0, animation: '', description: 'A função \"CriaLista\" não recebe parâmetros. Ela retornará a lista vazia.' },\n    { line: 1, animation: 'createList', description: 'Declaração do ponteiro para o início da lista.' },\n    { line: 2, animation: '', description: 'Retorna a lista vazia.' },\n  ],\n  code: [\n    'struct elemento * CriaLista(){',\n    ' struct elemento *lista = NULL;',\n    ' return lista;',\n    '}'\n  ],\n};\n\nexport const destroiListaFuncaoSimples = {\n  executionOrder: [\n    { line: 0, animation: '', description: 'A função \"DestroiLista\" recebe o ponteiro para a lista como parâmetro. Ela retornará a lista vazia.' },\n    { line: 1, animation: '', description: 'Declaração do ponteiro auxiliar.' },\n    { line: 2, animation: 'destroyList', description: 'Verifica se a lista está vazia e, caso esteja, não terá elemento a ser removido. Senão, percorre a lista removendo os elementos.' },\n    { line: 3, animation: '', description: 'retorna a lista vazia.' },\n  ],\n  code: [\n    'struct elemento * DestroiLista(struct elemento * lista){',\n    ' struct elemento *aux;',\n    ` while(lista != NULL) {\n        aux = lista -> prox;\n        free(lista);\n        lista = aux;\n      }`,\n    ' return NULL;',\n    '}',\n  ]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}