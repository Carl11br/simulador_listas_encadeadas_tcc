{"ast":null,"code":"/*! LeaderLine v1.0.7 (c) anseki https://anseki.github.io/leader-line/ */\nvar LeaderLine = function () {\n  \"use strict\";\n\n  var Z,\n    w,\n    O,\n    M,\n    I,\n    o,\n    t,\n    s,\n    h,\n    u,\n    n,\n    a,\n    e,\n    _,\n    v,\n    l,\n    r,\n    i,\n    E,\n    x,\n    p,\n    c,\n    d,\n    C = \"leader-line\",\n    b = 1,\n    k = 2,\n    L = 3,\n    A = 4,\n    V = {\n      top: b,\n      right: k,\n      bottom: L,\n      left: A\n    },\n    P = 1,\n    N = 2,\n    T = 3,\n    W = 4,\n    B = 5,\n    R = {\n      straight: P,\n      arc: N,\n      fluid: T,\n      magnet: W,\n      grid: B\n    },\n    Y = \"behind\",\n    f = C + \"-defs\",\n    y = '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" id=\"leader-line-defs\"><style><![CDATA[.leader-line{position:absolute;overflow:visible!important;pointer-events:none!important;font-size:16px}#leader-line-defs{width:0;height:0;position:absolute;left:0;top:0}.leader-line-line-path{fill:none}.leader-line-mask-bg-rect{fill:white}.leader-line-caps-mask-anchor,.leader-line-caps-mask-marker-shape{fill:black}.leader-line-caps-mask-anchor{stroke:black}.leader-line-caps-mask-line,.leader-line-plugs-face{stroke:rgba(0,0,0,0)}.leader-line-line-mask-shape{stroke:white}.leader-line-line-outline-mask-shape{stroke:black}.leader-line-plug-mask-shape{fill:white;stroke:black}.leader-line-plug-outline-mask-shape{fill:black;stroke:white}.leader-line-areaAnchor{position:absolute;overflow:visible!important}]]></style><defs><circle id=\"leader-line-disc\" cx=\"0\" cy=\"0\" r=\"5\"/><rect id=\"leader-line-square\" x=\"-5\" y=\"-5\" width=\"10\" height=\"10\"/><polygon id=\"leader-line-arrow1\" points=\"-8,-8 8,0 -8,8 -5,0\"/><polygon id=\"leader-line-arrow2\" points=\"-4,-8 4,0 -4,8 -7,5 -2,0 -7,-5\"/><polygon id=\"leader-line-arrow3\" points=\"-4,-5 8,0 -4,5\"/><g id=\"leader-line-hand\"><path style=\"fill: #fcfcfc\" d=\"M9.19 11.14h4.75c1.38 0 2.49-1.11 2.49-2.49 0-.51-.15-.98-.41-1.37h1.3c1.38 0 2.49-1.11 2.49-2.49s-1.11-2.53-2.49-2.53h1.02c1.38 0 2.49-1.11 2.49-2.49s-1.11-2.49-2.49-2.49h14.96c1.37 0 2.49-1.11 2.49-2.49s-1.11-2.49-2.49-2.49H16.58C16-9.86 14.28-11.14 9.7-11.14c-4.79 0-6.55 3.42-7.87 4.73H-2.14v13.23h3.68C3.29 9.97 5.47 11.14 9.19 11.14L9.19 11.14Z\"/><path style=\"fill: black\" d=\"M13.95 12c1.85 0 3.35-1.5 3.35-3.35 0-.17-.02-.34-.04-.51h.07c1.85 0 3.35-1.5 3.35-3.35 0-.79-.27-1.51-.72-2.08 1.03-.57 1.74-1.67 1.74-2.93 0-.59-.16-1.15-.43-1.63h12.04c1.85 0 3.35-1.5 3.35-3.35 0-1.85-1.5-3.35-3.35-3.35H17.2C16.26-10.93 13.91-12 9.7-12 5.36-12 3.22-9.4 1.94-7.84c0 0-.29.33-.5.57-.63 0-3.58 0-3.58 0C-2.61-7.27-3-6.88-3-6.41v13.23c0 .47.39.86.86.86 0 0 2.48 0 3.2 0C2.9 10.73 5.29 12 9.19 12L13.95 12ZM9.19 10.28c-3.46 0-5.33-1.05-6.9-3.87-.15-.27-.44-.44-.75-.44 0 0-1.81 0-2.82 0V-5.55c1.06 0 3.11 0 3.11 0 .25 0 .44-.06.61-.25l.83-.95c1.23-1.49 2.91-3.53 6.43-3.53 3.45 0 4.9.74 5.57 1.72h-4.3c-.48 0-.86.38-.86.86s.39.86.86.86h22.34c.9 0 1.63.73 1.63 1.63 0 .9-.73 1.63-1.63 1.63H15.83c-.48 0-.86.38-.86.86 0 .47.39.86.86.86h2.52c.9 0 1.63.73 1.63 1.63s-.73 1.63-1.63 1.63h-3.12c-.48 0-.86.38-.86.86 0 .47.39.86.86.86h2.11c.88 0 1.63.76 1.63 1.67 0 .9-.73 1.63-1.63 1.63h-3.2c-.48 0-.86.39-.86.86 0 .47.39.86.86.86h1.36c.05.16.09.34.09.51 0 .9-.73 1.63-1.63 1.63C13.95 10.28 9.19 10.28 9.19 10.28Z\"/></g><g id=\"leader-line-crosshair\"><path d=\"M0-78.97c-43.54 0-78.97 35.43-78.97 78.97 0 43.54 35.43 78.97 78.97 78.97s78.97-35.43 78.97-78.97C78.97-43.54 43.55-78.97 0-78.97ZM76.51-1.21h-9.91v-9.11h-2.43v9.11h-11.45c-.64-28.12-23.38-50.86-51.5-51.5V-64.17h9.11V-66.6h-9.11v-9.91C42.46-75.86 75.86-42.45 76.51-1.21ZM-1.21-30.76h-9.11v2.43h9.11V-4.2c-1.44.42-2.57 1.54-2.98 2.98H-28.33v-9.11h-2.43v9.11H-50.29C-49.65-28-27.99-49.65-1.21-50.29V-30.76ZM-30.76 1.21v9.11h2.43v-9.11H-4.2c.42 1.44 1.54 2.57 2.98 2.98v24.13h-9.11v2.43h9.11v19.53C-27.99 49.65-49.65 28-50.29 1.21H-30.76ZM1.22 30.75h9.11v-2.43h-9.11V4.2c1.44-.42 2.56-1.54 2.98-2.98h24.13v9.11h2.43v-9.11h19.53C49.65 28 28 49.65 1.22 50.29V30.75ZM30.76-1.21v-9.11h-2.43v9.11H4.2c-.42-1.44-1.54-2.56-2.98-2.98V-28.33h9.11v-2.43h-9.11V-50.29C28-49.65 49.65-28 50.29-1.21H30.76ZM-1.21-76.51v9.91h-9.11v2.43h9.11v11.45c-28.12.64-50.86 23.38-51.5 51.5H-64.17v-9.11H-66.6v9.11h-9.91C-75.86-42.45-42.45-75.86-1.21-76.51ZM-76.51 1.21h9.91v9.11h2.43v-9.11h11.45c.64 28.12 23.38 50.86 51.5 51.5v11.45h-9.11v2.43h9.11v9.91C-42.45 75.86-75.86 42.45-76.51 1.21ZM1.22 76.51v-9.91h9.11v-2.43h-9.11v-11.45c28.12-.64 50.86-23.38 51.5-51.5h11.45v9.11h2.43v-9.11h9.91C75.86 42.45 42.45 75.86 1.22 76.51Z\"/><path d=\"M0 83.58-7.1 96 7.1 96Z\"/><path d=\"M0-83.58 7.1-96-7.1-96\"/><path d=\"M83.58 0 96 7.1 96-7.1Z\"/><path d=\"M-83.58 0-96-7.1-96 7.1Z\"/></g></defs></svg>',\n    X = {\n      disc: {\n        elmId: \"leader-line-disc\",\n        noRotate: !0,\n        bBox: {\n          left: -5,\n          top: -5,\n          width: 10,\n          height: 10,\n          right: 5,\n          bottom: 5\n        },\n        widthR: 2.5,\n        heightR: 2.5,\n        bCircle: 5,\n        sideLen: 5,\n        backLen: 5,\n        overhead: 0,\n        outlineBase: 1,\n        outlineMax: 4\n      },\n      square: {\n        elmId: \"leader-line-square\",\n        noRotate: !0,\n        bBox: {\n          left: -5,\n          top: -5,\n          width: 10,\n          height: 10,\n          right: 5,\n          bottom: 5\n        },\n        widthR: 2.5,\n        heightR: 2.5,\n        bCircle: 5,\n        sideLen: 5,\n        backLen: 5,\n        overhead: 0,\n        outlineBase: 1,\n        outlineMax: 4\n      },\n      arrow1: {\n        elmId: \"leader-line-arrow1\",\n        bBox: {\n          left: -8,\n          top: -8,\n          width: 16,\n          height: 16,\n          right: 8,\n          bottom: 8\n        },\n        widthR: 4,\n        heightR: 4,\n        bCircle: 8,\n        sideLen: 8,\n        backLen: 8,\n        overhead: 8,\n        outlineBase: 2,\n        outlineMax: 1.5\n      },\n      arrow2: {\n        elmId: \"leader-line-arrow2\",\n        bBox: {\n          left: -7,\n          top: -8,\n          width: 11,\n          height: 16,\n          right: 4,\n          bottom: 8\n        },\n        widthR: 2.75,\n        heightR: 4,\n        bCircle: 8,\n        sideLen: 8,\n        backLen: 7,\n        overhead: 4,\n        outlineBase: 1,\n        outlineMax: 1.75\n      },\n      arrow3: {\n        elmId: \"leader-line-arrow3\",\n        bBox: {\n          left: -4,\n          top: -5,\n          width: 12,\n          height: 10,\n          right: 8,\n          bottom: 5\n        },\n        widthR: 3,\n        heightR: 2.5,\n        bCircle: 8,\n        sideLen: 5,\n        backLen: 4,\n        overhead: 8,\n        outlineBase: 1,\n        outlineMax: 2.5\n      },\n      hand: {\n        elmId: \"leader-line-hand\",\n        bBox: {\n          left: -3,\n          top: -12,\n          width: 40,\n          height: 24,\n          right: 37,\n          bottom: 12\n        },\n        widthR: 10,\n        heightR: 6,\n        bCircle: 37,\n        sideLen: 12,\n        backLen: 3,\n        overhead: 37\n      },\n      crosshair: {\n        elmId: \"leader-line-crosshair\",\n        noRotate: !0,\n        bBox: {\n          left: -96,\n          top: -96,\n          width: 192,\n          height: 192,\n          right: 96,\n          bottom: 96\n        },\n        widthR: 48,\n        heightR: 48,\n        bCircle: 96,\n        sideLen: 96,\n        backLen: 96,\n        overhead: 0\n      }\n    },\n    F = {\n      behind: Y,\n      disc: \"disc\",\n      square: \"square\",\n      arrow1: \"arrow1\",\n      arrow2: \"arrow2\",\n      arrow3: \"arrow3\",\n      hand: \"hand\",\n      crosshair: \"crosshair\"\n    },\n    q = {\n      disc: \"disc\",\n      square: \"square\",\n      arrow1: \"arrow1\",\n      arrow2: \"arrow2\",\n      arrow3: \"arrow3\",\n      hand: \"hand\",\n      crosshair: \"crosshair\"\n    },\n    G = [b, k, L, A],\n    D = \"auto\",\n    Q = {\n      x: \"left\",\n      y: \"top\",\n      width: \"width\",\n      height: \"height\"\n    },\n    z = 80,\n    j = 4,\n    H = 5,\n    U = 120,\n    K = 8,\n    J = 3.75,\n    $ = 10,\n    ee = 30,\n    te = .5522847,\n    ne = .25 * Math.PI,\n    m = /^\\s*(\\-?[\\d\\.]+)\\s*(\\%)?\\s*$/,\n    ae = \"http://www.w3.org/2000/svg\",\n    S = \"-ms-scroll-limit\" in document.documentElement.style && \"-ms-ime-align\" in document.documentElement.style && !window.navigator.msPointerEnabled,\n    ie = !S && !!document.uniqueID,\n    oe = (\"MozAppearance\" in document.documentElement.style),\n    le = !(S || oe || !window.chrome || !window.CSS),\n    re = !S && !ie && !oe && !le && !window.chrome && \"WebkitAppearance\" in document.documentElement.style,\n    se = ie || S ? .2 : .1,\n    ue = {\n      path: T,\n      lineColor: \"coral\",\n      lineSize: 4,\n      plugSE: [Y, \"arrow1\"],\n      plugSizeSE: [1, 1],\n      lineOutlineEnabled: !1,\n      lineOutlineColor: \"indianred\",\n      lineOutlineSize: .25,\n      plugOutlineEnabledSE: [!1, !1],\n      plugOutlineSizeSE: [1, 1]\n    },\n    he = (p = {}.toString, c = {}.hasOwnProperty.toString, d = c.call(Object), function (e) {\n      return e && \"[object Object]\" === p.call(e) && (!(e = Object.getPrototypeOf(e)) || (e = e.hasOwnProperty(\"constructor\") && e.constructor) && \"function\" == typeof e && c.call(e) === d);\n    }),\n    pe = Number.isFinite || function (e) {\n      return \"number\" == typeof e && window.isFinite(e);\n    },\n    g = (_ = {\n      ease: [.25, .1, .25, 1],\n      linear: [0, 0, 1, 1],\n      \"ease-in\": [.42, 0, 1, 1],\n      \"ease-out\": [0, 0, .58, 1],\n      \"ease-in-out\": [.42, 0, .58, 1]\n    }, v = 1e3 / 60 / 2, l = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {\n      setTimeout(e, v);\n    }, r = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function (e) {\n      clearTimeout(e);\n    }, i = Number.isFinite || function (e) {\n      return \"number\" == typeof e && window.isFinite(e);\n    }, E = [], x = 0, {\n      add: function add(n, e, t, a, i, o, l) {\n        var r,\n          s,\n          u,\n          h,\n          p,\n          c,\n          d,\n          f,\n          y,\n          m,\n          S = ++x;\n        function g(e, t) {\n          return {\n            value: n(t),\n            timeRatio: e,\n            outputRatio: t\n          };\n        }\n        if (\"string\" == typeof i && (i = _[i]), n = n || function () {}, t < v) r = [g(0, 0), g(1, 1)];else {\n          if (s = v / t, r = [g(0, 0)], 0 === i[0] && 0 === i[1] && 1 === i[2] && 1 === i[3]) for (h = s; h <= 1; h += s) r.push(g(h, h));else for (p = u = (h = s) / 10; p <= 1; p += u) d = p, m = y = f = void 0, f = (m = p * p) * p, m *= 3 * (y = 1 - p), h <= (c = {\n            x: (d = 3 * (y * y) * p) * i[0] + m * i[2] + f,\n            y: d * i[1] + m * i[3] + f\n          }).x && (r.push(g(c.x, c.y)), h += s);\n          r.push(g(1, 1));\n        }\n        return E.push(o = {\n          animId: S,\n          frameCallback: e,\n          duration: t,\n          count: a,\n          frames: r,\n          reverse: !!o\n        }), !1 !== l && be(o, l), S;\n      },\n      remove: function remove(n) {\n        var a;\n        E.some(function (e, t) {\n          return e.animId === n && (a = t, !(e.framesStart = null));\n        }) && E.splice(a, 1);\n      },\n      start: function start(t, n, a) {\n        E.some(function (e) {\n          return e.animId === t && (e.reverse = !!n, be(e, a), !0);\n        });\n      },\n      stop: function stop(t, n) {\n        var a;\n        return E.some(function (e) {\n          return e.animId === t && (n ? null != e.lastFrame && (a = e.frames[e.lastFrame].timeRatio) : (a = (Date.now() - e.framesStart) / e.duration, (a = e.reverse ? 1 - a : a) < 0 ? a = 0 : 1 < a && (a = 1)), !(e.framesStart = null));\n        }), a;\n      },\n      validTiming: function validTiming(t) {\n        return \"string\" == typeof t ? _[t] : Array.isArray(t) && [0, 1, 2, 3].every(function (e) {\n          return i(t[e]) && 0 <= t[e] && t[e] <= 1;\n        }) ? [t[0], t[1], t[2], t[3]] : null;\n      }\n    }),\n    ce = function ce(e) {\n      e.SVGPathElement.prototype.getPathData && e.SVGPathElement.prototype.setPathData || function () {\n        function i(e) {\n          this._string = e, this._currentIndex = 0, this._endIndex = this._string.length, this._prevCommand = null, this._skipOptionalSpaces();\n        }\n        var a = {\n            Z: \"Z\",\n            M: \"M\",\n            L: \"L\",\n            C: \"C\",\n            Q: \"Q\",\n            A: \"A\",\n            H: \"H\",\n            V: \"V\",\n            S: \"S\",\n            T: \"T\",\n            z: \"Z\",\n            m: \"m\",\n            l: \"l\",\n            c: \"c\",\n            q: \"q\",\n            a: \"a\",\n            h: \"h\",\n            v: \"v\",\n            s: \"s\",\n            t: \"t\"\n          },\n          o = -1 !== e.navigator.userAgent.indexOf(\"MSIE \");\n        i.prototype = {\n          parseSegment: function parseSegment() {\n            var e = this._string[this._currentIndex],\n              t = a[e] || null;\n            if (null === t) {\n              if (null === this._prevCommand) return null;\n              if (null === (t = (\"+\" === e || \"-\" === e || \".\" === e || \"0\" <= e && e <= \"9\") && \"Z\" !== this._prevCommand ? \"M\" === this._prevCommand ? \"L\" : \"m\" === this._prevCommand ? \"l\" : this._prevCommand : null)) return null;\n            } else this._currentIndex += 1;\n            var n = null,\n              e = (this._prevCommand = t).toUpperCase();\n            return \"H\" === e || \"V\" === e ? n = [this._parseNumber()] : \"M\" === e || \"L\" === e || \"T\" === e ? n = [this._parseNumber(), this._parseNumber()] : \"S\" === e || \"Q\" === e ? n = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()] : \"C\" === e ? n = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()] : \"A\" === e ? n = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseArcFlag(), this._parseArcFlag(), this._parseNumber(), this._parseNumber()] : \"Z\" === e && (this._skipOptionalSpaces(), n = []), null === n || 0 <= n.indexOf(null) ? null : {\n              type: t,\n              values: n\n            };\n          },\n          hasMoreData: function hasMoreData() {\n            return this._currentIndex < this._endIndex;\n          },\n          peekSegmentType: function peekSegmentType() {\n            var e = this._string[this._currentIndex];\n            return a[e] || null;\n          },\n          initialCommandIsMoveTo: function initialCommandIsMoveTo() {\n            if (!this.hasMoreData()) return !0;\n            var e = this.peekSegmentType();\n            return \"M\" === e || \"m\" === e;\n          },\n          _isCurrentSpace: function _isCurrentSpace() {\n            var e = this._string[this._currentIndex];\n            return e <= \" \" && (\" \" === e || \"\\n\" === e || \"\\t\" === e || \"\\r\" === e || \"\\f\" === e);\n          },\n          _skipOptionalSpaces: function _skipOptionalSpaces() {\n            for (; this._currentIndex < this._endIndex && this._isCurrentSpace();) this._currentIndex += 1;\n            return this._currentIndex < this._endIndex;\n          },\n          _skipOptionalSpacesOrDelimiter: function _skipOptionalSpacesOrDelimiter() {\n            return !(this._currentIndex < this._endIndex && !this._isCurrentSpace() && \",\" !== this._string[this._currentIndex]) && (this._skipOptionalSpaces() && this._currentIndex < this._endIndex && \",\" === this._string[this._currentIndex] && (this._currentIndex += 1, this._skipOptionalSpaces()), this._currentIndex < this._endIndex);\n          },\n          _parseNumber: function _parseNumber() {\n            var e = 0,\n              t = 0,\n              n = 1,\n              a = 0,\n              i = 1,\n              o = 1,\n              l = this._currentIndex;\n            if (this._skipOptionalSpaces(), this._currentIndex < this._endIndex && \"+\" === this._string[this._currentIndex] ? this._currentIndex += 1 : this._currentIndex < this._endIndex && \"-\" === this._string[this._currentIndex] && (this._currentIndex += 1, i = -1), this._currentIndex === this._endIndex || (this._string[this._currentIndex] < \"0\" || \"9\" < this._string[this._currentIndex]) && \".\" !== this._string[this._currentIndex]) return null;\n            for (var r = this._currentIndex; this._currentIndex < this._endIndex && \"0\" <= this._string[this._currentIndex] && this._string[this._currentIndex] <= \"9\";) this._currentIndex += 1;\n            if (this._currentIndex !== r) for (var s = this._currentIndex - 1, u = 1; r <= s;) t += u * (this._string[s] - \"0\"), --s, u *= 10;\n            if (this._currentIndex < this._endIndex && \".\" === this._string[this._currentIndex]) {\n              if (this._currentIndex += 1, this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || \"9\" < this._string[this._currentIndex]) return null;\n              for (; this._currentIndex < this._endIndex && \"0\" <= this._string[this._currentIndex] && this._string[this._currentIndex] <= \"9\";) n *= 10, a += (this._string.charAt(this._currentIndex) - \"0\") / n, this._currentIndex += 1;\n            }\n            if (this._currentIndex !== l && this._currentIndex + 1 < this._endIndex && (\"e\" === this._string[this._currentIndex] || \"E\" === this._string[this._currentIndex]) && \"x\" !== this._string[this._currentIndex + 1] && \"m\" !== this._string[this._currentIndex + 1]) {\n              if (this._currentIndex += 1, \"+\" === this._string[this._currentIndex] ? this._currentIndex += 1 : \"-\" === this._string[this._currentIndex] && (this._currentIndex += 1, o = -1), this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || \"9\" < this._string[this._currentIndex]) return null;\n              for (; this._currentIndex < this._endIndex && \"0\" <= this._string[this._currentIndex] && this._string[this._currentIndex] <= \"9\";) e *= 10, e += this._string[this._currentIndex] - \"0\", this._currentIndex += 1;\n            }\n            var h = t + a;\n            return h *= i, e && (h *= Math.pow(10, o * e)), l === this._currentIndex ? null : (this._skipOptionalSpacesOrDelimiter(), h);\n          },\n          _parseArcFlag: function _parseArcFlag() {\n            if (this._currentIndex >= this._endIndex) return null;\n            var e = null,\n              t = this._string[this._currentIndex];\n            if (this._currentIndex += 1, \"0\" === t) e = 0;else {\n              if (\"1\" !== t) return null;\n              e = 1;\n            }\n            return this._skipOptionalSpacesOrDelimiter(), e;\n          }\n        };\n        function n(e) {\n          if (!e || 0 === e.length) return [];\n          var t = new i(e),\n            n = [];\n          if (t.initialCommandIsMoveTo()) for (; t.hasMoreData();) {\n            var a = t.parseSegment();\n            if (null === a) break;\n            n.push(a);\n          }\n          return n;\n        }\n        function l(e) {\n          return e.map(function (e) {\n            return {\n              type: e.type,\n              values: Array.prototype.slice.call(e.values)\n            };\n          });\n        }\n        function r(e) {\n          var u = [],\n            h = null,\n            p = null,\n            c = null,\n            d = null,\n            f = null,\n            y = null,\n            m = null;\n          return e.forEach(function (e) {\n            var t, n, a, i, o, l, r, s;\n            \"M\" === e.type ? (r = e.values[0], s = e.values[1], u.push({\n              type: \"M\",\n              values: [r, s]\n            }), d = y = r, f = m = s) : \"C\" === e.type ? (o = e.values[0], l = e.values[1], t = e.values[2], n = e.values[3], r = e.values[4], s = e.values[5], u.push({\n              type: \"C\",\n              values: [o, l, t, n, r, s]\n            }), p = t, c = n, d = r, f = s) : \"L\" === e.type ? (r = e.values[0], s = e.values[1], u.push({\n              type: \"L\",\n              values: [r, s]\n            }), d = r, f = s) : \"H\" === e.type ? (r = e.values[0], u.push({\n              type: \"L\",\n              values: [r, f]\n            }), d = r) : \"V\" === e.type ? (s = e.values[0], u.push({\n              type: \"L\",\n              values: [d, s]\n            }), f = s) : \"S\" === e.type ? (t = e.values[0], n = e.values[1], r = e.values[2], s = e.values[3], i = \"C\" === h || \"S\" === h ? (a = d + (d - p), f + (f - c)) : (a = d, f), u.push({\n              type: \"C\",\n              values: [a, i, t, n, r, s]\n            }), p = t, c = n, d = r, f = s) : \"T\" === e.type ? (r = e.values[0], s = e.values[1], l = \"Q\" === h || \"T\" === h ? (o = d + (d - p), f + (f - c)) : (o = d, f), u.push({\n              type: \"C\",\n              values: [a = d + 2 * (o - d) / 3, i = f + 2 * (l - f) / 3, r + 2 * (o - r) / 3, s + 2 * (l - s) / 3, r, s]\n            }), p = o, c = l, d = r, f = s) : \"Q\" === e.type ? (o = e.values[0], l = e.values[1], r = e.values[2], s = e.values[3], u.push({\n              type: \"C\",\n              values: [a = d + 2 * (o - d) / 3, i = f + 2 * (l - f) / 3, r + 2 * (o - r) / 3, s + 2 * (l - s) / 3, r, s]\n            }), p = o, c = l, d = r, f = s) : \"A\" === e.type ? (n = e.values[0], a = e.values[1], i = e.values[2], o = e.values[3], l = e.values[4], r = e.values[5], s = e.values[6], 0 === n || 0 === a ? (u.push({\n              type: \"C\",\n              values: [d, f, r, s, r, s]\n            }), d = r, f = s) : d === r && f === s || b(d, f, r, s, n, a, i, o, l).forEach(function (e) {\n              u.push({\n                type: \"C\",\n                values: e\n              }), d = r, f = s;\n            })) : \"Z\" === e.type && (u.push(e), d = y, f = m), h = e.type;\n          }), u;\n        }\n        var s = e.SVGPathElement.prototype.setAttribute,\n          u = e.SVGPathElement.prototype.removeAttribute,\n          d = e.Symbol ? e.Symbol() : \"__cachedPathData\",\n          f = e.Symbol ? e.Symbol() : \"__cachedNormalizedPathData\",\n          b = function b(e, t, n, a, i, o, l, r, s, u) {\n            function h(e, t, n) {\n              return {\n                x: e * Math.cos(n) - t * Math.sin(n),\n                y: e * Math.sin(n) + t * Math.cos(n)\n              };\n            }\n            var p = Math.PI * l / 180,\n              c = [];\n            u ? (_ = u[0], v = u[1], S = u[2], g = u[3]) : (e = (m = h(e, t, -p)).x, t = m.y, 1 < (m = (y = (e - (n = (f = h(n, a, -p)).x)) / 2) * y / (i * i) + (d = (t - (a = f.y)) / 2) * d / (o * o)) && (i *= m = Math.sqrt(m), o *= m), f = i * i, m = o * o, S = (f = (r === s ? -1 : 1) * Math.sqrt(Math.abs((f * m - f * d * d - m * y * y) / (f * d * d + m * y * y)))) * i * d / o + (e + n) / 2, g = f * -o * y / i + (t + a) / 2, _ = Math.asin(parseFloat(((t - g) / o).toFixed(9))), v = Math.asin(parseFloat(((a - g) / o).toFixed(9))), e < S && (_ = Math.PI - _), n < S && (v = Math.PI - v), _ < 0 && (_ = 2 * Math.PI + _), v < 0 && (v = 2 * Math.PI + v), s && v < _ && (_ -= 2 * Math.PI), !s && _ < v && (v -= 2 * Math.PI));\n            var d,\n              f,\n              y,\n              m = v - _;\n            Math.abs(m) > 120 * Math.PI / 180 && (d = v, f = n, y = a, v = s && _ < v ? _ + 120 * Math.PI / 180 * 1 : _ + 120 * Math.PI / 180 * -1, n = S + i * Math.cos(v), a = g + o * Math.sin(v), c = b(n, a, f, y, i, o, l, 0, s, [v, d, S, g]));\n            var m = v - _,\n              S = Math.cos(_),\n              g = Math.sin(_),\n              _ = Math.cos(v),\n              v = Math.sin(v),\n              m = Math.tan(m / 4),\n              i = 4 / 3 * i * m,\n              o = 4 / 3 * o * m,\n              m = [e, t],\n              S = [e + i * g, t - o * S],\n              _ = [n + i * v, a - o * _],\n              a = [n, a];\n            if (S[0] = 2 * m[0] - S[0], S[1] = 2 * m[1] - S[1], u) return [S, _, a].concat(c);\n            var c = [S, _, a].concat(c).join().split(\",\"),\n              E = [],\n              x = [];\n            return c.forEach(function (e, t) {\n              t % 2 ? x.push(h(c[t - 1], c[t], p).y) : x.push(h(c[t], c[t + 1], p).x), 6 === x.length && (E.push(x), x = []);\n            }), E;\n          };\n        e.SVGPathElement.prototype.setAttribute = function (e, t) {\n          \"d\" === e && (this[d] = null, this[f] = null), s.call(this, e, t);\n        }, e.SVGPathElement.prototype.removeAttribute = function (e, t) {\n          \"d\" === e && (this[d] = null, this[f] = null), u.call(this, e);\n        }, e.SVGPathElement.prototype.getPathData = function (e) {\n          if (e && e.normalize) {\n            if (this[f]) return l(this[f]);\n            this[d] ? t = l(this[d]) : (t = n(this.getAttribute(\"d\") || \"\"), this[d] = l(t));\n            e = r((s = [], c = p = h = u = null, t.forEach(function (e) {\n              var t,\n                n,\n                a,\n                i,\n                o,\n                l,\n                r = e.type;\n              \"M\" === r ? (o = e.values[0], l = e.values[1], s.push({\n                type: \"M\",\n                values: [o, l]\n              }), u = p = o, h = c = l) : \"m\" === r ? (o = u + e.values[0], l = h + e.values[1], s.push({\n                type: \"M\",\n                values: [o, l]\n              }), u = p = o, h = c = l) : \"L\" === r ? (o = e.values[0], l = e.values[1], s.push({\n                type: \"L\",\n                values: [o, l]\n              }), u = o, h = l) : \"l\" === r ? (o = u + e.values[0], l = h + e.values[1], s.push({\n                type: \"L\",\n                values: [o, l]\n              }), u = o, h = l) : \"C\" === r ? (t = e.values[0], n = e.values[1], a = e.values[2], i = e.values[3], o = e.values[4], l = e.values[5], s.push({\n                type: \"C\",\n                values: [t, n, a, i, o, l]\n              }), u = o, h = l) : \"c\" === r ? (t = u + e.values[0], n = h + e.values[1], a = u + e.values[2], i = h + e.values[3], o = u + e.values[4], l = h + e.values[5], s.push({\n                type: \"C\",\n                values: [t, n, a, i, o, l]\n              }), u = o, h = l) : \"Q\" === r ? (t = e.values[0], n = e.values[1], o = e.values[2], l = e.values[3], s.push({\n                type: \"Q\",\n                values: [t, n, o, l]\n              }), u = o, h = l) : \"q\" === r ? (t = u + e.values[0], n = h + e.values[1], o = u + e.values[2], l = h + e.values[3], s.push({\n                type: \"Q\",\n                values: [t, n, o, l]\n              }), u = o, h = l) : \"A\" === r ? (o = e.values[5], l = e.values[6], s.push({\n                type: \"A\",\n                values: [e.values[0], e.values[1], e.values[2], e.values[3], e.values[4], o, l]\n              }), u = o, h = l) : \"a\" === r ? (o = u + e.values[5], l = h + e.values[6], s.push({\n                type: \"A\",\n                values: [e.values[0], e.values[1], e.values[2], e.values[3], e.values[4], o, l]\n              }), u = o, h = l) : \"H\" === r ? (o = e.values[0], s.push({\n                type: \"H\",\n                values: [o]\n              }), u = o) : \"h\" === r ? (o = u + e.values[0], s.push({\n                type: \"H\",\n                values: [o]\n              }), u = o) : \"V\" === r ? (l = e.values[0], s.push({\n                type: \"V\",\n                values: [l]\n              }), h = l) : \"v\" === r ? (l = h + e.values[0], s.push({\n                type: \"V\",\n                values: [l]\n              }), h = l) : \"S\" === r ? (a = e.values[0], i = e.values[1], o = e.values[2], l = e.values[3], s.push({\n                type: \"S\",\n                values: [a, i, o, l]\n              }), u = o, h = l) : \"s\" === r ? (a = u + e.values[0], i = h + e.values[1], o = u + e.values[2], l = h + e.values[3], s.push({\n                type: \"S\",\n                values: [a, i, o, l]\n              }), u = o, h = l) : \"T\" === r ? (o = e.values[0], l = e.values[1], s.push({\n                type: \"T\",\n                values: [o, l]\n              }), u = o, h = l) : \"t\" === r ? (o = u + e.values[0], l = h + e.values[1], s.push({\n                type: \"T\",\n                values: [o, l]\n              }), u = o, h = l) : \"Z\" !== r && \"z\" !== r || (s.push({\n                type: \"Z\",\n                values: []\n              }), u = p, h = c);\n            }), s));\n            return this[f] = l(e), e;\n          }\n          if (this[d]) return l(this[d]);\n          var s,\n            u,\n            h,\n            p,\n            c,\n            t = n(this.getAttribute(\"d\") || \"\");\n          return this[d] = l(t), t;\n        }, e.SVGPathElement.prototype.setPathData = function (e) {\n          if (0 === e.length) o ? this.setAttribute(\"d\", \"\") : this.removeAttribute(\"d\");else {\n            for (var t = \"\", n = 0, a = e.length; n < a; n += 1) {\n              var i = e[n];\n              0 < n && (t += \" \"), t += i.type, i.values && 0 < i.values.length && (t += \" \" + i.values.join(\" \"));\n            }\n            this.setAttribute(\"d\", t);\n          }\n        }, e.SVGRectElement.prototype.getPathData = function (e) {\n          var t = this.x.baseVal.value,\n            n = this.y.baseVal.value,\n            a = this.width.baseVal.value,\n            i = this.height.baseVal.value,\n            o = (this.hasAttribute(\"rx\") ? this.rx : this.ry).baseVal.value,\n            l = (this.hasAttribute(\"ry\") ? this.ry : this.rx).baseVal.value,\n            n = (n = [{\n              type: \"M\",\n              values: [t + (o = a / 2 < o ? a / 2 : o), n]\n            }, {\n              type: \"H\",\n              values: [t + a - o]\n            }, {\n              type: \"A\",\n              values: [o, l = i / 2 < l ? i / 2 : l, 0, 0, 1, t + a, n + l]\n            }, {\n              type: \"V\",\n              values: [n + i - l]\n            }, {\n              type: \"A\",\n              values: [o, l, 0, 0, 1, t + a - o, n + i]\n            }, {\n              type: \"H\",\n              values: [t + o]\n            }, {\n              type: \"A\",\n              values: [o, l, 0, 0, 1, t, n + i - l]\n            }, {\n              type: \"V\",\n              values: [n + l]\n            }, {\n              type: \"A\",\n              values: [o, l, 0, 0, 1, t + o, n]\n            }, {\n              type: \"Z\",\n              values: []\n            }]).filter(function (e) {\n              return \"A\" !== e.type || 0 !== e.values[0] && 0 !== e.values[1];\n            });\n          return n = e && !0 === e.normalize ? r(n) : n;\n        }, e.SVGCircleElement.prototype.getPathData = function (e) {\n          var t = this.cx.baseVal.value,\n            n = this.cy.baseVal.value,\n            a = this.r.baseVal.value,\n            n = [{\n              type: \"M\",\n              values: [t + a, n]\n            }, {\n              type: \"A\",\n              values: [a, a, 0, 0, 1, t, n + a]\n            }, {\n              type: \"A\",\n              values: [a, a, 0, 0, 1, t - a, n]\n            }, {\n              type: \"A\",\n              values: [a, a, 0, 0, 1, t, n - a]\n            }, {\n              type: \"A\",\n              values: [a, a, 0, 0, 1, t + a, n]\n            }, {\n              type: \"Z\",\n              values: []\n            }];\n          return n = e && !0 === e.normalize ? r(n) : n;\n        }, e.SVGEllipseElement.prototype.getPathData = function (e) {\n          var t = this.cx.baseVal.value,\n            n = this.cy.baseVal.value,\n            a = this.rx.baseVal.value,\n            i = this.ry.baseVal.value,\n            n = [{\n              type: \"M\",\n              values: [t + a, n]\n            }, {\n              type: \"A\",\n              values: [a, i, 0, 0, 1, t, n + i]\n            }, {\n              type: \"A\",\n              values: [a, i, 0, 0, 1, t - a, n]\n            }, {\n              type: \"A\",\n              values: [a, i, 0, 0, 1, t, n - i]\n            }, {\n              type: \"A\",\n              values: [a, i, 0, 0, 1, t + a, n]\n            }, {\n              type: \"Z\",\n              values: []\n            }];\n          return n = e && !0 === e.normalize ? r(n) : n;\n        }, e.SVGLineElement.prototype.getPathData = function () {\n          return [{\n            type: \"M\",\n            values: [this.x1.baseVal.value, this.y1.baseVal.value]\n          }, {\n            type: \"L\",\n            values: [this.x2.baseVal.value, this.y2.baseVal.value]\n          }];\n        }, e.SVGPolylineElement.prototype.getPathData = function () {\n          for (var e = [], t = 0; t < this.points.numberOfItems; t += 1) {\n            var n = this.points.getItem(t);\n            e.push({\n              type: 0 === t ? \"M\" : \"L\",\n              values: [n.x, n.y]\n            });\n          }\n          return e;\n        }, e.SVGPolygonElement.prototype.getPathData = function () {\n          for (var e = [], t = 0; t < this.points.numberOfItems; t += 1) {\n            var n = this.points.getItem(t);\n            e.push({\n              type: 0 === t ? \"M\" : \"L\",\n              values: [n.x, n.y]\n            });\n          }\n          return e.push({\n            type: \"Z\",\n            values: []\n          }), e;\n        };\n      }();\n    },\n    S = (a = {}, Ee.m = n = [function (e, t, n) {\n      n.r(t);\n      var a = 500,\n        i = [],\n        o = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {\n          return setTimeout(e, 1e3 / 60);\n        },\n        l = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function (e) {\n          return clearTimeout(e);\n        },\n        r = Date.now(),\n        s = void 0;\n      function u() {\n        var n = void 0,\n          e = void 0;\n        s && (l.call(window, s), s = null), i.forEach(function (e) {\n          var t;\n          (t = e.event) && (e.event = null, e.listener(t), n = !0);\n        }), n ? (r = Date.now(), e = !0) : Date.now() - r < a && (e = !0), e && (s = o.call(window, u));\n      }\n      function h(n) {\n        var a = -1;\n        return i.some(function (e, t) {\n          return e.listener === n && (a = t, !0);\n        }), a;\n      }\n      t.default = {\n        add: function add(e) {\n          var t = void 0;\n          return -1 === h(e) ? (i.push(t = {\n            listener: e\n          }), function (e) {\n            t.event = e, s || u();\n          }) : null;\n        },\n        remove: function remove(e) {\n          -1 < (e = h(e)) && (i.splice(e, 1), !i.length && s && (l.call(window, s), s = null));\n        }\n      };\n    }], Ee.c = a, Ee.d = function (e, t, n) {\n      Ee.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: n\n      });\n    }, Ee.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, Ee.t = function (t, e) {\n      if (1 & e && (t = Ee(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var n = Object.create(null);\n      if (Ee.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var a in t) Ee.d(n, a, function (e) {\n        return t[e];\n      }.bind(null, a));\n      return n;\n    }, Ee.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return Ee.d(t, \"a\", t), t;\n    }, Ee.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, Ee.p = \"\", Ee(Ee.s = 0).default),\n    de = {\n      line_altColor: {\n        iniValue: !1\n      },\n      line_color: {},\n      line_colorTra: {\n        iniValue: !1\n      },\n      line_strokeWidth: {},\n      plug_enabled: {\n        iniValue: !1\n      },\n      plug_enabledSE: {\n        hasSE: !0,\n        iniValue: !1\n      },\n      plug_plugSE: {\n        hasSE: !0,\n        iniValue: Y\n      },\n      plug_colorSE: {\n        hasSE: !0\n      },\n      plug_colorTraSE: {\n        hasSE: !0,\n        iniValue: !1\n      },\n      plug_markerWidthSE: {\n        hasSE: !0\n      },\n      plug_markerHeightSE: {\n        hasSE: !0\n      },\n      lineOutline_enabled: {\n        iniValue: !1\n      },\n      lineOutline_color: {},\n      lineOutline_colorTra: {\n        iniValue: !1\n      },\n      lineOutline_strokeWidth: {},\n      lineOutline_inStrokeWidth: {},\n      plugOutline_enabledSE: {\n        hasSE: !0,\n        iniValue: !1\n      },\n      plugOutline_plugSE: {\n        hasSE: !0,\n        iniValue: Y\n      },\n      plugOutline_colorSE: {\n        hasSE: !0\n      },\n      plugOutline_colorTraSE: {\n        hasSE: !0,\n        iniValue: !1\n      },\n      plugOutline_strokeWidthSE: {\n        hasSE: !0\n      },\n      plugOutline_inStrokeWidthSE: {\n        hasSE: !0\n      },\n      position_socketXYSE: {\n        hasSE: !0,\n        hasProps: !0\n      },\n      position_plugOverheadSE: {\n        hasSE: !0\n      },\n      position_path: {},\n      position_lineStrokeWidth: {},\n      position_socketGravitySE: {\n        hasSE: !0\n      },\n      path_pathData: {},\n      path_edge: {\n        hasProps: !0\n      },\n      viewBox_bBox: {\n        hasProps: !0\n      },\n      viewBox_plugBCircleSE: {\n        hasSE: !0\n      },\n      lineMask_enabled: {\n        iniValue: !1\n      },\n      lineMask_outlineMode: {\n        iniValue: !1\n      },\n      lineMask_x: {},\n      lineMask_y: {},\n      lineOutlineMask_x: {},\n      lineOutlineMask_y: {},\n      maskBGRect_x: {},\n      maskBGRect_y: {},\n      capsMaskAnchor_enabledSE: {\n        hasSE: !0,\n        iniValue: !1\n      },\n      capsMaskAnchor_pathDataSE: {\n        hasSE: !0\n      },\n      capsMaskAnchor_strokeWidthSE: {\n        hasSE: !0\n      },\n      capsMaskMarker_enabled: {\n        iniValue: !1\n      },\n      capsMaskMarker_enabledSE: {\n        hasSE: !0,\n        iniValue: !1\n      },\n      capsMaskMarker_plugSE: {\n        hasSE: !0,\n        iniValue: Y\n      },\n      capsMaskMarker_markerWidthSE: {\n        hasSE: !0\n      },\n      capsMaskMarker_markerHeightSE: {\n        hasSE: !0\n      },\n      caps_enabled: {\n        iniValue: !1\n      },\n      attach_plugSideLenSE: {\n        hasSE: !0\n      },\n      attach_plugBackLenSE: {\n        hasSE: !0\n      }\n    },\n    fe = {\n      show_on: {},\n      show_effect: {},\n      show_animOptions: {},\n      show_animId: {},\n      show_inAnim: {}\n    },\n    ye = \"fade\",\n    me = [],\n    Se = {},\n    ge = 0,\n    _e = {},\n    ve = 0;\n  function Ee(e) {\n    if (a[e]) return a[e].exports;\n    var t = a[e] = {\n      i: e,\n      l: !1,\n      exports: {}\n    };\n    return n[e].call(t.exports, t, t.exports, Ee), t.l = !0, t.exports;\n  }\n  function xe() {\n    var i = Date.now(),\n      o = !1;\n    e && (r.call(window, e), e = null), E.forEach(function (e) {\n      var t, n, a;\n      if (e.framesStart) {\n        if ((t = i - e.framesStart) >= e.duration && e.count && e.loopsLeft <= 1) return a = e.frames[e.lastFrame = e.reverse ? 0 : e.frames.length - 1], e.frameCallback(a.value, !0, a.timeRatio, a.outputRatio), void (e.framesStart = null);\n        if (t > e.duration) {\n          if (n = Math.floor(t / e.duration), e.count) {\n            if (n >= e.loopsLeft) return a = e.frames[e.lastFrame = e.reverse ? 0 : e.frames.length - 1], e.frameCallback(a.value, !0, a.timeRatio, a.outputRatio), void (e.framesStart = null);\n            e.loopsLeft -= n;\n          }\n          e.framesStart += e.duration * n, t = i - e.framesStart;\n        }\n        e.reverse && (t = e.duration - t), a = e.frames[e.lastFrame = Math.round(t / v)], !1 !== e.frameCallback(a.value, !1, a.timeRatio, a.outputRatio) ? o = !0 : e.framesStart = null;\n      }\n    }), o && (e = l.call(window, xe));\n  }\n  function be(e, t) {\n    e.framesStart = Date.now(), null != t && (e.framesStart -= e.duration * (e.reverse ? 1 - t : t)), e.loopsLeft = e.count, e.lastFrame = null, xe();\n  }\n  function ke(t, n) {\n    var e, a;\n    return typeof t != typeof n || (e = he(t) ? \"obj\" : Array.isArray(t) ? \"array\" : \"\") != (he(n) ? \"obj\" : Array.isArray(n) ? \"array\" : \"\") || (\"obj\" === e ? ke(a = Object.keys(t).sort(), Object.keys(n).sort()) || a.some(function (e) {\n      return ke(t[e], n[e]);\n    }) : \"array\" === e ? t.length !== n.length || t.some(function (e, t) {\n      return ke(e, n[t]);\n    }) : t !== n);\n  }\n  function we(n) {\n    return n && (he(n) ? Object.keys(n).reduce(function (e, t) {\n      return e[t] = we(n[t]), e;\n    }, {}) : Array.isArray(n) ? n.map(we) : n);\n  }\n  function Oe(e) {\n    var t,\n      n,\n      a,\n      i = 1,\n      o = e = (e + \"\").trim();\n    function l(e) {\n      var t = 1,\n        e = m.exec(e);\n      return e && (t = parseFloat(e[1]), e[2] ? t = 0 <= t && t <= 100 ? t / 100 : 1 : (t < 0 || 1 < t) && (t = 1)), t;\n    }\n    return (t = /^(rgba|hsla|hwb|gray|device\\-cmyk)\\s*\\(([\\s\\S]+)\\)$/i.exec(e)) ? (n = t[1].toLowerCase(), a = t[2].trim().split(/\\s*,\\s*/), \"rgba\" === n && 4 === a.length ? (i = l(a[3]), o = \"rgb(\" + a.slice(0, 3).join(\", \") + \")\") : \"hsla\" === n && 4 === a.length ? (i = l(a[3]), o = \"hsl(\" + a.slice(0, 3).join(\", \") + \")\") : \"hwb\" === n && 4 === a.length ? (i = l(a[3]), o = \"hwb(\" + a.slice(0, 3).join(\", \") + \")\") : \"gray\" === n && 2 === a.length ? (i = l(a[1]), o = \"gray(\" + a[0] + \")\") : \"device-cmyk\" === n && 5 <= a.length && (i = l(a[4]), o = \"device-cmyk(\" + a.slice(0, 4).join(\", \") + \")\")) : (t = /^\\#(?:([\\da-f]{6})([\\da-f]{2})|([\\da-f]{3})([\\da-f]))$/i.exec(e)) ? o = t[1] ? (i = parseInt(t[2], 16) / 255, \"#\" + t[1]) : (i = parseInt(t[4] + t[4], 16) / 255, \"#\" + t[3]) : \"transparent\" === e.toLocaleLowerCase() && (i = 0), [i, o];\n  }\n  function Me(e) {\n    return !(!e || e.nodeType !== Node.ELEMENT_NODE || \"function\" != typeof e.getBoundingClientRect);\n  }\n  function Ie(e, t) {\n    var n,\n      a,\n      i,\n      o = {};\n    if (!(i = e.ownerDocument)) return console.error(\"Cannot get document that contains the element.\"), null;\n    if (e.compareDocumentPosition(i) & Node.DOCUMENT_POSITION_DISCONNECTED) return console.error(\"A disconnected element was passed.\"), null;\n    for (a in n = e.getBoundingClientRect()) o[a] = n[a];\n    if (!t) {\n      if (!(i = i.defaultView)) return console.error(\"Cannot get window that contains the element.\"), null;\n      o.left += i.pageXOffset, o.right += i.pageXOffset, o.top += i.pageYOffset, o.bottom += i.pageYOffset;\n    }\n    return o;\n  }\n  function Ce(e, t) {\n    var n,\n      a = [],\n      i = e;\n    for (t = t || window;;) {\n      if (!(n = i.ownerDocument)) return console.error(\"Cannot get document that contains the element.\"), null;\n      if (!(n = n.defaultView)) return console.error(\"Cannot get window that contains the element.\"), null;\n      if (n === t) break;\n      if (!(i = n.frameElement)) return console.error(\"`baseWindow` was not found.\"), null;\n      a.unshift(i);\n    }\n    return a;\n  }\n  function Le(e, t) {\n    var a = 0,\n      i = 0;\n    return (t = Ce(e, t = t || window)) ? t.length ? (t.forEach(function (e, t) {\n      var n = Ie(e, 0 < t);\n      a += n.left, i += n.top, e = (t = e).ownerDocument.defaultView.getComputedStyle(t, \"\"), n = {\n        left: t.clientLeft + parseFloat(e.paddingLeft),\n        top: t.clientTop + parseFloat(e.paddingTop)\n      }, a += n.left, i += n.top;\n    }), (t = Ie(e, !0)).left += a, t.right += a, t.top += i, t.bottom += i, t) : Ie(e) : null;\n  }\n  function Ae(e, t) {\n    var n = e.x - t.x,\n      t = e.y - t.y;\n    return Math.sqrt(n * n + t * t);\n  }\n  function Ve(e, t, n) {\n    var a = t.x - e.x,\n      t = t.y - e.y;\n    return {\n      x: e.x + a * n,\n      y: e.y + t * n,\n      angle: Math.atan2(t, a) / (Math.PI / 180)\n    };\n  }\n  function Pe(e, t, n) {\n    e = Math.atan2(e.y - t.y, t.x - e.x);\n    return {\n      x: t.x + Math.cos(e) * n,\n      y: t.y + Math.sin(e) * n * -1\n    };\n  }\n  function Ne(e, t, n, a, i) {\n    var o = i * i,\n      l = o * i,\n      r = 1 - i,\n      s = r * r,\n      u = s * r,\n      h = u * e.x + 3 * s * i * t.x + 3 * r * o * n.x + l * a.x,\n      p = u * e.y + 3 * s * i * t.y + 3 * r * o * n.y + l * a.y,\n      c = e.x + 2 * i * (t.x - e.x) + o * (n.x - 2 * t.x + e.x),\n      u = e.y + 2 * i * (t.y - e.y) + o * (n.y - 2 * t.y + e.y),\n      s = t.x + 2 * i * (n.x - t.x) + o * (a.x - 2 * n.x + t.x),\n      l = t.y + 2 * i * (n.y - t.y) + o * (a.y - 2 * n.y + t.y),\n      o = r * e.x + i * t.x,\n      e = r * e.y + i * t.y,\n      t = r * n.x + i * a.x,\n      i = r * n.y + i * a.y,\n      a = 90 - 180 * Math.atan2(c - s, u - l) / Math.PI;\n    return {\n      x: h,\n      y: p,\n      fromP2: {\n        x: c,\n        y: u\n      },\n      toP1: {\n        x: s,\n        y: l\n      },\n      fromP1: {\n        x: o,\n        y: e\n      },\n      toP2: {\n        x: t,\n        y: i\n      },\n      angle: a += 180 < a ? -180 : 180\n    };\n  }\n  function Te(n, a, i, o, e) {\n    function l(e, t, n, a, i) {\n      return e * (e * (-3 * t + 9 * n - 9 * a + 3 * i) + 6 * t - 12 * n + 6 * a) - 3 * t + 3 * n;\n    }\n    var r,\n      s,\n      u = [.2491, .2491, .2335, .2335, .2032, .2032, .1601, .1601, .1069, .1069, .0472, .0472],\n      h = 0,\n      p = (e = null == e || 1 < e ? 1 : e < 0 ? 0 : e) / 2;\n    return [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816].forEach(function (e, t) {\n      r = l(s = p * e + p, n.x, a.x, i.x, o.x), s = l(s, n.y, a.y, i.y, o.y), s = r * r + s * s, h += u[t] * Math.sqrt(s);\n    }), p * h;\n  }\n  function We(e, t, n, a, i) {\n    for (var o, l = .5, r = 1 - l; o = Te(e, t, n, a, r), !(Math.abs(o - i) <= .01);) r += (o < i ? 1 : -1) * (l /= 2);\n    return r;\n  }\n  function Be(e, t) {\n    var n;\n    return e.forEach(function (e) {\n      e = t ? e.map(function (e) {\n        e = {\n          x: e.x,\n          y: e.y\n        };\n        return t(e), e;\n      }) : e;\n      (n = n || [{\n        type: \"M\",\n        values: [e[0].x, e[0].y]\n      }]).push(e.length ? 2 === e.length ? {\n        type: \"L\",\n        values: [e[1].x, e[1].y]\n      } : {\n        type: \"C\",\n        values: [e[1].x, e[1].y, e[2].x, e[2].y, e[3].x, e[3].y]\n      } : {\n        type: \"Z\",\n        values: []\n      });\n    }), n;\n  }\n  function Re(e) {\n    var t = [],\n      n = 0;\n    return e.forEach(function (e) {\n      e = (2 === e.length ? Ae : Te).apply(null, e);\n      t.push(e), n += e;\n    }), {\n      segsLen: t,\n      lenAll: n\n    };\n  }\n  function Fe(e, a) {\n    return null == e || null == a || e.length !== a.length || e.some(function (e, t) {\n      var n = a[t];\n      return e.type !== n.type || e.values.some(function (e, t) {\n        return e !== n.values[t];\n      });\n    });\n  }\n  function Ge(e, t, n) {\n    e.events[t] ? e.events[t].indexOf(n) < 0 && e.events[t].push(n) : e.events[t] = [n];\n  }\n  function De(e, t, n) {\n    var a;\n    e.events[t] && -1 < (a = e.events[t].indexOf(n)) && e.events[t].splice(a, 1);\n  }\n  function ze(e) {\n    t && clearTimeout(t), me.push(e), t = setTimeout(function () {\n      me.forEach(function (e) {\n        e();\n      }), me = [];\n    }, 0);\n  }\n  function je(e, t) {\n    e.reflowTargets.indexOf(t) < 0 && e.reflowTargets.push(t);\n  }\n  function He(e) {\n    e.reflowTargets.forEach(function (e) {\n      var n;\n      n = e, setTimeout(function () {\n        var e = n.parentNode,\n          t = n.nextSibling;\n        e.insertBefore(e.removeChild(n), t);\n      }, 0);\n    }), e.reflowTargets = [];\n  }\n  function Ue(e, t, n, a, i, o, l) {\n    var r;\n    \"auto-start-reverse\" === n ? (\"boolean\" != typeof s && (t.setAttribute(\"orient\", \"auto-start-reverse\"), s = t.orientType.baseVal === SVGMarkerElement.SVG_MARKER_ORIENT_UNKNOWN), s ? t.setAttribute(\"orient\", n) : ((r = i.createSVGTransform()).setRotate(180, 0, 0), o.transform.baseVal.appendItem(r), t.setAttribute(\"orient\", \"auto\"), r = !0)) : (t.setAttribute(\"orient\", n), !1 === s && o.transform.baseVal.clear()), t = t.viewBox.baseVal, r ? (t.x = -a.right, t.y = -a.bottom) : (t.x = a.left, t.y = a.top), t.width = a.width, t.height = a.height, ie && je(e, l);\n  }\n  function Ze(e, t) {\n    return {\n      prop: e ? \"markerEnd\" : \"markerStart\",\n      orient: t ? t.noRotate ? \"0\" : e ? \"auto\" : \"auto-start-reverse\" : null\n    };\n  }\n  function Ye(n, a) {\n    Object.keys(a).forEach(function (e) {\n      var t = a[e];\n      n[e] = null != t.iniValue ? t.hasSE ? [t.iniValue, t.iniValue] : t.iniValue : t.hasSE ? t.hasProps ? [{}, {}] : [] : t.hasProps ? {} : null;\n    });\n  }\n  function Xe(t, e, n, a, i) {\n    return a !== e[n] && (e[n] = a, i && i.forEach(function (e) {\n      e(t, a, n);\n    }), !0);\n  }\n  function qe(e) {\n    function t(e, t) {\n      return e + parseFloat(t);\n    }\n    var n = e.document,\n      a = e.getComputedStyle(n.documentElement, \"\"),\n      e = e.getComputedStyle(n.body, \"\"),\n      n = {\n        x: 0,\n        y: 0\n      };\n    return \"static\" !== e.position ? (n.x -= [a.marginLeft, a.borderLeftWidth, a.paddingLeft, e.marginLeft, e.borderLeftWidth].reduce(t, 0), n.y -= [a.marginTop, a.borderTopWidth, a.paddingTop, e.marginTop, e.borderTopWidth].reduce(t, 0)) : \"static\" !== a.position && (n.x -= [a.marginLeft, a.borderLeftWidth].reduce(t, 0), n.y -= [a.marginTop, a.borderTopWidth].reduce(t, 0)), n;\n  }\n  function Qe(e) {\n    var t,\n      n = e.document;\n    n.getElementById(f) || (t = new e.DOMParser().parseFromString(y, \"image/svg+xml\"), n.body.appendChild(t.documentElement), ce(e));\n  }\n  function Ke(l) {\n    var g,\n      c,\n      _,\n      e,\n      n,\n      a,\n      i,\n      d,\n      o,\n      r,\n      s,\n      t,\n      u,\n      h,\n      p = l.options,\n      f = l.curStats,\n      y = l.aplStats,\n      v = f.position_socketXYSE,\n      m = !1;\n    function S(e, t) {\n      e = t === b ? {\n        x: e.left + e.width / 2,\n        y: e.top\n      } : t === k ? {\n        x: e.right,\n        y: e.top + e.height / 2\n      } : t === L ? {\n        x: e.left + e.width / 2,\n        y: e.bottom\n      } : {\n        x: e.left,\n        y: e.top + e.height / 2\n      };\n      return e.socketId = t, e;\n    }\n    function E(e) {\n      return {\n        x: e.x,\n        y: e.y\n      };\n    }\n    if (f.position_path = p.path, f.position_lineStrokeWidth = f.line_strokeWidth, f.position_socketGravitySE = g = we(p.socketGravitySE), c = [0, 1].map(function (e) {\n      var t = p.anchorSE[e],\n        n = l.optionIsAttach.anchorSE[e],\n        a = !1 !== n ? _e[t._id] : null,\n        i = !1 !== n && a.conf.getStrokeWidth ? a.conf.getStrokeWidth(a, l) : 0,\n        o = !1 !== n && a.conf.getBBoxNest ? a.conf.getBBoxNest(a, l, i) : Le(t, l.baseWindow);\n      return f.capsMaskAnchor_pathDataSE[e] = !1 !== n && a.conf.getPathData ? a.conf.getPathData(a, l, i) : (n = null != (t = o).right ? t.right : t.left + t.width, a = null != t.bottom ? t.bottom : t.top + t.height, [{\n        type: \"M\",\n        values: [t.left, t.top]\n      }, {\n        type: \"L\",\n        values: [n, t.top]\n      }, {\n        type: \"L\",\n        values: [n, a]\n      }, {\n        type: \"L\",\n        values: [t.left, a]\n      }, {\n        type: \"Z\",\n        values: []\n      }]), f.capsMaskAnchor_strokeWidthSE[e] = i, o;\n    }), i = -1, p.socketSE[0] && p.socketSE[1] ? (v[0] = S(c[0], p.socketSE[0]), v[1] = S(c[1], p.socketSE[1])) : (p.socketSE[0] || p.socketSE[1] ? (a = p.socketSE[0] ? (n = 0, 1) : (n = 1, 0), v[n] = S(c[n], p.socketSE[n]), (e = G.map(function (e) {\n      return S(c[a], e);\n    })).forEach(function (e) {\n      var t = Ae(e, v[n]);\n      (t < i || -1 === i) && (v[a] = e, i = t);\n    })) : (e = G.map(function (e) {\n      return S(c[1], e);\n    }), G.map(function (e) {\n      return S(c[0], e);\n    }).forEach(function (n) {\n      e.forEach(function (e) {\n        var t = Ae(n, e);\n        (t < i || -1 === i) && (v[0] = n, v[1] = e, i = t);\n      });\n    })), [0, 1].forEach(function (e) {\n      var t, n;\n      p.socketSE[e] || (c[e].width || c[e].height ? c[e].width || v[e].socketId !== A && v[e].socketId !== k ? c[e].height || v[e].socketId !== b && v[e].socketId !== L || (v[e].socketId = 0 <= v[e ? 0 : 1].y - c[e].top ? L : b) : v[e].socketId = 0 <= v[e ? 0 : 1].x - c[e].left ? k : A : (t = v[e ? 0 : 1].x - c[e].left, n = v[e ? 0 : 1].y - c[e].top, v[e].socketId = Math.abs(t) >= Math.abs(n) ? 0 <= t ? k : A : 0 <= n ? L : b));\n    })), f.position_path !== y.position_path || f.position_lineStrokeWidth !== y.position_lineStrokeWidth || [0, 1].some(function (e) {\n      return f.position_plugOverheadSE[e] !== y.position_plugOverheadSE[e] || (t = v[e], n = y.position_socketXYSE[e], t.x !== n.x || t.y !== n.y || t.socketId !== n.socketId) || (t = g[e], n = y.position_socketGravitySE[e], (e = null == t ? \"auto\" : Array.isArray(t) ? \"array\" : \"number\") != (null == n ? \"auto\" : Array.isArray(n) ? \"array\" : \"number\") || (\"array\" == e ? t[0] !== n[0] || t[1] !== n[1] : t !== n));\n      var t, n;\n    })) {\n      switch (l.pathList.baseVal = _ = [], l.pathList.animVal = null, f.position_path) {\n        case P:\n          _.push([E(v[0]), E(v[1])]);\n          break;\n        case N:\n          t = \"number\" == typeof g[0] && 0 < g[0] || \"number\" == typeof g[1] && 0 < g[1], u = ne * (t ? -1 : 1), h = Math.atan2(v[1].y - v[0].y, v[1].x - v[0].x), t = u - h, h = Math.PI - h - u, u = Ae(v[0], v[1]) / Math.sqrt(2) * te, t = {\n            x: v[0].x + Math.cos(t) * u,\n            y: v[0].y + Math.sin(t) * u * -1\n          }, u = {\n            x: v[1].x + Math.cos(h) * u,\n            y: v[1].y + Math.sin(h) * u * -1\n          }, _.push([E(v[0]), t, u, E(v[1])]);\n          break;\n        case T:\n        case W:\n          o = [g[0], f.position_path === W ? 0 : g[1]], r = [], s = [], v.forEach(function (e, t) {\n            var n,\n              a = o[t],\n              i = Array.isArray(a) ? {\n                x: a[0],\n                y: a[1]\n              } : \"number\" == typeof a ? e.socketId === b ? {\n                x: 0,\n                y: -a\n              } : e.socketId === k ? {\n                x: a,\n                y: 0\n              } : e.socketId === L ? {\n                x: 0,\n                y: a\n              } : {\n                x: -a,\n                y: 0\n              } : (n = v[t ? 0 : 1], a = 0 < (a = f.position_plugOverheadSE[t]) ? U + (K < a ? (a - K) * J : 0) : z + (f.position_lineStrokeWidth > j ? (f.position_lineStrokeWidth - j) * H : 0), e.socketId === b ? {\n                x: 0,\n                y: -(i = (i = (e.y - n.y) / 2) < a ? a : i)\n              } : e.socketId === k ? {\n                x: i = (i = (n.x - e.x) / 2) < a ? a : i,\n                y: 0\n              } : e.socketId === L ? {\n                x: 0,\n                y: i = (i = (n.y - e.y) / 2) < a ? a : i\n              } : {\n                x: -(i = (i = (e.x - n.x) / 2) < a ? a : i),\n                y: 0\n              });\n            r[t] = e.x + i.x, s[t] = e.y + i.y;\n          }), _.push([E(v[0]), {\n            x: r[0],\n            y: s[0]\n          }, {\n            x: r[1],\n            y: s[1]\n          }, E(v[1])]);\n          break;\n        case B:\n          !function () {\n            var n,\n              i = 1,\n              l = 2,\n              r = 3,\n              o = 4,\n              s = [[], []],\n              u = [];\n            function h(e) {\n              return e === i ? r : e === l ? o : e === r ? i : l;\n            }\n            function p(e) {\n              return e === l || e === o ? \"x\" : \"y\";\n            }\n            function c(e, t, n) {\n              var a = {\n                x: e.x,\n                y: e.y\n              };\n              if (n) {\n                if (n === h(e.dirId)) throw new Error(\"Invalid dirId: \" + n);\n                a.dirId = n;\n              } else a.dirId = e.dirId;\n              return a.dirId === i ? a.y -= t : a.dirId === l ? a.x += t : a.dirId === r ? a.y += t : a.x -= t, a;\n            }\n            function d(e, t) {\n              return t.dirId === i ? e.y <= t.y : t.dirId === l ? e.x >= t.x : t.dirId === r ? e.y >= t.y : e.x <= t.x;\n            }\n            function f(e, t) {\n              return t.dirId === i || t.dirId === r ? e.x === t.x : e.y === t.y;\n            }\n            function y(e) {\n              return e[0] ? {\n                contain: 0,\n                notContain: 1\n              } : {\n                contain: 1,\n                notContain: 0\n              };\n            }\n            function m(e, t, n) {\n              return Math.abs(t[n] - e[n]);\n            }\n            function S(e, t, n) {\n              return \"x\" === n ? e.x < t.x ? l : o : e.y < t.y ? r : i;\n            }\n            for (v.forEach(function (e, t) {\n              var n = E(e),\n                a = g[t];\n              e = Array.isArray(a) ? a[0] < 0 ? [o, -a[0]] : 0 < a[0] ? [l, a[0]] : a[1] < 0 ? [i, -a[1]] : 0 < a[1] ? [r, a[1]] : [e.socketId, 0] : \"number\" != typeof a ? [e.socketId, ee] : 0 <= a ? [e.socketId, a] : [h(e.socketId), -a], n.dirId = e[0], a = e[1], s[t].push(n), u[t] = c(n, a);\n            }); function () {\n              var e,\n                t,\n                a,\n                i,\n                n = [d(u[1], u[0]), d(u[0], u[1])],\n                o = [p(u[0].dirId), p(u[1].dirId)];\n              if (o[0] === o[1]) {\n                if (n[0] && n[1]) return void (f(u[1], u[0]) || (u[0][o[0]] === u[1][o[1]] ? (s[0].push(u[0]), s[1].push(u[1])) : (e = u[0][o[0]] + (u[1][o[1]] - u[0][o[0]]) / 2, s[0].push(c(u[0], Math.abs(e - u[0][o[0]]))), s[1].push(c(u[1], Math.abs(e - u[1][o[1]]))))));\n                n[0] !== n[1] ? (t = y(n), (a = m(u[t.notContain], u[t.contain], o[t.notContain])) < ee && (u[t.notContain] = c(u[t.notContain], ee - a)), s[t.notContain].push(u[t.notContain]), u[t.notContain] = c(u[t.notContain], ee, f(u[t.contain], u[t.notContain]) ? \"x\" === o[t.notContain] ? r : l : S(u[t.notContain], u[t.contain], \"x\" === o[t.notContain] ? \"y\" : \"x\"))) : (a = m(u[0], u[1], \"x\" === o[0] ? \"y\" : \"x\"), s.forEach(function (e, t) {\n                  var n = 0 === t ? 1 : 0;\n                  e.push(u[t]), u[t] = c(u[t], ee, 2 * ee <= a ? S(u[t], u[n], \"x\" === o[t] ? \"y\" : \"x\") : \"x\" === o[t] ? r : l);\n                }));\n              } else {\n                if (n[0] && n[1]) return void (f(u[1], u[0]) ? s[1].push(u[1]) : f(u[0], u[1]) ? s[0].push(u[0]) : s[0].push(\"x\" === o[0] ? {\n                  x: u[1].x,\n                  y: u[0].y\n                } : {\n                  x: u[0].x,\n                  y: u[1].y\n                }));\n                n[0] !== n[1] ? (t = y(n), s[t.notContain].push(u[t.notContain]), u[t.notContain] = c(u[t.notContain], ee, m(u[t.notContain], u[t.contain], o[t.contain]) >= ee ? S(u[t.notContain], u[t.contain], o[t.contain]) : u[t.contain].dirId)) : (i = [{\n                  x: u[0].x,\n                  y: u[0].y\n                }, {\n                  x: u[1].x,\n                  y: u[1].y\n                }], s.forEach(function (e, t) {\n                  var n = 0 === t ? 1 : 0,\n                    a = m(i[t], i[n], o[t]);\n                  a < ee && (u[t] = c(u[t], ee - a)), e.push(u[t]), u[t] = c(u[t], ee, S(u[t], u[n], o[n]));\n                }));\n              }\n              return 1;\n            }(););\n            s[1].reverse(), s[0].concat(s[1]).forEach(function (e, t) {\n              e = {\n                x: e.x,\n                y: e.y\n              };\n              0 < t && _.push([n, e]), n = e;\n            });\n          }();\n      }\n      d = [], f.position_plugOverheadSE.forEach(function (e, t) {\n        var n,\n          a,\n          i,\n          o,\n          l,\n          r,\n          s,\n          u,\n          h,\n          p = !t;\n        0 < e ? 2 === (n = _[a = p ? 0 : _.length - 1]).length ? (d[a] = d[a] || Ae.apply(null, n), d[a] > $ && (d[a] - e < $ && (e = d[a] - $), s = Ve(n[0], n[1], (p ? e : d[a] - e) / d[a]), _[a] = p ? [s, n[1]] : [n[0], s], d[a] -= e)) : (d[a] = d[a] || Te.apply(null, n), d[a] > $ && (d[a] - e < $ && (e = d[a] - $), s = Ne(n[0], n[1], n[2], n[3], We(n[0], n[1], n[2], n[3], p ? e : d[a] - e)), o = p ? (i = n[0], s.toP1) : (i = n[3], s.fromP2), l = Math.atan2(i.y - s.y, s.x - i.x), r = Ae(s, o), s.x = i.x + Math.cos(l) * e, s.y = i.y + Math.sin(l) * e * -1, o.x = s.x + Math.cos(l) * r, o.y = s.y + Math.sin(l) * r * -1, _[a] = p ? [s, s.toP1, s.toP2, n[3]] : [n[0], s.fromP1, s.fromP2, s], d[a] = null)) : e < 0 && (n = _[a = p ? 0 : _.length - 1], s = v[t].socketId, t = -c[t][\"x\" == (u = s === A || s === k ? \"x\" : \"y\") ? \"width\" : \"height\"], h = (e = e < t ? t : e) * (s === A || s === b ? -1 : 1), 2 === n.length ? n[p ? 0 : n.length - 1][u] += h : (p ? [0, 1] : [n.length - 2, n.length - 1]).forEach(function (e) {\n          n[e][u] += h;\n        }), d[a] = null);\n      }), y.position_socketXYSE = we(v), y.position_plugOverheadSE = we(f.position_plugOverheadSE), y.position_path = f.position_path, y.position_lineStrokeWidth = f.position_lineStrokeWidth, y.position_socketGravitySE = we(g), m = !0, l.events.apl_position && l.events.apl_position.forEach(function (e) {\n        e(l, _);\n      });\n    }\n    return m;\n  }\n  function Je(t, n) {\n    n !== t.isShown && (!!n != !!t.isShown && (t.svg.style.visibility = n ? \"\" : \"hidden\"), t.isShown = n, t.events && t.events.svgShow && t.events.svgShow.forEach(function (e) {\n      e(t, n);\n    }));\n  }\n  function $e(e, t) {\n    var n,\n      a,\n      h,\n      p,\n      c,\n      d,\n      f,\n      i,\n      o,\n      l,\n      r,\n      s,\n      u,\n      y,\n      m,\n      S,\n      g,\n      _,\n      v,\n      E,\n      x,\n      b,\n      k,\n      w,\n      O,\n      M,\n      I,\n      C,\n      L,\n      A,\n      V,\n      P,\n      N,\n      T,\n      W,\n      B,\n      R,\n      F,\n      G,\n      D,\n      z,\n      j,\n      H,\n      U = {};\n    t.line && (U.line = (i = (n = e).options, a = n.curStats, o = n.events, l = !1, l = Xe(n, a, \"line_color\", i.lineColor, o.cur_line_color) || l, l = Xe(n, a, \"line_colorTra\", Oe(a.line_color)[0] < 1) || l, l = Xe(n, a, \"line_strokeWidth\", i.lineSize, o.cur_line_strokeWidth) || l)), (t.plug || U.line) && (U.plug = (p = (h = e).options, c = h.curStats, d = h.events, f = !1, [0, 1].forEach(function (e) {\n      var t,\n        n,\n        a,\n        i,\n        o,\n        l,\n        r,\n        s,\n        u = p.plugSE[e];\n      f = Xe(h, c.plug_enabledSE, e, u !== Y) || f, f = Xe(h, c.plug_plugSE, e, u) || f, f = Xe(h, c.plug_colorSE, e, s = p.plugColorSE[e] || c.line_color, d.cur_plug_colorSE) || f, f = Xe(h, c.plug_colorTraSE, e, Oe(s)[0] < 1) || f, u !== Y && (i = n = (t = X[q[u]]).widthR * p.plugSizeSE[e], o = a = t.heightR * p.plugSizeSE[e], re && (i *= c.line_strokeWidth, o *= c.line_strokeWidth), f = Xe(h, c.plug_markerWidthSE, e, i) || f, f = Xe(h, c.plug_markerHeightSE, e, o) || f, c.capsMaskMarker_markerWidthSE[e] = n, c.capsMaskMarker_markerHeightSE[e] = a), c.plugOutline_plugSE[e] = c.capsMaskMarker_plugSE[e] = u, c.plug_enabledSE[e] ? (s = c.line_strokeWidth / ue.lineSize * p.plugSizeSE[e], c.position_plugOverheadSE[e] = t.overhead * s, c.viewBox_plugBCircleSE[e] = t.bCircle * s, l = t.sideLen * s, r = t.backLen * s) : (c.position_plugOverheadSE[e] = -c.line_strokeWidth / 2, c.viewBox_plugBCircleSE[e] = l = r = 0), Xe(h, c.attach_plugSideLenSE, e, l, d.cur_attach_plugSideLenSE), Xe(h, c.attach_plugBackLenSE, e, r, d.cur_attach_plugBackLenSE), c.capsMaskAnchor_enabledSE[e] = !c.plug_enabledSE[e];\n    }), f = Xe(h, c, \"plug_enabled\", c.plug_enabledSE[0] || c.plug_enabledSE[1]) || f)), (t.lineOutline || U.line) && (U.lineOutline = (o = (i = e).options, l = i.curStats, k = !1, k = Xe(i, l, \"lineOutline_enabled\", o.lineOutlineEnabled) || k, k = Xe(i, l, \"lineOutline_color\", o.lineOutlineColor) || k, k = Xe(i, l, \"lineOutline_colorTra\", Oe(l.lineOutline_color)[0] < 1) || k, o = l.line_strokeWidth * o.lineOutlineSize, k = Xe(i, l, \"lineOutline_strokeWidth\", l.line_strokeWidth - 2 * o) || k, k = Xe(i, l, \"lineOutline_inStrokeWidth\", l.lineOutline_colorTra ? l.lineOutline_strokeWidth + 2 * se : l.line_strokeWidth - o) || k)), (t.plugOutline || U.line || U.plug || U.lineOutline) && (U.plugOutline = (s = (r = e).options, u = r.curStats, y = !1, [0, 1].forEach(function (e) {\n      var t = u.plugOutline_plugSE[e],\n        n = t !== Y ? X[q[t]] : null;\n      y = Xe(r, u.plugOutline_enabledSE, e, s.plugOutlineEnabledSE[e] && u.plug_enabled && u.plug_enabledSE[e] && !!n && !!n.outlineBase) || y, y = Xe(r, u.plugOutline_colorSE, e, t = s.plugOutlineColorSE[e] || u.lineOutline_color) || y, y = Xe(r, u.plugOutline_colorTraSE, e, Oe(t)[0] < 1) || y, n && n.outlineBase && ((t = s.plugOutlineSizeSE[e]) > n.outlineMax && (t = n.outlineMax), t *= 2 * n.outlineBase, y = Xe(r, u.plugOutline_strokeWidthSE, e, t) || y, y = Xe(r, u.plugOutline_inStrokeWidthSE, e, u.plugOutline_colorTraSE[e] ? t - se / (u.line_strokeWidth / ue.lineSize) / s.plugSizeSE[e] * 2 : t / 2) || y);\n    }), y)), (t.faces || U.line || U.plug || U.lineOutline || U.plugOutline) && (U.faces = (g = (m = e).curStats, _ = m.aplStats, v = m.events, E = !1, !g.line_altColor && Xe(m, _, \"line_color\", S = g.line_color, v.apl_line_color) && (m.lineFace.style.stroke = S, E = !0), Xe(m, _, \"line_strokeWidth\", S = g.line_strokeWidth, v.apl_line_strokeWidth) && (m.lineShape.style.strokeWidth = S + \"px\", E = !0, (oe || ie) && (je(m, m.lineShape), ie && (je(m, m.lineFace), je(m, m.lineMaskCaps)))), Xe(m, _, \"lineOutline_enabled\", S = g.lineOutline_enabled, v.apl_lineOutline_enabled) && (m.lineOutlineFace.style.display = S ? \"inline\" : \"none\", E = !0), g.lineOutline_enabled && (Xe(m, _, \"lineOutline_color\", S = g.lineOutline_color, v.apl_lineOutline_color) && (m.lineOutlineFace.style.stroke = S, E = !0), Xe(m, _, \"lineOutline_strokeWidth\", S = g.lineOutline_strokeWidth, v.apl_lineOutline_strokeWidth) && (m.lineOutlineMaskShape.style.strokeWidth = S + \"px\", E = !0, ie && (je(m, m.lineOutlineMaskCaps), je(m, m.lineOutlineFace))), Xe(m, _, \"lineOutline_inStrokeWidth\", S = g.lineOutline_inStrokeWidth, v.apl_lineOutline_inStrokeWidth) && (m.lineMaskShape.style.strokeWidth = S + \"px\", E = !0, ie && (je(m, m.lineOutlineMaskCaps), je(m, m.lineOutlineFace)))), Xe(m, _, \"plug_enabled\", S = g.plug_enabled, v.apl_plug_enabled) && (m.plugsFace.style.display = S ? \"inline\" : \"none\", E = !0), g.plug_enabled && [0, 1].forEach(function (n) {\n      var e = g.plug_plugSE[n],\n        t = e !== Y ? X[q[e]] : null,\n        a = Ze(n, t);\n      Xe(m, _.plug_enabledSE, n, S = g.plug_enabledSE[n], v.apl_plug_enabledSE) && (m.plugsFace.style[a.prop] = S ? \"url(#\" + m.plugMarkerIdSE[n] + \")\" : \"none\", E = !0), g.plug_enabledSE[n] && (Xe(m, _.plug_plugSE, n, e, v.apl_plug_plugSE) && (m.plugFaceSE[n].href.baseVal = \"#\" + t.elmId, Ue(m, m.plugMarkerSE[n], a.orient, t.bBox, m.svg, m.plugMarkerShapeSE[n], m.plugsFace), E = !0, oe && je(m, m.plugsFace)), Xe(m, _.plug_colorSE, n, S = g.plug_colorSE[n], v.apl_plug_colorSE) && (m.plugFaceSE[n].style.fill = S, E = !0, (le || re || ie) && !g.line_colorTra && je(m, ie ? m.lineMaskCaps : m.capsMaskLine)), [\"markerWidth\", \"markerHeight\"].forEach(function (e) {\n        var t = \"plug_\" + e + \"SE\";\n        Xe(m, _[t], n, S = g[t][n], v[\"apl_\" + t]) && (m.plugMarkerSE[n][e].baseVal.value = S, E = !0);\n      }), Xe(m, _.plugOutline_enabledSE, n, S = g.plugOutline_enabledSE[n], v.apl_plugOutline_enabledSE) && (S ? (m.plugFaceSE[n].style.mask = \"url(#\" + m.plugMaskIdSE[n] + \")\", m.plugOutlineFaceSE[n].style.display = \"inline\") : (m.plugFaceSE[n].style.mask = \"none\", m.plugOutlineFaceSE[n].style.display = \"none\"), E = !0), g.plugOutline_enabledSE[n] && (Xe(m, _.plugOutline_plugSE, n, e, v.apl_plugOutline_plugSE) && (m.plugOutlineFaceSE[n].href.baseVal = m.plugMaskShapeSE[n].href.baseVal = m.plugOutlineMaskShapeSE[n].href.baseVal = \"#\" + t.elmId, [m.plugMaskSE[n], m.plugOutlineMaskSE[n]].forEach(function (e) {\n        e.x.baseVal.value = t.bBox.left, e.y.baseVal.value = t.bBox.top, e.width.baseVal.value = t.bBox.width, e.height.baseVal.value = t.bBox.height;\n      }), E = !0), Xe(m, _.plugOutline_colorSE, n, S = g.plugOutline_colorSE[n], v.apl_plugOutline_colorSE) && (m.plugOutlineFaceSE[n].style.fill = S, E = !0, ie && (je(m, m.lineMaskCaps), je(m, m.lineOutlineMaskCaps))), Xe(m, _.plugOutline_strokeWidthSE, n, S = g.plugOutline_strokeWidthSE[n], v.apl_plugOutline_strokeWidthSE) && (m.plugOutlineMaskShapeSE[n].style.strokeWidth = S + \"px\", E = !0), Xe(m, _.plugOutline_inStrokeWidthSE, n, S = g.plugOutline_inStrokeWidthSE[n], v.apl_plugOutline_inStrokeWidthSE) && (m.plugMaskShapeSE[n].style.strokeWidth = S + \"px\", E = !0)));\n    }), E)), (t.position || U.line || U.plug) && (U.position = Ke(e)), (t.path || U.position) && (U.path = (k = (x = e).curStats, I = x.aplStats, M = x.pathList.animVal || x.pathList.baseVal, w = k.path_edge, C = !1, M && (w.x1 = w.x2 = M[0][0].x, w.y1 = w.y2 = M[0][0].y, k.path_pathData = b = Be(M, function (e) {\n      e.x < w.x1 && (w.x1 = e.x), e.y < w.y1 && (w.y1 = e.y), e.x > w.x2 && (w.x2 = e.x), e.y > w.y2 && (w.y2 = e.y);\n    }), Fe(b, I.path_pathData) && (x.linePath.setPathData(b), I.path_pathData = b, C = !0, ie ? (je(x, x.plugsFace), je(x, x.lineMaskCaps)) : oe && je(x, x.linePath), x.events.apl_path && x.events.apl_path.forEach(function (e) {\n      e(x, b);\n    }))), C)), U.viewBox = (M = (O = e).curStats, I = O.aplStats, C = M.path_edge, L = M.viewBox_bBox, A = I.viewBox_bBox, V = O.svg.viewBox.baseVal, P = O.svg.style, N = !1, I = Math.max(M.line_strokeWidth / 2, M.viewBox_plugBCircleSE[0] || 0, M.viewBox_plugBCircleSE[1] || 0), T = {\n      x1: C.x1 - I,\n      y1: C.y1 - I,\n      x2: C.x2 + I,\n      y2: C.y2 + I\n    }, O.events.new_edge4viewBox && O.events.new_edge4viewBox.forEach(function (e) {\n      e(O, T);\n    }), L.x = M.lineMask_x = M.lineOutlineMask_x = M.maskBGRect_x = T.x1, L.y = M.lineMask_y = M.lineOutlineMask_y = M.maskBGRect_y = T.y1, L.width = T.x2 - T.x1, L.height = T.y2 - T.y1, [\"x\", \"y\", \"width\", \"height\"].forEach(function (e) {\n      var t;\n      (t = L[e]) !== A[e] && (V[e] = A[e] = t, P[Q[e]] = t + (\"x\" === e || \"y\" === e ? O.bodyOffset[e] : 0) + \"px\", N = !0);\n    }), N), U.mask = (R = (W = e).curStats, F = W.aplStats, G = !1, R.plug_enabled ? [0, 1].forEach(function (e) {\n      R.capsMaskMarker_enabledSE[e] = R.plug_enabledSE[e] && R.plug_colorTraSE[e] || R.plugOutline_enabledSE[e] && R.plugOutline_colorTraSE[e];\n    }) : R.capsMaskMarker_enabledSE[0] = R.capsMaskMarker_enabledSE[1] = !1, R.capsMaskMarker_enabled = R.capsMaskMarker_enabledSE[0] || R.capsMaskMarker_enabledSE[1], R.lineMask_outlineMode = R.lineOutline_enabled, R.caps_enabled = R.capsMaskMarker_enabled || R.capsMaskAnchor_enabledSE[0] || R.capsMaskAnchor_enabledSE[1], R.lineMask_enabled = R.caps_enabled || R.lineMask_outlineMode, (R.lineMask_enabled && !R.lineMask_outlineMode || R.lineOutline_enabled) && [\"x\", \"y\"].forEach(function (e) {\n      var t = \"maskBGRect_\" + e;\n      Xe(W, F, t, B = R[t]) && (W.maskBGRect[e].baseVal.value = B, G = !0);\n    }), Xe(W, F, \"lineMask_enabled\", B = R.lineMask_enabled) && (W.lineFace.style.mask = B ? \"url(#\" + W.lineMaskId + \")\" : \"none\", G = !0, re && je(W, W.lineMask)), R.lineMask_enabled && (Xe(W, F, \"lineMask_outlineMode\", B = R.lineMask_outlineMode) && (B ? (W.lineMaskBG.style.display = \"none\", W.lineMaskShape.style.display = \"inline\") : (W.lineMaskBG.style.display = \"inline\", W.lineMaskShape.style.display = \"none\"), G = !0), [\"x\", \"y\"].forEach(function (e) {\n      var t = \"lineMask_\" + e;\n      Xe(W, F, t, B = R[t]) && (W.lineMask[e].baseVal.value = B, G = !0);\n    }), Xe(W, F, \"caps_enabled\", B = R.caps_enabled) && (W.lineMaskCaps.style.display = W.lineOutlineMaskCaps.style.display = B ? \"inline\" : \"none\", G = !0, re && je(W, W.capsMaskLine)), R.caps_enabled && ([0, 1].forEach(function (e) {\n      var t;\n      Xe(W, F.capsMaskAnchor_enabledSE, e, B = R.capsMaskAnchor_enabledSE[e]) && (W.capsMaskAnchorSE[e].style.display = B ? \"inline\" : \"none\", G = !0, re && je(W, W.lineMask)), R.capsMaskAnchor_enabledSE[e] && (Fe(t = R.capsMaskAnchor_pathDataSE[e], F.capsMaskAnchor_pathDataSE[e]) && (W.capsMaskAnchorSE[e].setPathData(t), F.capsMaskAnchor_pathDataSE[e] = t, G = !0), Xe(W, F.capsMaskAnchor_strokeWidthSE, e, B = R.capsMaskAnchor_strokeWidthSE[e]) && (W.capsMaskAnchorSE[e].style.strokeWidth = B + \"px\", G = !0));\n    }), Xe(W, F, \"capsMaskMarker_enabled\", B = R.capsMaskMarker_enabled) && (W.capsMaskLine.style.display = B ? \"inline\" : \"none\", G = !0), R.capsMaskMarker_enabled && [0, 1].forEach(function (n) {\n      var e = R.capsMaskMarker_plugSE[n],\n        t = e !== Y ? X[q[e]] : null,\n        a = Ze(n, t);\n      Xe(W, F.capsMaskMarker_enabledSE, n, B = R.capsMaskMarker_enabledSE[n]) && (W.capsMaskLine.style[a.prop] = B ? \"url(#\" + W.lineMaskMarkerIdSE[n] + \")\" : \"none\", G = !0), R.capsMaskMarker_enabledSE[n] && (Xe(W, F.capsMaskMarker_plugSE, n, e) && (W.capsMaskMarkerShapeSE[n].href.baseVal = \"#\" + t.elmId, Ue(W, W.capsMaskMarkerSE[n], a.orient, t.bBox, W.svg, W.capsMaskMarkerShapeSE[n], W.capsMaskLine), G = !0, oe && (je(W, W.capsMaskLine), je(W, W.lineFace))), [\"markerWidth\", \"markerHeight\"].forEach(function (e) {\n        var t = \"capsMaskMarker_\" + e + \"SE\";\n        Xe(W, F[t], n, B = R[t][n]) && (W.capsMaskMarkerSE[n][e].baseVal.value = B, G = !0);\n      }));\n    }))), R.lineOutline_enabled && [\"x\", \"y\"].forEach(function (e) {\n      var t = \"lineOutlineMask_\" + e;\n      Xe(W, F, t, B = R[t]) && (W.lineOutlineMask[e].baseVal.value = B, G = !0);\n    }), G), t.effect && (j = (D = e).curStats, H = D.aplStats, Object.keys(Z).forEach(function (e) {\n      var t = Z[e],\n        n = e + \"_enabled\",\n        a = e + \"_options\",\n        e = j[a];\n      Xe(D, H, n, z = j[n]) ? (z && (H[a] = we(e)), t[z ? \"init\" : \"remove\"](D)) : z && ke(e, H[a]) && (t.remove(D), H[n] = !0, H[a] = we(e), t.init(D));\n    })), (le || re) && U.line && !U.path && je(e, e.lineShape), le && U.plug && !U.line && je(e, e.plugsFace), He(e);\n  }\n  function et(e, t) {\n    return {\n      duration: (pe(e.duration) && 0 < e.duration ? e : t).duration,\n      timing: g.validTiming(e.timing) ? e.timing : we(t.timing)\n    };\n  }\n  function tt(e, t, n, a) {\n    var i = e.curStats,\n      o = e.aplStats,\n      l = {};\n    function r() {\n      [\"show_on\", \"show_effect\", \"show_animOptions\"].forEach(function (e) {\n        o[e] = i[e];\n      });\n    }\n    i.show_on = t, n && w[n] && (i.show_effect = n, i.show_animOptions = et(he(a) ? a : {}, w[n].defaultAnimOptions)), l.show_on = i.show_on !== o.show_on, l.show_effect = i.show_effect !== o.show_effect, l.show_animOptions = ke(i.show_animOptions, o.show_animOptions), l.show_effect || l.show_animOptions ? i.show_inAnim ? (n = l.show_effect ? w[o.show_effect].stop(e, !0, !0) : w[o.show_effect].stop(e), r(), w[o.show_effect].init(e, n)) : l.show_on && (o.show_effect && l.show_effect && w[o.show_effect].stop(e, !0, !0), r(), w[o.show_effect].init(e)) : l.show_on && (r(), w[o.show_effect].start(e));\n  }\n  function nt(e, t, n) {\n    n = {\n      props: e,\n      optionName: n\n    };\n    return e.attachments.indexOf(t) < 0 && (!t.conf.bind || t.conf.bind(t, n)) && (e.attachments.push(t), t.boundTargets.push(n), 1);\n  }\n  function at(n, a, e) {\n    var i = n.attachments.indexOf(a);\n    -1 < i && n.attachments.splice(i, 1), a.boundTargets.some(function (e, t) {\n      return e.props === n && (a.conf.unbind && a.conf.unbind(a, e), i = t, !0);\n    }) && (a.boundTargets.splice(i, 1), e || ze(function () {\n      a.boundTargets.length || o(a);\n    }));\n  }\n  function it(s, u) {\n    var i,\n      n,\n      e,\n      t,\n      a,\n      o,\n      l,\n      r,\n      h,\n      p,\n      c,\n      d,\n      f,\n      y,\n      m,\n      S = s.options,\n      g = {};\n    function _(e, t, n, a, i) {\n      var o = {};\n      return n ? null != a ? (o.container = e[n], o.key = a) : (o.container = e, o.key = n) : (o.container = e, o.key = t), o.default = i, o.acceptsAuto = null == o.default, o;\n    }\n    function v(e, t, n, a, i, o, l) {\n      var r,\n        s,\n        u,\n        l = _(e, n, i, o, l);\n      return null != t[n] && (s = (t[n] + \"\").toLowerCase()) && (l.acceptsAuto && s === D || (u = a[s])) && u !== l.container[l.key] && (l.container[l.key] = u, r = !0), null != l.container[l.key] || l.acceptsAuto || (l.container[l.key] = l.default, r = !0), r;\n    }\n    function E(e, t, n, a, i, o, l, r, s) {\n      var u,\n        h,\n        p,\n        c,\n        l = _(e, n, i, o, l);\n      if (!a) {\n        if (null == l.default) throw new Error(\"Invalid `type`: \" + n);\n        a = typeof l.default;\n      }\n      return null != t[n] && (l.acceptsAuto && (t[n] + \"\").toLowerCase() === D || (p = h = t[n], (\"number\" === (c = a) ? pe(p) : typeof p === c) && (h = s && \"string\" === a && h ? h.trim() : h, 1) && (!r || r(h)))) && h !== l.container[l.key] && (l.container[l.key] = h, u = !0), null != l.container[l.key] || l.acceptsAuto || (l.container[l.key] = l.default, u = !0), u;\n    }\n    if (u = u || {}, [\"start\", \"end\"].forEach(function (e, t) {\n      var n = u[e],\n        a = !1;\n      if (n && (Me(n) || (a = I(n, \"anchor\"))) && n !== S.anchorSE[t]) {\n        if (!1 !== s.optionIsAttach.anchorSE[t] && at(s, _e[S.anchorSE[t]._id]), a && !nt(s, _e[n._id], e)) throw new Error(\"Can't bind attachment\");\n        S.anchorSE[t] = n, s.optionIsAttach.anchorSE[t] = a, i = g.position = !0;\n      }\n    }), !S.anchorSE[0] || !S.anchorSE[1] || S.anchorSE[0] === S.anchorSE[1]) throw new Error(\"`start` and `end` are required.\");\n    function x(e) {\n      var t = a.appendChild(y.createElementNS(ae, \"mask\"));\n      return t.id = e, t.maskUnits.baseVal = SVGUnitTypes.SVG_UNIT_TYPE_USERSPACEONUSE, [t.x, t.y, t.width, t.height].forEach(function (e) {\n        e.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, 0);\n      }), t;\n    }\n    function b(e) {\n      var t = a.appendChild(y.createElementNS(ae, \"marker\"));\n      return t.id = e, t.markerUnits.baseVal = SVGMarkerElement.SVG_MARKERUNITS_STROKEWIDTH, t.viewBox.baseVal || t.setAttribute(\"viewBox\", \"0 0 0 0\"), t;\n    }\n    function k(e) {\n      return [e.width, e.height].forEach(function (e) {\n        e.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE, 100);\n      }), e;\n    }\n    i && (c = function (e, t) {\n      var n, a;\n      if (!(e = Ce(e)) || !(n = Ce(t))) throw new Error(\"Cannot get frames.\");\n      return e.length && n.length && (e.reverse(), n.reverse(), e.some(function (t) {\n        return n.some(function (e) {\n          return e === t && (a = e.contentWindow, !0);\n        });\n      })), a || window;\n    }(!1 !== s.optionIsAttach.anchorSE[0] ? _e[S.anchorSE[0]._id].element : S.anchorSE[0], !1 !== s.optionIsAttach.anchorSE[1] ? _e[S.anchorSE[1]._id].element : S.anchorSE[1])) !== s.baseWindow && (e = c, f = (n = s).aplStats, y = e.document, m = C + \"-\" + n._id, n.pathList = {}, Ye(f, de), Object.keys(Z).forEach(function (e) {\n      var t = e + \"_enabled\";\n      f[t] && (Z[e].remove(n), f[t] = !1);\n    }), n.baseWindow && n.svg && n.baseWindow.document.body.removeChild(n.svg), Qe(n.baseWindow = e), n.bodyOffset = qe(e), n.svg = t = y.createElementNS(ae, \"svg\"), t.className.baseVal = C, t.viewBox.baseVal || t.setAttribute(\"viewBox\", \"0 0 0 0\"), n.defs = a = t.appendChild(y.createElementNS(ae, \"defs\")), n.linePath = l = a.appendChild(y.createElementNS(ae, \"path\")), l.id = r = m + \"-line-path\", l.className.baseVal = C + \"-line-path\", re && (l.style.fill = \"none\"), n.lineShape = l = a.appendChild(y.createElementNS(ae, \"use\")), l.id = h = m + \"-line-shape\", l.href.baseVal = \"#\" + r, (o = a.appendChild(y.createElementNS(ae, \"g\"))).id = p = m + \"-caps\", n.capsMaskAnchorSE = [0, 1].map(function () {\n      var e = o.appendChild(y.createElementNS(ae, \"path\"));\n      return e.className.baseVal = C + \"-caps-mask-anchor\", e;\n    }), n.lineMaskMarkerIdSE = [m + \"-caps-mask-marker-0\", m + \"-caps-mask-marker-1\"], n.capsMaskMarkerSE = [0, 1].map(function (e) {\n      return b(n.lineMaskMarkerIdSE[e]);\n    }), n.capsMaskMarkerShapeSE = [0, 1].map(function (e) {\n      e = n.capsMaskMarkerSE[e].appendChild(y.createElementNS(ae, \"use\"));\n      return e.className.baseVal = C + \"-caps-mask-marker-shape\", e;\n    }), n.capsMaskLine = l = o.appendChild(y.createElementNS(ae, \"use\")), l.className.baseVal = C + \"-caps-mask-line\", l.href.baseVal = \"#\" + h, n.maskBGRect = l = k(a.appendChild(y.createElementNS(ae, \"rect\"))), l.id = c = m + \"-mask-bg-rect\", l.className.baseVal = C + \"-mask-bg-rect\", re && (l.style.fill = \"white\"), n.lineMask = k(x(n.lineMaskId = m + \"-line-mask\")), n.lineMaskBG = l = n.lineMask.appendChild(y.createElementNS(ae, \"use\")), l.href.baseVal = \"#\" + c, n.lineMaskShape = l = n.lineMask.appendChild(y.createElementNS(ae, \"use\")), l.className.baseVal = C + \"-line-mask-shape\", l.href.baseVal = \"#\" + r, l.style.display = \"none\", n.lineMaskCaps = l = n.lineMask.appendChild(y.createElementNS(ae, \"use\")), l.href.baseVal = \"#\" + p, n.lineOutlineMask = k(x(e = m + \"-line-outline-mask\")), (l = n.lineOutlineMask.appendChild(y.createElementNS(ae, \"use\"))).href.baseVal = \"#\" + c, n.lineOutlineMaskShape = l = n.lineOutlineMask.appendChild(y.createElementNS(ae, \"use\")), l.className.baseVal = C + \"-line-outline-mask-shape\", l.href.baseVal = \"#\" + r, n.lineOutlineMaskCaps = l = n.lineOutlineMask.appendChild(y.createElementNS(ae, \"use\")), l.href.baseVal = \"#\" + p, n.face = t.appendChild(y.createElementNS(ae, \"g\")), n.lineFace = l = n.face.appendChild(y.createElementNS(ae, \"use\")), l.href.baseVal = \"#\" + h, n.lineOutlineFace = l = n.face.appendChild(y.createElementNS(ae, \"use\")), l.href.baseVal = \"#\" + h, l.style.mask = \"url(#\" + e + \")\", l.style.display = \"none\", n.plugMaskIdSE = [m + \"-plug-mask-0\", m + \"-plug-mask-1\"], n.plugMaskSE = [0, 1].map(function (e) {\n      return x(n.plugMaskIdSE[e]);\n    }), n.plugMaskShapeSE = [0, 1].map(function (e) {\n      e = n.plugMaskSE[e].appendChild(y.createElementNS(ae, \"use\"));\n      return e.className.baseVal = C + \"-plug-mask-shape\", e;\n    }), d = [], n.plugOutlineMaskSE = [0, 1].map(function (e) {\n      return x(d[e] = m + \"-plug-outline-mask-\" + e);\n    }), n.plugOutlineMaskShapeSE = [0, 1].map(function (e) {\n      e = n.plugOutlineMaskSE[e].appendChild(y.createElementNS(ae, \"use\"));\n      return e.className.baseVal = C + \"-plug-outline-mask-shape\", e;\n    }), n.plugMarkerIdSE = [m + \"-plug-marker-0\", m + \"-plug-marker-1\"], n.plugMarkerSE = [0, 1].map(function (e) {\n      e = b(n.plugMarkerIdSE[e]);\n      return re && (e.markerUnits.baseVal = SVGMarkerElement.SVG_MARKERUNITS_USERSPACEONUSE), e;\n    }), n.plugMarkerShapeSE = [0, 1].map(function (e) {\n      return n.plugMarkerSE[e].appendChild(y.createElementNS(ae, \"g\"));\n    }), n.plugFaceSE = [0, 1].map(function (e) {\n      return n.plugMarkerShapeSE[e].appendChild(y.createElementNS(ae, \"use\"));\n    }), n.plugOutlineFaceSE = [0, 1].map(function (e) {\n      var t = n.plugMarkerShapeSE[e].appendChild(y.createElementNS(ae, \"use\"));\n      return t.style.mask = \"url(#\" + d[e] + \")\", t.style.display = \"none\", t;\n    }), n.plugsFace = l = n.face.appendChild(y.createElementNS(ae, \"use\")), l.className.baseVal = C + \"-plugs-face\", l.href.baseVal = \"#\" + h, l.style.display = \"none\", n.curStats.show_inAnim ? (n.isShown = 1, w[f.show_effect].stop(n, !0)) : n.isShown || (t.style.visibility = \"hidden\"), y.body.appendChild(t), [0, 1, 2].forEach(function (e) {\n      var t,\n        e = n.options.labelSEM[e];\n      e && I(e, \"label\") && (t = _e[e._id]).conf.initSvg && t.conf.initSvg(t, n);\n    }), g.line = g.plug = g.lineOutline = g.plugOutline = g.faces = g.effect = !0), g.position = v(S, u, \"path\", R, null, null, ue.path) || g.position, g.position = v(S, u, \"startSocket\", V, \"socketSE\", 0) || g.position, g.position = v(S, u, \"endSocket\", V, \"socketSE\", 1) || g.position, [u.startSocketGravity, u.endSocketGravity].forEach(function (e, t) {\n      var n,\n        a,\n        i = !1;\n      null != e && (Array.isArray(e) ? pe(e[0]) && pe(e[1]) && (i = [e[0], e[1]], Array.isArray(S.socketGravitySE[t]) && (n = i, a = S.socketGravitySE[t], n.length === a.length && n.every(function (e, t) {\n        return e === a[t];\n      })) && (i = !1)) : ((e + \"\").toLowerCase() === D ? i = null : pe(e) && 0 <= e && (i = e), i === S.socketGravitySE[t] && (i = !1)), !1 !== i && (S.socketGravitySE[t] = i, g.position = !0));\n    }), g.line = E(S, u, \"color\", null, \"lineColor\", null, ue.lineColor, null, !0) || g.line, g.line = E(S, u, \"size\", null, \"lineSize\", null, ue.lineSize, function (e) {\n      return 0 < e;\n    }) || g.line, [\"startPlug\", \"endPlug\"].forEach(function (e, t) {\n      g.plug = v(S, u, e, F, \"plugSE\", t, ue.plugSE[t]) || g.plug, g.plug = E(S, u, e + \"Color\", \"string\", \"plugColorSE\", t, null, null, !0) || g.plug, g.plug = E(S, u, e + \"Size\", null, \"plugSizeSE\", t, ue.plugSizeSE[t], function (e) {\n        return 0 < e;\n      }) || g.plug;\n    }), g.lineOutline = E(S, u, \"outline\", null, \"lineOutlineEnabled\", null, ue.lineOutlineEnabled) || g.lineOutline, g.lineOutline = E(S, u, \"outlineColor\", null, \"lineOutlineColor\", null, ue.lineOutlineColor, null, !0) || g.lineOutline, g.lineOutline = E(S, u, \"outlineSize\", null, \"lineOutlineSize\", null, ue.lineOutlineSize, function (e) {\n      return 0 < e && e <= .48;\n    }) || g.lineOutline, [\"startPlugOutline\", \"endPlugOutline\"].forEach(function (e, t) {\n      g.plugOutline = E(S, u, e, null, \"plugOutlineEnabledSE\", t, ue.plugOutlineEnabledSE[t]) || g.plugOutline, g.plugOutline = E(S, u, e + \"Color\", \"string\", \"plugOutlineColorSE\", t, null, null, !0) || g.plugOutline, g.plugOutline = E(S, u, e + \"Size\", null, \"plugOutlineSizeSE\", t, ue.plugOutlineSizeSE[t], function (e) {\n        return 1 <= e;\n      }) || g.plugOutline;\n    }), [\"startLabel\", \"endLabel\", \"middleLabel\"].forEach(function (e, t) {\n      var n,\n        a,\n        i,\n        o = u[e],\n        l = S.labelSEM[t] && !s.optionIsAttach.labelSEM[t] ? _e[S.labelSEM[t]._id].text : S.labelSEM[t],\n        r = !1;\n      if ((n = \"string\" == typeof o) && (o = o.trim()), (n || o && (r = I(o, \"label\"))) && o !== l) {\n        if (S.labelSEM[t] && (at(s, _e[S.labelSEM[t]._id]), S.labelSEM[t] = \"\"), o) {\n          if (r ? (a = _e[(i = o)._id]).boundTargets.slice().forEach(function (e) {\n            a.conf.removeOption(a, e);\n          }) : i = new M(O.captionLabel, [o]), !nt(s, _e[i._id], e)) throw new Error(\"Can't bind attachment\");\n          S.labelSEM[t] = i;\n        }\n        s.optionIsAttach.labelSEM[t] = r;\n      }\n    }), Object.keys(Z).forEach(function (a) {\n      var e,\n        t,\n        o = Z[a],\n        n = a + \"_enabled\",\n        i = a + \"_options\";\n      function l(a) {\n        var i = {};\n        return o.optionsConf.forEach(function (e) {\n          var t = e[0],\n            n = e[3];\n          null == e[4] || i[n] || (i[n] = []), (\"function\" == typeof t ? t : \"id\" === t ? v : E).apply(null, [i, a].concat(e.slice(1)));\n        }), i;\n      }\n      function r(e) {\n        var t,\n          n = a + \"_animOptions\";\n        return e.hasOwnProperty(\"animation\") ? he(e.animation) ? t = s.curStats[n] = et(e.animation, o.defaultAnimOptions) : (t = !!e.animation, s.curStats[n] = t ? et({}, o.defaultAnimOptions) : null) : (t = !!o.defaultEnabled, s.curStats[n] = t ? et({}, o.defaultAnimOptions) : null), t;\n      }\n      u.hasOwnProperty(a) && (e = u[a], he(e) ? (s.curStats[n] = !0, t = s.curStats[i] = l(e), o.anim && (s.curStats[i].animation = r(e))) : (t = s.curStats[n] = !!e) && (s.curStats[i] = l({}), o.anim && (s.curStats[i].animation = r({}))), ke(t, S[a]) && (S[a] = t, g.effect = !0));\n    }), $e(s, g);\n  }\n  function ot(e, t, n) {\n    var a = {\n      options: {\n        anchorSE: [],\n        socketSE: [],\n        socketGravitySE: [],\n        plugSE: [],\n        plugColorSE: [],\n        plugSizeSE: [],\n        plugOutlineEnabledSE: [],\n        plugOutlineColorSE: [],\n        plugOutlineSizeSE: [],\n        labelSEM: [\"\", \"\", \"\"]\n      },\n      optionIsAttach: {\n        anchorSE: [!1, !1],\n        labelSEM: [!1, !1, !1]\n      },\n      curStats: {},\n      aplStats: {},\n      attachments: [],\n      events: {},\n      reflowTargets: []\n    };\n    Ye(a.curStats, de), Ye(a.aplStats, de), Object.keys(Z).forEach(function (e) {\n      var t = Z[e].stats;\n      Ye(a.curStats, t), Ye(a.aplStats, t), a.options[e] = !1;\n    }), Ye(a.curStats, fe), Ye(a.aplStats, fe), a.curStats.show_effect = ye, a.curStats.show_animOptions = we(w[ye].defaultAnimOptions), Object.defineProperty(this, \"_id\", {\n      value: ++ge\n    }), a._id = this._id, Se[this._id] = a, 1 === arguments.length && (n = e, e = null), n = n || {}, (e || t) && (n = we(n), e && (n.start = e), t && (n.end = t)), a.isShown = a.aplStats.show_on = !n.hide, this.setOptions(n);\n  }\n  function lt(n) {\n    return function (e) {\n      var t = {};\n      t[n] = e, this.setOptions(t);\n    };\n  }\n  function rt(e, t) {\n    var n,\n      a = {\n        conf: e,\n        curStats: {},\n        aplStats: {},\n        boundTargets: []\n      },\n      i = {};\n    e.argOptions.every(function (e) {\n      return !(!t.length || (\"string\" == typeof e.type ? typeof t[0] !== e.type : \"function\" != typeof e.type || !e.type(t[0]))) && (i[e.optionName] = t.shift(), !0);\n    }), n = t.length && he(t[0]) ? we(t[0]) : {}, Object.keys(i).forEach(function (e) {\n      n[e] = i[e];\n    }), e.stats && (Ye(a.curStats, e.stats), Ye(a.aplStats, e.stats)), Object.defineProperty(this, \"_id\", {\n      value: ++ve\n    }), Object.defineProperty(this, \"isRemoved\", {\n      get: function get() {\n        return !_e[this._id];\n      }\n    }), a._id = this._id, e.init && !e.init(a, n) || (_e[this._id] = a);\n  }\n  return Z = {\n    dash: {\n      stats: {\n        dash_len: {},\n        dash_gap: {},\n        dash_maxOffset: {}\n      },\n      anim: !0,\n      defaultAnimOptions: {\n        duration: 1e3,\n        timing: \"linear\"\n      },\n      optionsConf: [[\"type\", \"len\", \"number\", null, null, null, function (e) {\n        return 0 < e;\n      }], [\"type\", \"gap\", \"number\", null, null, null, function (e) {\n        return 0 < e;\n      }]],\n      init: function init(e) {\n        Ge(e, \"apl_line_strokeWidth\", Z.dash.update), e.lineFace.style.strokeDashoffset = 0, Z.dash.update(e);\n      },\n      remove: function remove(e) {\n        var t = e.curStats;\n        De(e, \"apl_line_strokeWidth\", Z.dash.update), t.dash_animId && (g.remove(t.dash_animId), t.dash_animId = null), e.lineFace.style.strokeDasharray = \"none\", e.lineFace.style.strokeDashoffset = 0, Ye(e.aplStats, Z.dash.stats);\n      },\n      update: function update(t) {\n        var e,\n          n = t.curStats,\n          a = t.aplStats,\n          i = a.dash_options,\n          o = !1;\n        n.dash_len = i.len || 2 * a.line_strokeWidth, n.dash_gap = i.gap || a.line_strokeWidth, n.dash_maxOffset = n.dash_len + n.dash_gap, o = Xe(t, a, \"dash_len\", n.dash_len) || o, (o = Xe(t, a, \"dash_gap\", n.dash_gap) || o) && (t.lineFace.style.strokeDasharray = a.dash_len + \",\" + a.dash_gap), n.dash_animOptions ? (o = Xe(t, a, \"dash_maxOffset\", n.dash_maxOffset), a.dash_animOptions && (o || ke(n.dash_animOptions, a.dash_animOptions)) && (n.dash_animId && (e = g.stop(n.dash_animId), g.remove(n.dash_animId)), a.dash_animOptions = null), a.dash_animOptions || (n.dash_animId = g.add(function (e) {\n          return (1 - e) * a.dash_maxOffset + \"px\";\n        }, function (e) {\n          t.lineFace.style.strokeDashoffset = e;\n        }, n.dash_animOptions.duration, 0, n.dash_animOptions.timing, !1, e), a.dash_animOptions = we(n.dash_animOptions))) : a.dash_animOptions && (n.dash_animId && (g.remove(n.dash_animId), n.dash_animId = null), t.lineFace.style.strokeDashoffset = 0, a.dash_animOptions = null);\n      }\n    },\n    gradient: {\n      stats: {\n        gradient_colorSE: {\n          hasSE: !0\n        },\n        gradient_pointSE: {\n          hasSE: !0,\n          hasProps: !0\n        }\n      },\n      optionsConf: [[\"type\", \"startColor\", \"string\", \"colorSE\", 0, null, null, !0], [\"type\", \"endColor\", \"string\", \"colorSE\", 1, null, null, !0]],\n      init: function init(e) {\n        var a = e.baseWindow.document,\n          t = e.defs,\n          n = C + \"-\" + e._id + \"-gradient\";\n        e.efc_gradient_gradient = t = t.appendChild(a.createElementNS(ae, \"linearGradient\")), t.id = n, t.gradientUnits.baseVal = SVGUnitTypes.SVG_UNIT_TYPE_USERSPACEONUSE, [t.x1, t.y1, t.x2, t.y2].forEach(function (e) {\n          e.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, 0);\n        }), e.efc_gradient_stopSE = [0, 1].map(function (t) {\n          var n = e.efc_gradient_gradient.appendChild(a.createElementNS(ae, \"stop\"));\n          try {\n            n.offset.baseVal = t;\n          } catch (e) {\n            if (e.code !== DOMException.NO_MODIFICATION_ALLOWED_ERR) throw e;\n            n.setAttribute(\"offset\", t);\n          }\n          return n;\n        }), Ge(e, \"cur_plug_colorSE\", Z.gradient.update), Ge(e, \"apl_path\", Z.gradient.update), e.curStats.line_altColor = !0, e.lineFace.style.stroke = \"url(#\" + n + \")\", Z.gradient.update(e);\n      },\n      remove: function remove(e) {\n        e.efc_gradient_gradient && (e.defs.removeChild(e.efc_gradient_gradient), e.efc_gradient_gradient = e.efc_gradient_stopSE = null), De(e, \"cur_plug_colorSE\", Z.gradient.update), De(e, \"apl_path\", Z.gradient.update), e.curStats.line_altColor = !1, e.lineFace.style.stroke = e.curStats.line_color, Ye(e.aplStats, Z.gradient.stats);\n      },\n      update: function update(a) {\n        var e,\n          i = a.curStats,\n          o = a.aplStats,\n          t = o.gradient_options,\n          n = a.pathList.animVal || a.pathList.baseVal;\n        [0, 1].forEach(function (e) {\n          i.gradient_colorSE[e] = t.colorSE[e] || i.plug_colorSE[e];\n        }), e = n[0][0], i.gradient_pointSE[0] = {\n          x: e.x,\n          y: e.y\n        }, e = (n = n[n.length - 1])[n.length - 1], i.gradient_pointSE[1] = {\n          x: e.x,\n          y: e.y\n        }, [0, 1].forEach(function (t) {\n          var n;\n          Xe(a, o.gradient_colorSE, t, n = i.gradient_colorSE[t]) && (re ? (n = Oe(n), a.efc_gradient_stopSE[t].style.stopColor = n[1], a.efc_gradient_stopSE[t].style.stopOpacity = n[0]) : a.efc_gradient_stopSE[t].style.stopColor = n), [\"x\", \"y\"].forEach(function (e) {\n            (n = i.gradient_pointSE[t][e]) !== o.gradient_pointSE[t][e] && (a.efc_gradient_gradient[e + (t + 1)].baseVal.value = o.gradient_pointSE[t][e] = n);\n          });\n        });\n      }\n    },\n    dropShadow: {\n      stats: {\n        dropShadow_dx: {},\n        dropShadow_dy: {},\n        dropShadow_blur: {},\n        dropShadow_color: {},\n        dropShadow_opacity: {},\n        dropShadow_x: {},\n        dropShadow_y: {}\n      },\n      optionsConf: [[\"type\", \"dx\", null, null, null, 2], [\"type\", \"dy\", null, null, null, 4], [\"type\", \"blur\", null, null, null, 3, function (e) {\n        return 0 <= e;\n      }], [\"type\", \"color\", null, null, null, \"#000\", null, !0], [\"type\", \"opacity\", null, null, null, .8, function (e) {\n        return 0 <= e && e <= 1;\n      }]],\n      init: function init(t) {\n        var e,\n          n,\n          a,\n          i,\n          o = t.baseWindow.document,\n          l = t.defs,\n          r = C + \"-\" + t._id + \"-dropShadow\",\n          s = (e = o, n = r, i = {}, \"boolean\" != typeof u && (u = !!window.SVGFEDropShadowElement && !re), i.elmsAppend = [i.elmFilter = o = e.createElementNS(ae, \"filter\")], o.filterUnits.baseVal = SVGUnitTypes.SVG_UNIT_TYPE_USERSPACEONUSE, o.x.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, 0), o.y.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, 0), o.width.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE, 100), o.height.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE, 100), o.id = n, u ? (i.elmOffset = i.elmBlur = a = o.appendChild(e.createElementNS(ae, \"feDropShadow\")), i.styleFlood = a.style) : (i.elmBlur = o.appendChild(e.createElementNS(ae, \"feGaussianBlur\")), i.elmOffset = a = o.appendChild(e.createElementNS(ae, \"feOffset\")), a.result.baseVal = \"offsetblur\", a = o.appendChild(e.createElementNS(ae, \"feFlood\")), i.styleFlood = a.style, (a = o.appendChild(e.createElementNS(ae, \"feComposite\"))).in2.baseVal = \"offsetblur\", a.operator.baseVal = SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_IN, (a = o.appendChild(e.createElementNS(ae, \"feMerge\"))).appendChild(e.createElementNS(ae, \"feMergeNode\")), a.appendChild(e.createElementNS(ae, \"feMergeNode\")).in1.baseVal = \"SourceGraphic\"), i);\n        [\"elmFilter\", \"elmOffset\", \"elmBlur\", \"styleFlood\", \"elmsAppend\"].forEach(function (e) {\n          t[\"efc_dropShadow_\" + e] = s[e];\n        }), s.elmsAppend.forEach(function (e) {\n          l.appendChild(e);\n        }), t.face.setAttribute(\"filter\", \"url(#\" + r + \")\"), Ge(t, \"new_edge4viewBox\", Z.dropShadow.adjustEdge), Z.dropShadow.update(t);\n      },\n      remove: function remove(e) {\n        var t = e.defs;\n        e.efc_dropShadow_elmsAppend && (e.efc_dropShadow_elmsAppend.forEach(function (e) {\n          t.removeChild(e);\n        }), e.efc_dropShadow_elmFilter = e.efc_dropShadow_elmOffset = e.efc_dropShadow_elmBlur = e.efc_dropShadow_styleFlood = e.efc_dropShadow_elmsAppend = null), De(e, \"new_edge4viewBox\", Z.dropShadow.adjustEdge), $e(e, {}), e.face.removeAttribute(\"filter\"), Ye(e.aplStats, Z.dropShadow.stats);\n      },\n      update: function update(e) {\n        var t,\n          n,\n          a = e.curStats,\n          i = e.aplStats,\n          o = i.dropShadow_options;\n        a.dropShadow_dx = t = o.dx, Xe(e, i, \"dropShadow_dx\", t) && (e.efc_dropShadow_elmOffset.dx.baseVal = t, n = !0), a.dropShadow_dy = t = o.dy, Xe(e, i, \"dropShadow_dy\", t) && (e.efc_dropShadow_elmOffset.dy.baseVal = t, n = !0), a.dropShadow_blur = t = o.blur, Xe(e, i, \"dropShadow_blur\", t) && (e.efc_dropShadow_elmBlur.setStdDeviation(t, t), n = !0), n && $e(e, {}), a.dropShadow_color = t = o.color, Xe(e, i, \"dropShadow_color\", t) && (e.efc_dropShadow_styleFlood.floodColor = t), a.dropShadow_opacity = t = o.opacity, Xe(e, i, \"dropShadow_opacity\", t) && (e.efc_dropShadow_styleFlood.floodOpacity = t);\n      },\n      adjustEdge: function adjustEdge(a, i) {\n        var e,\n          o = a.curStats,\n          l = a.aplStats;\n        null != o.dropShadow_dx && (e = 3 * o.dropShadow_blur, (e = {\n          x1: i.x1 - e + o.dropShadow_dx,\n          y1: i.y1 - e + o.dropShadow_dy,\n          x2: i.x2 + e + o.dropShadow_dx,\n          y2: i.y2 + e + o.dropShadow_dy\n        }).x1 < i.x1 && (i.x1 = e.x1), e.y1 < i.y1 && (i.y1 = e.y1), e.x2 > i.x2 && (i.x2 = e.x2), e.y2 > i.y2 && (i.y2 = e.y2), [\"x\", \"y\"].forEach(function (e) {\n          var t,\n            n = \"dropShadow_\" + e;\n          o[n] = t = i[e + \"1\"], Xe(a, l, n, t) && (a.efc_dropShadow_elmFilter[e].baseVal.value = t);\n        }));\n      }\n    }\n  }, Object.keys(Z).forEach(function (e) {\n    var t = Z[e],\n      n = t.stats;\n    n[e + \"_enabled\"] = {\n      iniValue: !1\n    }, n[e + \"_options\"] = {\n      hasProps: !0\n    }, t.anim && (n[e + \"_animOptions\"] = {}, n[e + \"_animId\"] = {});\n  }), w = {\n    none: {\n      defaultAnimOptions: {},\n      init: function init(e, t) {\n        var n = e.curStats;\n        n.show_animId && (g.remove(n.show_animId), n.show_animId = null), w.none.start(e, t);\n      },\n      start: function start(e, t) {\n        w.none.stop(e, !0);\n      },\n      stop: function stop(e, t, n) {\n        var a = e.curStats;\n        return n = null != n ? n : e.aplStats.show_on, a.show_inAnim = !1, t && Je(e, n), n ? 1 : 0;\n      }\n    },\n    fade: {\n      defaultAnimOptions: {\n        duration: 300,\n        timing: \"linear\"\n      },\n      init: function init(n, e) {\n        var t = n.curStats,\n          a = n.aplStats;\n        t.show_animId && g.remove(t.show_animId), t.show_animId = g.add(function (e) {\n          return e;\n        }, function (e, t) {\n          t ? w.fade.stop(n, !0) : (n.svg.style.opacity = e + \"\", ie && (je(n, n.svg), He(n)));\n        }, a.show_animOptions.duration, 1, a.show_animOptions.timing, null, !1), w.fade.start(n, e);\n      },\n      start: function start(e, t) {\n        var n,\n          a = e.curStats;\n        a.show_inAnim && (n = g.stop(a.show_animId)), Je(e, 1), a.show_inAnim = !0, g.start(a.show_animId, !e.aplStats.show_on, null != t ? t : n);\n      },\n      stop: function stop(e, t, n) {\n        var a,\n          i = e.curStats;\n        return n = null != n ? n : e.aplStats.show_on, a = i.show_inAnim ? g.stop(i.show_animId) : n ? 1 : 0, i.show_inAnim = !1, t && (e.svg.style.opacity = n ? \"\" : \"0\", Je(e, n)), a;\n      }\n    },\n    draw: {\n      defaultAnimOptions: {\n        duration: 500,\n        timing: [.58, 0, .42, 1]\n      },\n      init: function init(n, e) {\n        var t = n.curStats,\n          a = n.aplStats,\n          o = n.pathList.baseVal,\n          i = Re(o),\n          l = i.segsLen,\n          r = i.lenAll;\n        t.show_animId && g.remove(t.show_animId), t.show_animId = g.add(function (e) {\n          var t,\n            n,\n            a,\n            i = -1;\n          if (0 === e) n = [[o[0][0], o[0][0]]];else if (1 === e) n = o;else {\n            for (t = r * e, n = []; t >= l[++i];) n.push(o[i]), t -= l[i];\n            t && (2 === (a = o[i]).length ? n.push([a[0], Ve(a[0], a[1], t / l[i])]) : (e = Ne(a[0], a[1], a[2], a[3], We(a[0], a[1], a[2], a[3], t)), n.push([a[0], e.fromP1, e.fromP2, e])));\n          }\n          return n;\n        }, function (e, t) {\n          t ? w.draw.stop(n, !0) : (n.pathList.animVal = e, $e(n, {\n            path: !0\n          }));\n        }, a.show_animOptions.duration, 1, a.show_animOptions.timing, null, !1), w.draw.start(n, e);\n      },\n      start: function start(e, t) {\n        var n,\n          a = e.curStats;\n        a.show_inAnim && (n = g.stop(a.show_animId)), Je(e, 1), a.show_inAnim = !0, Ge(e, \"apl_position\", w.draw.update), g.start(a.show_animId, !e.aplStats.show_on, null != t ? t : n);\n      },\n      stop: function stop(e, t, n) {\n        var a,\n          i = e.curStats;\n        return n = null != n ? n : e.aplStats.show_on, a = i.show_inAnim ? g.stop(i.show_animId) : n ? 1 : 0, i.show_inAnim = !1, t && (e.pathList.animVal = n ? null : [[e.pathList.baseVal[0][0], e.pathList.baseVal[0][0]]], $e(e, {\n          path: !0\n        }), Je(e, n)), a;\n      },\n      update: function update(e) {\n        De(e, \"apl_position\", w.draw.update), e.curStats.show_inAnim ? w.draw.init(e, w.draw.stop(e)) : e.aplStats.show_animOptions = {};\n      }\n    }\n  }, [[\"start\", \"anchorSE\", 0], [\"end\", \"anchorSE\", 1], [\"color\", \"lineColor\"], [\"size\", \"lineSize\"], [\"startSocketGravity\", \"socketGravitySE\", 0], [\"endSocketGravity\", \"socketGravitySE\", 1], [\"startPlugColor\", \"plugColorSE\", 0], [\"endPlugColor\", \"plugColorSE\", 1], [\"startPlugSize\", \"plugSizeSE\", 0], [\"endPlugSize\", \"plugSizeSE\", 1], [\"outline\", \"lineOutlineEnabled\"], [\"outlineColor\", \"lineOutlineColor\"], [\"outlineSize\", \"lineOutlineSize\"], [\"startPlugOutline\", \"plugOutlineEnabledSE\", 0], [\"endPlugOutline\", \"plugOutlineEnabledSE\", 1], [\"startPlugOutlineColor\", \"plugOutlineColorSE\", 0], [\"endPlugOutlineColor\", \"plugOutlineColorSE\", 1], [\"startPlugOutlineSize\", \"plugOutlineSizeSE\", 0], [\"endPlugOutlineSize\", \"plugOutlineSizeSE\", 1]].forEach(function (e) {\n    var t = e[0],\n      n = e[1],\n      a = e[2];\n    Object.defineProperty(ot.prototype, t, {\n      get: function get() {\n        var e = null != a ? Se[this._id].options[n][a] : n ? Se[this._id].options[n] : Se[this._id].options[t];\n        return null == e ? D : we(e);\n      },\n      set: lt(t),\n      enumerable: !0\n    });\n  }), [[\"path\", R], [\"startSocket\", V, \"socketSE\", 0], [\"endSocket\", V, \"socketSE\", 1], [\"startPlug\", F, \"plugSE\", 0], [\"endPlug\", F, \"plugSE\", 1]].forEach(function (e) {\n    var a = e[0],\n      i = e[1],\n      o = e[2],\n      l = e[3];\n    Object.defineProperty(ot.prototype, a, {\n      get: function get() {\n        var t,\n          n = null != l ? Se[this._id].options[o][l] : o ? Se[this._id].options[o] : Se[this._id].options[a];\n        return n ? Object.keys(i).some(function (e) {\n          return i[e] === n && (t = e, !0);\n        }) ? t : new Error(\"It's broken\") : D;\n      },\n      set: lt(a),\n      enumerable: !0\n    });\n  }), Object.keys(Z).forEach(function (n) {\n    var a = Z[n];\n    Object.defineProperty(ot.prototype, n, {\n      get: function get() {\n        var s,\n          e,\n          t = Se[this._id].options[n];\n        return he(t) ? (s = t, e = a.optionsConf.reduce(function (e, t) {\n          var n,\n            a = t[0],\n            i = t[1],\n            o = t[2],\n            l = t[3],\n            t = t[4],\n            r = null != t ? s[l][t] : l ? s[l] : s[i];\n          return e[i] = \"id\" === a ? r ? Object.keys(o).some(function (e) {\n            return o[e] === r && (n = e, !0);\n          }) ? n : new Error(\"It's broken\") : D : null == r ? D : we(r), e;\n        }, {}), a.anim && (e.animation = we(s.animation)), e) : t;\n      },\n      set: lt(n),\n      enumerable: !0\n    });\n  }), [\"startLabel\", \"endLabel\", \"middleLabel\"].forEach(function (e, n) {\n    Object.defineProperty(ot.prototype, e, {\n      get: function get() {\n        var e = Se[this._id],\n          t = e.options;\n        return t.labelSEM[n] && !e.optionIsAttach.labelSEM[n] ? _e[t.labelSEM[n]._id].text : t.labelSEM[n] || \"\";\n      },\n      set: lt(e),\n      enumerable: !0\n    });\n  }), ot.prototype.setOptions = function (e) {\n    return it(Se[this._id], e), this;\n  }, ot.prototype.position = function () {\n    return $e(Se[this._id], {\n      position: !0\n    }), this;\n  }, ot.prototype.remove = function () {\n    var t = Se[this._id],\n      n = t.curStats;\n    Object.keys(Z).forEach(function (e) {\n      e += \"_animId\";\n      n[e] && g.remove(n[e]);\n    }), n.show_animId && g.remove(n.show_animId), t.attachments.slice().forEach(function (e) {\n      at(t, e);\n    }), t.baseWindow && t.svg && t.baseWindow.document.body.removeChild(t.svg), delete Se[this._id];\n  }, ot.prototype.show = function (e, t) {\n    return tt(Se[this._id], !0, e, t), this;\n  }, ot.prototype.hide = function (e, t) {\n    return tt(Se[this._id], !1, e, t), this;\n  }, o = function o(t) {\n    t && _e[t._id] && (t.boundTargets.slice().forEach(function (e) {\n      at(e.props, t, !0);\n    }), t.conf.remove && t.conf.remove(t), delete _e[t._id]);\n  }, rt.prototype.remove = function () {\n    var t = this,\n      n = _e[t._id];\n    n && (n.boundTargets.slice().forEach(function (e) {\n      n.conf.removeOption(n, e);\n    }), ze(function () {\n      var e = _e[t._id];\n      e && (console.error(\"LeaderLineAttachment was not removed by removeOption\"), o(e));\n    }));\n  }, M = rt, window.LeaderLineAttachment = M, I = function I(e, t) {\n    return e instanceof M && (!(e.isRemoved || t && _e[e._id].conf.type !== t) || null);\n  }, O = {\n    pointAnchor: {\n      type: \"anchor\",\n      argOptions: [{\n        optionName: \"element\",\n        type: Me\n      }],\n      init: function init(e, t) {\n        return e.element = O.pointAnchor.checkElement(t.element), e.x = O.pointAnchor.parsePercent(t.x, !0) || [.5, !0], e.y = O.pointAnchor.parsePercent(t.y, !0) || [.5, !0], !0;\n      },\n      removeOption: function removeOption(e, t) {\n        var n = t.props,\n          a = {},\n          i = e.element,\n          e = n.options.anchorSE[\"start\" === t.optionName ? 1 : 0];\n        i === e && (i = e === document.body ? new M(O.pointAnchor, [i]) : document.body), a[t.optionName] = i, it(n, a);\n      },\n      getBBoxNest: function getBBoxNest(e, t) {\n        var n = Le(e.element, t.baseWindow),\n          a = n.width,\n          t = n.height;\n        return n.width = n.height = 0, n.left = n.right = n.left + e.x[0] * (e.x[1] ? a : 1), n.top = n.bottom = n.top + e.y[0] * (e.y[1] ? t : 1), n;\n      },\n      parsePercent: function parsePercent(e, t) {\n        var n,\n          a,\n          i = !1;\n        return pe(e) ? a = e : \"string\" == typeof e && (n = m.exec(e)) && n[2] && (i = 0 !== (a = parseFloat(n[1]) / 100)), null != a && (t || 0 <= a) ? [a, i] : null;\n      },\n      checkElement: function checkElement(e) {\n        if (null == e) e = document.body;else if (!Me(e)) throw new Error(\"`element` must be Element\");\n        return e;\n      }\n    },\n    areaAnchor: {\n      type: \"anchor\",\n      argOptions: [{\n        optionName: \"element\",\n        type: Me\n      }, {\n        optionName: \"shape\",\n        type: \"string\"\n      }],\n      stats: {\n        color: {},\n        strokeWidth: {},\n        elementWidth: {},\n        elementHeight: {},\n        elementLeft: {},\n        elementTop: {},\n        pathListRel: {},\n        bBoxRel: {},\n        pathData: {},\n        viewBoxBBox: {\n          hasProps: !0\n        },\n        dashLen: {},\n        dashGap: {}\n      },\n      init: function init(a, e) {\n        var t,\n          n = [];\n        return a.element = O.pointAnchor.checkElement(e.element), \"string\" == typeof e.color && (a.color = e.color.trim()), \"string\" == typeof e.fillColor && (a.fill = e.fillColor.trim()), pe(e.size) && 0 <= e.size && (a.size = e.size), e.dash && (a.dash = !0, pe(e.dash.len) && 0 < e.dash.len && (a.dashLen = e.dash.len), pe(e.dash.gap) && 0 < e.dash.gap && (a.dashGap = e.dash.gap)), \"circle\" === e.shape ? a.shape = e.shape : \"polygon\" === e.shape && Array.isArray(e.points) && 3 <= e.points.length && e.points.every(function (e) {\n          var t = {};\n          return !(!(t.x = O.pointAnchor.parsePercent(e[0], !0)) || !(t.y = O.pointAnchor.parsePercent(e[1], !0))) && (n.push(t), (t.x[1] || t.y[1]) && (a.hasRatio = !0), !0);\n        }) ? (a.shape = e.shape, a.points = n) : (a.shape = \"rect\", a.radius = pe(e.radius) && 0 <= e.radius ? e.radius : 0), \"rect\" !== a.shape && \"circle\" !== a.shape || (a.x = O.pointAnchor.parsePercent(e.x, !0) || [-.05, !0], a.y = O.pointAnchor.parsePercent(e.y, !0) || [-.05, !0], a.width = O.pointAnchor.parsePercent(e.width) || [1.1, !0], a.height = O.pointAnchor.parsePercent(e.height) || [1.1, !0], (a.x[1] || a.y[1] || a.width[1] || a.height[1]) && (a.hasRatio = !0)), t = a.element.ownerDocument, a.svg = e = t.createElementNS(ae, \"svg\"), e.className.baseVal = C + \"-areaAnchor\", e.viewBox.baseVal || e.setAttribute(\"viewBox\", \"0 0 0 0\"), a.path = e.appendChild(t.createElementNS(ae, \"path\")), a.path.style.fill = a.fill || \"none\", a.isShown = !1, e.style.visibility = \"hidden\", t.body.appendChild(e), Qe(t = t.defaultView), a.bodyOffset = qe(t), a.updateColor = function () {\n          var e = a.curStats,\n            t = a.aplStats,\n            n = a.boundTargets.length ? a.boundTargets[0].props.curStats : null;\n          e.color = n = a.color || (n ? n.line_color : ue.lineColor), Xe(a, t, \"color\", n) && (a.path.style.stroke = n);\n        }, a.updateShow = function () {\n          Je(a, a.boundTargets.some(function (e) {\n            return !0 === e.props.isShown;\n          }));\n        }, !0;\n      },\n      bind: function bind(e, t) {\n        t = t.props;\n        return e.color || Ge(t, \"cur_line_color\", e.updateColor), Ge(t, \"svgShow\", e.updateShow), ze(function () {\n          e.updateColor(), e.updateShow();\n        }), !0;\n      },\n      unbind: function unbind(e, t) {\n        t = t.props;\n        e.color || De(t, \"cur_line_color\", e.updateColor), De(t, \"svgShow\", e.updateShow), 1 < e.boundTargets.length && ze(function () {\n          e.updateColor(), e.updateShow(), O.areaAnchor.update(e) && e.boundTargets.forEach(function (e) {\n            $e(e.props, {\n              position: !0\n            });\n          });\n        });\n      },\n      removeOption: function removeOption(e, t) {\n        O.pointAnchor.removeOption(e, t);\n      },\n      remove: function remove(t) {\n        t.boundTargets.length && (console.error(\"LeaderLineAttachment was not unbound by remove\"), t.boundTargets.forEach(function (e) {\n          O.areaAnchor.unbind(t, e);\n        })), t.svg.parentNode.removeChild(t.svg);\n      },\n      getStrokeWidth: function getStrokeWidth(e, t) {\n        return O.areaAnchor.update(e) && 1 < e.boundTargets.length && ze(function () {\n          e.boundTargets.forEach(function (e) {\n            e.props !== t && $e(e.props, {\n              position: !0\n            });\n          });\n        }), e.curStats.strokeWidth;\n      },\n      getPathData: function getPathData(e, t) {\n        var n = Le(e.element, t.baseWindow);\n        return Be(e.curStats.pathListRel, function (e) {\n          e.x += n.left, e.y += n.top;\n        });\n      },\n      getBBoxNest: function getBBoxNest(e, t) {\n        t = Le(e.element, t.baseWindow), e = e.curStats.bBoxRel;\n        return {\n          left: e.left + t.left,\n          top: e.top + t.top,\n          right: e.right + t.left,\n          bottom: e.bottom + t.top,\n          width: e.width,\n          height: e.height\n        };\n      },\n      update: function update(t) {\n        var n,\n          a,\n          i,\n          o,\n          e,\n          l,\n          r,\n          s,\n          u,\n          h,\n          p,\n          c,\n          d,\n          f,\n          y,\n          m,\n          S = t.curStats,\n          g = t.aplStats,\n          _ = t.boundTargets.length ? t.boundTargets[0].props.curStats : null,\n          v = {};\n        if (v.strokeWidth = Xe(t, S, \"strokeWidth\", null != t.size ? t.size : _ ? _.line_strokeWidth : ue.lineSize), n = Ie(t.element), v.elementWidth = Xe(t, S, \"elementWidth\", n.width), v.elementHeight = Xe(t, S, \"elementHeight\", n.height), v.elementLeft = Xe(t, S, \"elementLeft\", n.left), v.elementTop = Xe(t, S, \"elementTop\", n.top), v.strokeWidth || t.hasRatio && (v.elementWidth || v.elementHeight)) {\n          switch (t.shape) {\n            case \"rect\":\n              (c = {\n                left: t.x[0] * (t.x[1] ? n.width : 1),\n                top: t.y[0] * (t.y[1] ? n.height : 1),\n                width: t.width[0] * (t.width[1] ? n.width : 1),\n                height: t.height[0] * (t.height[1] ? n.height : 1)\n              }).right = c.left + c.width, c.bottom = c.top + c.height, p = S.strokeWidth / 2, s = (r = Math.min(c.width, c.height)) ? r / 2 * Math.SQRT2 + p : 0, h = (r = t.radius ? t.radius <= s ? t.radius : s : 0) ? (s = (r - p) / Math.SQRT2, h = [{\n                x: c.left - (u = r - s),\n                y: c.top + s\n              }, {\n                x: c.left + s,\n                y: c.top - u\n              }, {\n                x: c.right - s,\n                y: c.top - u\n              }, {\n                x: c.right + u,\n                y: c.top + s\n              }, {\n                x: c.right + u,\n                y: c.bottom - s\n              }, {\n                x: c.right - s,\n                y: c.bottom + u\n              }, {\n                x: c.left + s,\n                y: c.bottom + u\n              }, {\n                x: c.left - u,\n                y: c.bottom - s\n              }], S.pathListRel = [[h[0], {\n                x: h[0].x,\n                y: h[0].y - (p = r * te)\n              }, {\n                x: h[1].x - p,\n                y: h[1].y\n              }, h[1]]], h[1].x !== h[2].x && S.pathListRel.push([h[1], h[2]]), S.pathListRel.push([h[2], {\n                x: h[2].x + p,\n                y: h[2].y\n              }, {\n                x: h[3].x,\n                y: h[3].y - p\n              }, h[3]]), h[3].y !== h[4].y && S.pathListRel.push([h[3], h[4]]), S.pathListRel.push([h[4], {\n                x: h[4].x,\n                y: h[4].y + p\n              }, {\n                x: h[5].x + p,\n                y: h[5].y\n              }, h[5]]), h[5].x !== h[6].x && S.pathListRel.push([h[5], h[6]]), S.pathListRel.push([h[6], {\n                x: h[6].x - p,\n                y: h[6].y\n              }, {\n                x: h[7].x,\n                y: h[7].y + p\n              }, h[7]]), h[7].y !== h[0].y && S.pathListRel.push([h[7], h[0]]), S.pathListRel.push([]), u = r - s + S.strokeWidth / 2, [{\n                x: c.left - u,\n                y: c.top - u\n              }, {\n                x: c.right + u,\n                y: c.bottom + u\n              }]) : (u = S.strokeWidth / 2, h = [{\n                x: c.left - u,\n                y: c.top - u\n              }, {\n                x: c.right + u,\n                y: c.bottom + u\n              }], S.pathListRel = [[h[0], {\n                x: h[1].x,\n                y: h[0].y\n              }], [{\n                x: h[1].x,\n                y: h[0].y\n              }, h[1]], [h[1], {\n                x: h[0].x,\n                y: h[1].y\n              }], []], [{\n                x: c.left - S.strokeWidth,\n                y: c.top - S.strokeWidth\n              }, {\n                x: c.right + S.strokeWidth,\n                y: c.bottom + S.strokeWidth\n              }]), S.bBoxRel = {\n                left: h[0].x,\n                top: h[0].y,\n                right: h[1].x,\n                bottom: h[1].y,\n                width: h[1].x - h[0].x,\n                height: h[1].y - h[0].y\n              };\n              break;\n            case \"circle\":\n              (l = {\n                left: t.x[0] * (t.x[1] ? n.width : 1),\n                top: t.y[0] * (t.y[1] ? n.height : 1),\n                width: t.width[0] * (t.width[1] ? n.width : 1),\n                height: t.height[0] * (t.height[1] ? n.height : 1)\n              }).width || l.height || (l.width = l.height = 10), l.width || (l.width = l.height), l.height || (l.height = l.width), l.right = l.left + l.width, l.bottom = l.top + l.height, p = l.left + l.width / 2, r = l.top + l.height / 2, e = S.strokeWidth / 2, s = l.width / 2, u = l.height / 2, c = s * Math.SQRT2 + e, h = u * Math.SQRT2 + e, S.pathListRel = [[(e = [{\n                x: p - c,\n                y: r\n              }, {\n                x: p,\n                y: r - h\n              }, {\n                x: p + c,\n                y: r\n              }, {\n                x: p,\n                y: r + h\n              }])[0], {\n                x: e[0].x,\n                y: e[0].y - (p = h * te)\n              }, {\n                x: e[1].x - (r = c * te),\n                y: e[1].y\n              }, e[1]], [e[1], {\n                x: e[1].x + r,\n                y: e[1].y\n              }, {\n                x: e[2].x,\n                y: e[2].y - p\n              }, e[2]], [e[2], {\n                x: e[2].x,\n                y: e[2].y + p\n              }, {\n                x: e[3].x + r,\n                y: e[3].y\n              }, e[3]], [e[3], {\n                x: e[3].x - r,\n                y: e[3].y\n              }, {\n                x: e[0].x,\n                y: e[0].y + p\n              }, e[0]], []], s = c - s + S.strokeWidth / 2, u = h - u + S.strokeWidth / 2, e = [{\n                x: l.left - s,\n                y: l.top - u\n              }, {\n                x: l.right + s,\n                y: l.bottom + u\n              }], S.bBoxRel = {\n                left: e[0].x,\n                top: e[0].y,\n                right: e[1].x,\n                bottom: e[1].y,\n                width: e[1].x - e[0].x,\n                height: e[1].y - e[0].y\n              };\n              break;\n            case \"polygon\":\n              t.points.forEach(function (e) {\n                var t = e.x[0] * (e.x[1] ? n.width : 1),\n                  e = e.y[0] * (e.y[1] ? n.height : 1);\n                i ? (t < i.left && (i.left = t), t > i.right && (i.right = t), e < i.top && (i.top = e), e > i.bottom && (i.bottom = e)) : i = {\n                  left: t,\n                  right: t,\n                  top: e,\n                  bottom: e\n                }, o ? S.pathListRel.push([o, {\n                  x: t,\n                  y: e\n                }]) : S.pathListRel = [], o = {\n                  x: t,\n                  y: e\n                };\n              }), S.pathListRel.push([]), e = S.strokeWidth / 2, e = [{\n                x: i.left - e,\n                y: i.top - e\n              }, {\n                x: i.right + e,\n                y: i.bottom + e\n              }], S.bBoxRel = {\n                left: e[0].x,\n                top: e[0].y,\n                right: e[1].x,\n                bottom: e[1].y,\n                width: e[1].x - e[0].x,\n                height: e[1].y - e[0].y\n              };\n          }\n          v.pathListRel = v.bBoxRel = !0;\n        }\n        return (v.pathListRel || v.elementLeft || v.elementTop) && (S.pathData = Be(S.pathListRel, function (e) {\n          e.x += n.left, e.y += n.top;\n        })), Xe(t, g, \"strokeWidth\", a = S.strokeWidth) && (t.path.style.strokeWidth = a + \"px\"), Fe(a = S.pathData, g.pathData) && (t.path.setPathData(a), g.pathData = a, v.pathData = !0), t.dash && (!v.pathData && (!v.strokeWidth || t.dashLen && t.dashGap) || (S.dashLen = t.dashLen || 2 * S.strokeWidth, S.dashGap = t.dashGap || S.strokeWidth), v.dash = Xe(t, g, \"dashLen\", S.dashLen) || v.dash, v.dash = Xe(t, g, \"dashGap\", S.dashGap) || v.dash, v.dash && (t.path.style.strokeDasharray = g.dashLen + \",\" + g.dashGap)), d = S.viewBoxBBox, f = g.viewBoxBBox, y = t.svg.viewBox.baseVal, m = t.svg.style, d.x = S.bBoxRel.left + n.left, d.y = S.bBoxRel.top + n.top, d.width = S.bBoxRel.width, d.height = S.bBoxRel.height, [\"x\", \"y\", \"width\", \"height\"].forEach(function (e) {\n          (a = d[e]) !== f[e] && (y[e] = f[e] = a, m[Q[e]] = a + (\"x\" === e || \"y\" === e ? t.bodyOffset[e] : 0) + \"px\");\n        }), v.strokeWidth || v.pathListRel || v.bBoxRel;\n      }\n    },\n    mouseHoverAnchor: {\n      type: \"anchor\",\n      argOptions: [{\n        optionName: \"element\",\n        type: Me\n      }, {\n        optionName: \"showEffectName\",\n        type: \"string\"\n      }],\n      style: {\n        backgroundImage: \"url('data:image/svg+xml;charset=utf-8;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cG9seWdvbiBwb2ludHM9IjI0LDAgMCw4IDgsMTEgMCwxOSA1LDI0IDEzLDE2IDE2LDI0IiBmaWxsPSJjb3JhbCIvPjwvc3ZnPg==')\",\n        backgroundSize: \"\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundColor: \"#f8f881\",\n        cursor: \"default\"\n      },\n      hoverStyle: {\n        backgroundImage: \"none\",\n        backgroundColor: \"#fadf8f\"\n      },\n      padding: {\n        top: 1,\n        right: 15,\n        bottom: 1,\n        left: 2\n      },\n      minHeight: 15,\n      backgroundPosition: {\n        right: 2,\n        top: 2\n      },\n      backgroundSize: {\n        width: 12,\n        height: 12\n      },\n      dirKeys: [[\"top\", \"Top\"], [\"right\", \"Right\"], [\"bottom\", \"Bottom\"], [\"left\", \"Left\"]],\n      init: function init(a, i) {\n        var n,\n          t,\n          e,\n          o,\n          l,\n          r,\n          s,\n          u,\n          h,\n          p = O.mouseHoverAnchor,\n          c = {};\n        if (a.element = O.pointAnchor.checkElement(i.element), s = a.element, !((u = s.ownerDocument) && (h = u.defaultView) && h.HTMLElement && s instanceof h.HTMLElement)) throw new Error(\"`element` must be HTML element\");\n        return p.style.backgroundSize = p.backgroundSize.width + \"px \" + p.backgroundSize.height + \"px\", [\"style\", \"hoverStyle\"].forEach(function (e) {\n          var n = p[e];\n          a[e] = Object.keys(n).reduce(function (e, t) {\n            return e[t] = n[t], e;\n          }, {});\n        }), \"inline\" === (n = a.element.ownerDocument.defaultView.getComputedStyle(a.element, \"\")).display ? a.style.display = \"inline-block\" : \"none\" === n.display && (a.style.display = \"block\"), O.mouseHoverAnchor.dirKeys.forEach(function (e) {\n          var t = e[0],\n            e = \"padding\" + e[1];\n          parseFloat(n[e]) < p.padding[t] && (a.style[e] = p.padding[t] + \"px\");\n        }), a.style.display && (e = a.element.style.display, a.element.style.display = a.style.display), O.mouseHoverAnchor.dirKeys.forEach(function (e) {\n          e = \"padding\" + e[1];\n          a.style[e] && (c[e] = a.element.style[e], a.element.style[e] = a.style[e]);\n        }), (s = a.element.getBoundingClientRect()).height < p.minHeight && (ie ? (h = p.minHeight, \"content-box\" === n.boxSizing ? h -= parseFloat(n.borderTopWidth) + parseFloat(n.borderBottomWidth) + parseFloat(n.paddingTop) + parseFloat(n.paddingBottom) : \"padding-box\" === n.boxSizing && (h -= parseFloat(n.borderTopWidth) + parseFloat(n.borderBottomWidth)), a.style.height = h + \"px\") : a.style.height = parseFloat(n.height) + (p.minHeight - s.height) + \"px\"), a.style.backgroundPosition = re ? s.width - p.backgroundSize.width - p.backgroundPosition.right + \"px \" + p.backgroundPosition.top + \"px\" : \"right \" + p.backgroundPosition.right + \"px top \" + p.backgroundPosition.top + \"px\", a.style.display && (a.element.style.display = e), O.mouseHoverAnchor.dirKeys.forEach(function (e) {\n          e = \"padding\" + e[1];\n          a.style[e] && (a.element.style[e] = c[e]);\n        }), [\"style\", \"hoverStyle\"].forEach(function (e) {\n          var t = a[e],\n            n = i[e];\n          he(n) && Object.keys(n).forEach(function (e) {\n            \"string\" == typeof n[e] || pe(n[e]) ? t[e] = n[e] : null == n[e] && delete t[e];\n          });\n        }), \"function\" == typeof i.onSwitch && (r = i.onSwitch), i.showEffectName && w[i.showEffectName] && (a.showEffectName = o = i.showEffectName), l = i.animOptions, a.elmStyle = t = a.element.style, a.mouseenter = function (e) {\n          a.hoverStyleSave = p.getStyles(t, Object.keys(a.hoverStyle)), p.setStyles(t, a.hoverStyle), a.boundTargets.forEach(function (e) {\n            tt(e.props, !0, o, l);\n          }), r && r(e);\n        }, a.mouseleave = function (e) {\n          p.setStyles(t, a.hoverStyleSave), a.boundTargets.forEach(function (e) {\n            tt(e.props, !1, o, l);\n          }), r && r(e);\n        }, !0;\n      },\n      bind: function bind(e, t) {\n        var n, a, i, o, l;\n        return t.props.svg ? O.mouseHoverAnchor.llShow(t.props, !1, e.showEffectName) : ze(function () {\n          O.mouseHoverAnchor.llShow(t.props, !1, e.showEffectName);\n        }), e.enabled || (e.styleSave = O.mouseHoverAnchor.getStyles(e.elmStyle, Object.keys(e.style)), O.mouseHoverAnchor.setStyles(e.elmStyle, e.style), e.removeEventListener = (n = e.element, a = e.mouseenter, i = e.mouseleave, \"onmouseenter\" in n && \"onmouseleave\" in n ? (n.addEventListener(\"mouseenter\", a, !1), n.addEventListener(\"mouseleave\", i, !1), function () {\n          n.removeEventListener(\"mouseenter\", a, !1), n.removeEventListener(\"mouseleave\", i, !1);\n        }) : (console.warn(\"mouseenter and mouseleave events polyfill is enabled.\"), n.addEventListener(\"mouseover\", o = function o(e) {\n          e.relatedTarget && (e.relatedTarget === this || this.compareDocumentPosition(e.relatedTarget) & Node.DOCUMENT_POSITION_CONTAINED_BY) || a.apply(this, arguments);\n        }), n.addEventListener(\"mouseout\", l = function l(e) {\n          e.relatedTarget && (e.relatedTarget === this || this.compareDocumentPosition(e.relatedTarget) & Node.DOCUMENT_POSITION_CONTAINED_BY) || i.apply(this, arguments);\n        }), function () {\n          n.removeEventListener(\"mouseover\", o, !1), n.removeEventListener(\"mouseout\", l, !1);\n        })), e.enabled = !0), !0;\n      },\n      unbind: function unbind(e, t) {\n        e.enabled && e.boundTargets.length <= 1 && (e.removeEventListener(), O.mouseHoverAnchor.setStyles(e.elmStyle, e.styleSave), e.enabled = !1), O.mouseHoverAnchor.llShow(t.props, !0, e.showEffectName);\n      },\n      removeOption: function removeOption(e, t) {\n        O.pointAnchor.removeOption(e, t);\n      },\n      remove: function remove(t) {\n        t.boundTargets.length && (console.error(\"LeaderLineAttachment was not unbound by remove\"), t.boundTargets.forEach(function (e) {\n          O.mouseHoverAnchor.unbind(t, e);\n        }));\n      },\n      getBBoxNest: function getBBoxNest(e, t) {\n        return Le(e.element, t.baseWindow);\n      },\n      llShow: function llShow(e, t, n) {\n        w[n || e.curStats.show_effect].stop(e, !0, t), e.aplStats.show_on = t;\n      },\n      getStyles: function getStyles(n, e) {\n        return e.reduce(function (e, t) {\n          return e[t] = n[t], e;\n        }, {});\n      },\n      setStyles: function setStyles(t, n) {\n        Object.keys(n).forEach(function (e) {\n          t[e] = n[e];\n        });\n      }\n    },\n    captionLabel: {\n      type: \"label\",\n      argOptions: [{\n        optionName: \"text\",\n        type: \"string\"\n      }],\n      stats: {\n        color: {},\n        x: {},\n        y: {}\n      },\n      textStyleProps: [\"fontFamily\", \"fontStyle\", \"fontVariant\", \"fontWeight\", \"fontStretch\", \"fontSize\", \"fontSizeAdjust\", \"kerning\", \"letterSpacing\", \"wordSpacing\", \"textDecoration\"],\n      init: function init(l, t) {\n        return \"string\" == typeof t.text && (l.text = t.text.trim()), !!l.text && (\"string\" == typeof t.color && (l.color = t.color.trim()), l.outlineColor = \"string\" == typeof t.outlineColor ? t.outlineColor.trim() : \"#fff\", Array.isArray(t.offset) && pe(t.offset[0]) && pe(t.offset[1]) && (l.offset = {\n          x: t.offset[0],\n          y: t.offset[1]\n        }), pe(t.lineOffset) && (l.lineOffset = t.lineOffset), O.captionLabel.textStyleProps.forEach(function (e) {\n          null != t[e] && (l[e] = t[e]);\n        }), l.updateColor = function (e) {\n          O.captionLabel.updateColor(l, e);\n        }, l.updateSocketXY = function (e) {\n          var t,\n            n = l.curStats,\n            a = l.aplStats,\n            i = e.curStats,\n            o = i.position_socketXYSE[l.socketIndex];\n          null != o.x && (l.offset ? (n.x = o.x + l.offset.x, n.y = o.y + l.offset.y) : (t = l.height / 2, e = Math.max(i.attach_plugSideLenSE[l.socketIndex] || 0, i.line_strokeWidth / 2), i = i.position_socketXYSE[l.socketIndex ? 0 : 1], o.socketId === A || o.socketId === k ? (n.x = o.socketId === A ? o.x - t - l.width : o.x + t, n.y = i.y < o.y ? o.y + e + t : o.y - e - t - l.height) : (n.x = i.x < o.x ? o.x + e + t : o.x - e - t - l.width, n.y = o.socketId === b ? o.y - t - l.height : o.y + t)), Xe(l, a, \"x\", t = n.x) && (l.elmPosition.x.baseVal.getItem(0).value = t), Xe(l, a, \"y\", t = n.y) && (l.elmPosition.y.baseVal.getItem(0).value = t + l.height));\n        }, l.updatePath = function (e) {\n          var t = l.curStats,\n            n = l.aplStats,\n            e = e.pathList.animVal || e.pathList.baseVal;\n          e && (e = O.captionLabel.getMidPoint(e, l.lineOffset), t.x = e.x - l.width / 2, t.y = e.y - l.height / 2, Xe(l, n, \"x\", e = t.x) && (l.elmPosition.x.baseVal.getItem(0).value = e), Xe(l, n, \"y\", e = t.y) && (l.elmPosition.y.baseVal.getItem(0).value = e + l.height));\n        }, l.updateShow = function (e) {\n          O.captionLabel.updateShow(l, e);\n        }, re && (l.adjustEdge = function (e, t) {\n          var n = l.curStats;\n          null != n.x && O.captionLabel.adjustEdge(t, {\n            x: n.x,\n            y: n.y,\n            width: l.width,\n            height: l.height\n          }, l.strokeWidth / 2);\n        }), !0);\n      },\n      updateColor: function updateColor(e, t) {\n        var n = e.curStats,\n          a = e.aplStats,\n          t = t.curStats;\n        n.color = t = e.color || t.line_color, Xe(e, a, \"color\", t) && (e.styleFill.fill = t);\n      },\n      updateShow: function updateShow(e, t) {\n        t = !0 === t.isShown;\n        t !== e.isShown && (e.styleShow.visibility = t ? \"\" : \"hidden\", e.isShown = t);\n      },\n      adjustEdge: function adjustEdge(e, t, n) {\n        n = {\n          x1: t.x - n,\n          y1: t.y - n,\n          x2: t.x + t.width + n,\n          y2: t.y + t.height + n\n        };\n        n.x1 < e.x1 && (e.x1 = n.x1), n.y1 < e.y1 && (e.y1 = n.y1), n.x2 > e.x2 && (e.x2 = n.x2), n.y2 > e.y2 && (e.y2 = n.y2);\n      },\n      newText: function newText(e, t, n, a, i) {\n        var o,\n          l,\n          r = t.createElementNS(ae, \"text\");\n        return r.textContent = e, [r.x, r.y].forEach(function (e) {\n          var t = n.createSVGLength();\n          t.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, 0), e.baseVal.initialize(t);\n        }), \"boolean\" != typeof h && (h = \"paintOrder\" in r.style), i && !h ? (o = t.createElementNS(ae, \"defs\"), r.id = a, o.appendChild(r), (l = (e = t.createElementNS(ae, \"g\")).appendChild(t.createElementNS(ae, \"use\"))).href.baseVal = \"#\" + a, (t = e.appendChild(t.createElementNS(ae, \"use\"))).href.baseVal = \"#\" + a, (l = l.style).strokeLinejoin = \"round\", {\n          elmPosition: r,\n          styleText: r.style,\n          styleFill: t.style,\n          styleStroke: l,\n          styleShow: e.style,\n          elmsAppend: [o, e]\n        }) : (l = r.style, i && (l.strokeLinejoin = \"round\", l.paintOrder = \"stroke\"), {\n          elmPosition: r,\n          styleText: l,\n          styleFill: l,\n          styleStroke: i ? l : null,\n          styleShow: l,\n          elmsAppend: [r]\n        });\n      },\n      getMidPoint: function getMidPoint(e, t) {\n        var n,\n          a,\n          i = Re(e),\n          o = i.segsLen,\n          i = i.lenAll,\n          l = -1,\n          r = i / 2 + (t || 0);\n        if (r <= 0) return 2 === (n = e[0]).length ? Ve(n[0], n[1], 0) : Ne(n[0], n[1], n[2], n[3], 0);\n        if (i <= r) return 2 === (n = e[e.length - 1]).length ? Ve(n[0], n[1], 1) : Ne(n[0], n[1], n[2], n[3], 1);\n        for (a = []; r > o[++l];) a.push(e[l]), r -= o[l];\n        return 2 === (n = e[l]).length ? Ve(n[0], n[1], r / o[l]) : Ne(n[0], n[1], n[2], n[3], We(n[0], n[1], n[2], n[3], r));\n      },\n      initSvg: function initSvg(t, n) {\n        var e,\n          a,\n          i = O.captionLabel.newText(t.text, n.baseWindow.document, n.svg, C + \"-captionLabel-\" + t._id, t.outlineColor);\n        [\"elmPosition\", \"styleFill\", \"styleShow\", \"elmsAppend\"].forEach(function (e) {\n          t[e] = i[e];\n        }), t.isShown = !1, t.styleShow.visibility = \"hidden\", O.captionLabel.textStyleProps.forEach(function (e) {\n          null != t[e] && (i.styleText[e] = t[e]);\n        }), i.elmsAppend.forEach(function (e) {\n          n.svg.appendChild(e);\n        }), e = i.elmPosition.getBBox(), t.width = e.width, t.height = e.height, t.outlineColor && (a = e.height / 9, i.styleStroke.strokeWidth = (a = 10 < a ? 10 : a < 2 ? 2 : a) + \"px\", i.styleStroke.stroke = t.outlineColor), t.strokeWidth = a || 0, Ye(t.aplStats, O.captionLabel.stats), t.updateColor(n), t.refSocketXY ? t.updateSocketXY(n) : t.updatePath(n), re && $e(n, {}), t.updateShow(n);\n      },\n      bind: function bind(e, t) {\n        var n = t.props;\n        return e.color || Ge(n, \"cur_line_color\", e.updateColor), (e.refSocketXY = \"startLabel\" === t.optionName || \"endLabel\" === t.optionName) ? (e.socketIndex = \"startLabel\" === t.optionName ? 0 : 1, Ge(n, \"apl_position\", e.updateSocketXY), e.offset || (Ge(n, \"cur_attach_plugSideLenSE\", e.updateSocketXY), Ge(n, \"cur_line_strokeWidth\", e.updateSocketXY))) : Ge(n, \"apl_path\", e.updatePath), Ge(n, \"svgShow\", e.updateShow), re && Ge(n, \"new_edge4viewBox\", e.adjustEdge), O.captionLabel.initSvg(e, n), !0;\n      },\n      unbind: function unbind(e, t) {\n        var n = t.props;\n        e.elmsAppend && (e.elmsAppend.forEach(function (e) {\n          n.svg.removeChild(e);\n        }), e.elmPosition = e.styleFill = e.styleShow = e.elmsAppend = null), Ye(e.curStats, O.captionLabel.stats), Ye(e.aplStats, O.captionLabel.stats), e.color || De(n, \"cur_line_color\", e.updateColor), e.refSocketXY ? (De(n, \"apl_position\", e.updateSocketXY), e.offset || (De(n, \"cur_attach_plugSideLenSE\", e.updateSocketXY), De(n, \"cur_line_strokeWidth\", e.updateSocketXY))) : De(n, \"apl_path\", e.updatePath), De(n, \"svgShow\", e.updateShow), re && (De(n, \"new_edge4viewBox\", e.adjustEdge), $e(n, {}));\n      },\n      removeOption: function removeOption(e, t) {\n        var n = t.props,\n          a = {};\n        a[t.optionName] = \"\", it(n, a);\n      },\n      remove: function remove(t) {\n        t.boundTargets.length && (console.error(\"LeaderLineAttachment was not unbound by remove\"), t.boundTargets.forEach(function (e) {\n          O.captionLabel.unbind(t, e);\n        }));\n      }\n    },\n    pathLabel: {\n      type: \"label\",\n      argOptions: [{\n        optionName: \"text\",\n        type: \"string\"\n      }],\n      stats: {\n        color: {},\n        startOffset: {},\n        pathData: {}\n      },\n      init: function init(l, t) {\n        return \"string\" == typeof t.text && (l.text = t.text.trim()), !!l.text && (\"string\" == typeof t.color && (l.color = t.color.trim()), l.outlineColor = \"string\" == typeof t.outlineColor ? t.outlineColor.trim() : \"#fff\", pe(t.lineOffset) && (l.lineOffset = t.lineOffset), O.captionLabel.textStyleProps.forEach(function (e) {\n          null != t[e] && (l[e] = t[e]);\n        }), l.updateColor = function (e) {\n          O.captionLabel.updateColor(l, e);\n        }, l.updatePath = function (e) {\n          var t = l.curStats,\n            n = l.aplStats,\n            a = e.curStats,\n            i = e.pathList.animVal || e.pathList.baseVal;\n          i && (t.pathData = a = O.pathLabel.getOffsetPathData(i, a.line_strokeWidth / 2 + l.strokeWidth / 2 + l.height / 4, 1.25 * l.height), Fe(a, n.pathData) && (l.elmPath.setPathData(a), n.pathData = a, l.bBox = l.elmPosition.getBBox(), l.updateStartOffset(e)));\n        }, l.updateStartOffset = function (e) {\n          var i,\n            t,\n            n = l.curStats,\n            a = l.aplStats,\n            o = e.curStats;\n          n.pathData && (2 === l.semIndex && !l.lineOffset || (t = n.pathData.reduce(function (e, t) {\n            var n,\n              a = t.values;\n            switch (t.type) {\n              case \"M\":\n                i = {\n                  x: a[0],\n                  y: a[1]\n                };\n                break;\n              case \"L\":\n                n = {\n                  x: a[0],\n                  y: a[1]\n                }, i && (e += Ae(i, n)), i = n;\n                break;\n              case \"C\":\n                n = {\n                  x: a[4],\n                  y: a[5]\n                }, i && (e += Te(i, {\n                  x: a[0],\n                  y: a[1]\n                }, {\n                  x: a[2],\n                  y: a[3]\n                }, n)), i = n;\n            }\n            return e;\n          }, 0), e = 0 === l.semIndex ? 0 : 1 === l.semIndex ? t : t / 2, 2 !== l.semIndex && (o = Math.max(o.attach_plugBackLenSE[l.semIndex] || 0, o.line_strokeWidth / 2) + l.strokeWidth / 2 + l.height / 4, e = (e += 0 === l.semIndex ? o : -o) < 0 ? 0 : t < e ? t : e), l.lineOffset && (e = (e += l.lineOffset) < 0 ? 0 : t < e ? t : e), n.startOffset = e, Xe(l, a, \"startOffset\", e) && (l.elmOffset.startOffset.baseVal.value = e)));\n        }, l.updateShow = function (e) {\n          O.captionLabel.updateShow(l, e);\n        }, re && (l.adjustEdge = function (e, t) {\n          l.bBox && O.captionLabel.adjustEdge(t, l.bBox, l.strokeWidth / 2);\n        }), !0);\n      },\n      getOffsetPathData: function getOffsetPathData(e, c, n) {\n        var d,\n          a,\n          f = [];\n        function y(e, t) {\n          return Math.abs(e.x - t.x) < 3 && Math.abs(e.y - t.y) < 3;\n        }\n        return e.forEach(function (e) {\n          var t, n, a, i, o, l, r, s, u, h, p;\n          2 === e.length ? (s = e[0], u = e[1], h = c, p = Math.atan2(s.y - u.y, u.x - s.x) + .5 * Math.PI, t = [{\n            x: s.x + Math.cos(p) * h,\n            y: s.y + Math.sin(p) * h * -1\n          }, {\n            x: u.x + Math.cos(p) * h,\n            y: u.y + Math.sin(p) * h * -1\n          }], d ? (a = d.points, 0 <= (r = Math.atan2(a[1].y - a[0].y, a[0].x - a[1].x) - Math.atan2(e[0].y - e[1].y, e[1].x - e[0].x)) && r <= Math.PI ? n = {\n            type: \"line\",\n            points: t,\n            inside: !0\n          } : (o = Pe(a[0], a[1], c), i = Pe(t[1], t[0], c), l = a[0], s = t[1], p = (u = o).x - l.x, h = u.y - l.y, r = s.x - i.x, u = s.y - i.y, s = (-h * (l.x - i.x) + p * (l.y - i.y)) / (-r * h + p * u), u = (r * (l.y - i.y) - u * (l.x - i.x)) / (-r * h + p * u), n = (h = 0 <= s && s <= 1 && 0 <= u && u <= 1 ? {\n            x: l.x + u * p,\n            y: l.y + u * h\n          } : null) ? {\n            type: \"line\",\n            points: [a[1] = h, t[1]]\n          } : (a[1] = y(i, o) ? i : o, {\n            type: \"line\",\n            points: [i, t[1]]\n          }), d.len = Ae(a[0], a[1]))) : n = {\n            type: \"line\",\n            points: t\n          }, n.len = Ae(n.points[0], n.points[1]), f.push(d = n)) : (f.push({\n            type: \"cubic\",\n            points: function (e, t, n, a, i, o) {\n              for (var l, r, s = Te(e, t, n, a) / o, u = 1 / (o < i ? i / o * s : s), h = [], p = 0; r = (90 - (l = Ne(e, t, n, a, p)).angle) * (Math.PI / 180), h.push({\n                x: l.x + Math.cos(r) * i,\n                y: l.y + Math.sin(r) * i * -1\n              }), !(1 <= p);) 1 < (p += u) && (p = 1);\n              return h;\n            }(e[0], e[1], e[2], e[3], c, 16)\n          }), d = null);\n        }), d = null, f.forEach(function (e) {\n          var t;\n          d = \"line\" === e.type ? (e.inside && (d.len > c ? ((t = d.points)[1] = Pe(t[0], t[1], -c), d.len = Ae(t[0], t[1])) : (d.points = null, d.len = 0), e.len > c + n ? ((t = e.points)[0] = Pe(t[1], t[0], -(c + n)), e.len = Ae(t[0], t[1])) : (e.points = null, e.len = 0)), e) : null;\n        }), f.reduce(function (t, e) {\n          var n = e.points;\n          return n && (a && y(n[0], a) || t.push({\n            type: \"M\",\n            values: [n[0].x, n[0].y]\n          }), \"line\" === e.type ? t.push({\n            type: \"L\",\n            values: [n[1].x, n[1].y]\n          }) : (n.shift(), n.forEach(function (e) {\n            t.push({\n              type: \"L\",\n              values: [e.x, e.y]\n            });\n          })), a = n[n.length - 1]), t;\n        }, []);\n      },\n      newText: function newText(e, t, n, a) {\n        var i,\n          o,\n          l,\n          r,\n          s = t.createElementNS(ae, \"defs\"),\n          u = s.appendChild(t.createElementNS(ae, \"path\"));\n        return u.id = i = n + \"-path\", (l = (o = t.createElementNS(ae, \"text\")).appendChild(t.createElementNS(ae, \"textPath\"))).href.baseVal = \"#\" + i, l.startOffset.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, 0), l.textContent = e, \"boolean\" != typeof h && (h = \"paintOrder\" in o.style), a && !h ? (o.id = e = n + \"-text\", s.appendChild(o), (r = (n = t.createElementNS(ae, \"g\")).appendChild(t.createElementNS(ae, \"use\"))).href.baseVal = \"#\" + e, (t = n.appendChild(t.createElementNS(ae, \"use\"))).href.baseVal = \"#\" + e, (r = r.style).strokeLinejoin = \"round\", {\n          elmPosition: o,\n          elmPath: u,\n          elmOffset: l,\n          styleText: o.style,\n          styleFill: t.style,\n          styleStroke: r,\n          styleShow: n.style,\n          elmsAppend: [s, n]\n        }) : (r = o.style, a && (r.strokeLinejoin = \"round\", r.paintOrder = \"stroke\"), {\n          elmPosition: o,\n          elmPath: u,\n          elmOffset: l,\n          styleText: r,\n          styleFill: r,\n          styleStroke: a ? r : null,\n          styleShow: r,\n          elmsAppend: [s, o]\n        });\n      },\n      initSvg: function initSvg(t, n) {\n        var e,\n          a,\n          i,\n          o = O.pathLabel.newText(t.text, n.baseWindow.document, C + \"-pathLabel-\" + t._id, t.outlineColor);\n        [\"elmPosition\", \"elmPath\", \"elmOffset\", \"styleFill\", \"styleShow\", \"elmsAppend\"].forEach(function (e) {\n          t[e] = o[e];\n        }), t.isShown = !1, t.styleShow.visibility = \"hidden\", O.captionLabel.textStyleProps.forEach(function (e) {\n          null != t[e] && (o.styleText[e] = t[e]);\n        }), o.elmsAppend.forEach(function (e) {\n          n.svg.appendChild(e);\n        }), o.elmPath.setPathData([{\n          type: \"M\",\n          values: [0, 100]\n        }, {\n          type: \"h\",\n          values: [100]\n        }]), le && (i = o.elmOffset.href.baseVal, o.elmOffset.href.baseVal = \"\"), e = o.elmPosition.getBBox(), le && (o.elmOffset.href.baseVal = i), o.styleText.textAnchor = [\"start\", \"end\", \"middle\"][t.semIndex], 2 !== t.semIndex || t.lineOffset || o.elmOffset.startOffset.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE, 50), t.height = e.height, t.outlineColor && (a = e.height / 9, o.styleStroke.strokeWidth = (a = 10 < a ? 10 : a < 2 ? 2 : a) + \"px\", o.styleStroke.stroke = t.outlineColor), t.strokeWidth = a || 0, Ye(t.aplStats, O.pathLabel.stats), t.updateColor(n), t.updatePath(n), t.updateStartOffset(n), re && $e(n, {}), t.updateShow(n);\n      },\n      bind: function bind(e, t) {\n        var n = t.props;\n        return e.color || Ge(n, \"cur_line_color\", e.updateColor), Ge(n, \"cur_line_strokeWidth\", e.updatePath), Ge(n, \"apl_path\", e.updatePath), e.semIndex = \"startLabel\" === t.optionName ? 0 : \"endLabel\" === t.optionName ? 1 : 2, 2 === e.semIndex && !e.lineOffset || Ge(n, \"cur_attach_plugBackLenSE\", e.updateStartOffset), Ge(n, \"svgShow\", e.updateShow), re && Ge(n, \"new_edge4viewBox\", e.adjustEdge), O.pathLabel.initSvg(e, n), !0;\n      },\n      unbind: function unbind(e, t) {\n        var n = t.props;\n        e.elmsAppend && (e.elmsAppend.forEach(function (e) {\n          n.svg.removeChild(e);\n        }), e.elmPosition = e.elmPath = e.elmOffset = e.styleFill = e.styleShow = e.elmsAppend = null), Ye(e.curStats, O.pathLabel.stats), Ye(e.aplStats, O.pathLabel.stats), e.color || De(n, \"cur_line_color\", e.updateColor), De(n, \"cur_line_strokeWidth\", e.updatePath), De(n, \"apl_path\", e.updatePath), 2 === e.semIndex && !e.lineOffset || De(n, \"cur_attach_plugBackLenSE\", e.updateStartOffset), De(n, \"svgShow\", e.updateShow), re && (De(n, \"new_edge4viewBox\", e.adjustEdge), $e(n, {}));\n      },\n      removeOption: function removeOption(e, t) {\n        var n = t.props,\n          a = {};\n        a[t.optionName] = \"\", it(n, a);\n      },\n      remove: function remove(t) {\n        t.boundTargets.length && (console.error(\"LeaderLineAttachment was not unbound by remove\"), t.boundTargets.forEach(function (e) {\n          O.pathLabel.unbind(t, e);\n        }));\n      }\n    }\n  }, Object.keys(O).forEach(function (e) {\n    ot[e] = function () {\n      return new M(O[e], Array.prototype.slice.call(arguments));\n    };\n  }), ot.positionByWindowResize = !0, window.addEventListener(\"resize\", S.add(function () {\n    ot.positionByWindowResize && Object.keys(Se).forEach(function (e) {\n      $e(Se[e], {\n        position: !0\n      });\n    });\n  }), !1), ot;\n}();","map":null,"metadata":{},"sourceType":"script"}