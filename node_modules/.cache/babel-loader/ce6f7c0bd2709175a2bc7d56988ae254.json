{"ast":null,"code":"//Trechos de códigos extraídos das apresentações de slides do profressor André Renato\nexport var STRUCT_SIMPLES = \"\\nstruct elemento{\\n    int valor;\\n    struct elemento *prox;\\n};\";\nexport var INICIA_LISTA_SIMPLES = \"\\nint main(void){\\n    struct elemento *inicio;\\n    inicio = CriaLista();\\n    return 0;\\n}\\n\";\nexport var CRIA_LISTA_FUNCAO_SIMPLES = \"\\nstruct elemento *CriaLista(){\\n    return NULL;\\n}\";\nexport var CRIA_LISTA_USO_SIMPLES = \"struct elemento *inicio;\\ninicio = CriaLista();\";\nexport var CRIA_ELEMENTO_FUNCAO_SIMPLES = \"\\nstruct elemento *CriaElemento(int numero){\\n    struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));\\n    resp->valor = numero;\\n    resp->prox = NULL;\\n    return resp;\\n}\";\nexport var INSERE_INICIO_FUNCAO_SIMPLES = \"\\nstruct elemento *InsereInicio(elemento *lista, int numero){\\n    struct elemento *novo = CriaElemento(numero);\\n    novo->prox = lista;\\n    lista = novo;\\n    return lista;\\n}\";\nexport var INSERE_FIM_FUNCAO_SIMPLES = \"\\nstruct elemento *InsereFim(struct elemento *lista, int numero){\\n    struct elemento *aux;\\n    struct elemento *novo = CriaElemento(numero);\\n    if (lista == NULL){\\n        lista = novo;\\n    }\\n    else{\\n        aux = lista;\\n        while (aux->prox != NULL)\\n            aux = aux->prox;\\n        aux->prox = novo;\\n    }\\n    return lista;\\n}\";\nexport var INSERE_INDICE_FUNCAO_SIMPLES = \"\\nstruct elemento *InsereIndice(struct elemento *lista, int numero, int indice) {\\n    struct elemento *aux;\\n    struct elemento *ant;\\n    struct elemento *novo = CriaElemento(numero);\\n    int indiceAtual = 1;\\n    if (lista == NULL) \\n    {\\n      lista = novo;\\n    } \\n    else if (indice == 0) \\n    {\\n      novo->prox = lista;\\n      lista = novo;\\n    } \\n    else {\\n      aux = lista->prox;\\n      ant = lista;\\n      while (aux != NULL && indiceAtual != indice) \\n      {\\n        ant = aux;\\n        aux = aux->prox;\\n        indiceAtual++;\\n      }\\n      if (indiceAtual == indice) \\n      {\\n        ant->prox = novo;\\n        novo->prox = aux;\\n      }\\n    }\\n    return lista;\\n  }\";\nexport var BUSCA_FUNCAO_SIMPLES = \"\\nstruct elemento *BuscaElemento(struct elemento *lista, int numero){\\n    struct elemento *aux = lista;\\n    while (aux != NULL && aux->valor != numero)\\n        aux = aux->prox;\\n    return aux;\\n}\";\nexport var BUSCA_FUNCAO_SIMPLES_INDICE = \"\\nstruct elemento *BuscaIndice(struct elemento *lista, int indice){\\n    int indiceAtual = 0;\\n    struct elemento *aux = lista;\\n    while (aux != NULL && indiceAtual != indice){\\n        aux = aux->prox;\\n        indiceAtual++;\\n    return aux;\\n}\";\nexport var REMOVE_FUNCAO_SIMPLES = \"\\nstruct elemento *RemoveElemento(struct elemento *lista, int numero){\\n    if (lista == NULL) return NULL;\\n    struct elemento *ant = lista;\\n    struct elemento *aux = ant->prox;\\n    if (ant->valor == numero){\\n        lista = aux;\\n        free(ant);\\n    }\\n    else{\\n        while (aux != NULL && aux->valor != numero){\\n            ant = aux;\\n            aux = aux->prox;\\n        }\\n        if (aux != NULL){\\n            ant->prox = aux->prox;\\n            free(aux);\\n        }\\n    }\\n    return lista;\\n}\";\nexport var REMOVE_FUNCAO_SIMPLES_INDICE = \"\\nstruct elemento *RemoveIndice(struct elemento *lista, int indice){\\n    if (lista == NULL) return NULL;\\n    int indiceAtual = 1;\\n    struct elemento *ant = lista;\\n    struct elemento *aux = ant->prox;\\n    if (indice == 0){\\n        lista = aux;\\n        free(ant);\\n    }\\n    else{\\n        while (aux != NULL && indiceAtual != indice){\\n            ant = aux;\\n            aux = aux->prox;\\n            indiceAtual++;\\n        }\\n        if (aux != NULL){\\n            ant->prox = aux->prox;\\n            free(aux);\\n        }\\n    }\\n    return lista;\\n}\";\nexport var DESTROI_LISTA_FUNCAO_SIMPLES = \"\\nstruct elemento *DestroiLista(struct elemento *lista){\\n    struct elemento *aux;\\n    while (lista != NULL){\\n        aux = lista->prox;\\n        free(lista);\\n        lista = aux;\\n    }\\n    return NULL;\\n}\";","map":{"version":3,"names":["STRUCT_SIMPLES","INICIA_LISTA_SIMPLES","CRIA_LISTA_FUNCAO_SIMPLES","CRIA_LISTA_USO_SIMPLES","CRIA_ELEMENTO_FUNCAO_SIMPLES","INSERE_INICIO_FUNCAO_SIMPLES","INSERE_FIM_FUNCAO_SIMPLES","INSERE_INDICE_FUNCAO_SIMPLES","BUSCA_FUNCAO_SIMPLES","BUSCA_FUNCAO_SIMPLES_INDICE","REMOVE_FUNCAO_SIMPLES","REMOVE_FUNCAO_SIMPLES_INDICE","DESTROI_LISTA_FUNCAO_SIMPLES"],"sources":["/home/carloslm/Documents/GitHub/simulador_de_listas_encadeadas/src/components/Codes.js"],"sourcesContent":["//Trechos de códigos extraídos das apresentações de slides do profressor André Renato\nexport const STRUCT_SIMPLES = `\nstruct elemento{\n    int valor;\n    struct elemento *prox;\n};`\n\nexport const INICIA_LISTA_SIMPLES = `\nint main(void){\n    struct elemento *inicio;\n    inicio = CriaLista();\n    return 0;\n}\n`\n\nexport const CRIA_LISTA_FUNCAO_SIMPLES = `\nstruct elemento *CriaLista(){\n    return NULL;\n}`\n\nexport const CRIA_LISTA_USO_SIMPLES = `struct elemento *inicio;\ninicio = CriaLista();`\n\nexport const CRIA_ELEMENTO_FUNCAO_SIMPLES = `\nstruct elemento *CriaElemento(int numero){\n    struct elemento *resp = (struct elemento*) malloc(sizeof(struct elemento));\n    resp->valor = numero;\n    resp->prox = NULL;\n    return resp;\n}`\n\nexport const INSERE_INICIO_FUNCAO_SIMPLES = `\nstruct elemento *InsereInicio(elemento *lista, int numero){\n    struct elemento *novo = CriaElemento(numero);\n    novo->prox = lista;\n    lista = novo;\n    return lista;\n}`\n\nexport const INSERE_FIM_FUNCAO_SIMPLES = `\nstruct elemento *InsereFim(struct elemento *lista, int numero){\n    struct elemento *aux;\n    struct elemento *novo = CriaElemento(numero);\n    if (lista == NULL){\n        lista = novo;\n    }\n    else{\n        aux = lista;\n        while (aux->prox != NULL)\n            aux = aux->prox;\n        aux->prox = novo;\n    }\n    return lista;\n}`\n\nexport const INSERE_INDICE_FUNCAO_SIMPLES = `\nstruct elemento *InsereIndice(struct elemento *lista, int numero, int indice) {\n    struct elemento *aux;\n    struct elemento *ant;\n    struct elemento *novo = CriaElemento(numero);\n    int indiceAtual = 1;\n    if (lista == NULL) \n    {\n      lista = novo;\n    } \n    else if (indice == 0) \n    {\n      novo->prox = lista;\n      lista = novo;\n    } \n    else {\n      aux = lista->prox;\n      ant = lista;\n      while (aux != NULL && indiceAtual != indice) \n      {\n        ant = aux;\n        aux = aux->prox;\n        indiceAtual++;\n      }\n      if (indiceAtual == indice) \n      {\n        ant->prox = novo;\n        novo->prox = aux;\n      }\n    }\n    return lista;\n  }`\n\nexport const BUSCA_FUNCAO_SIMPLES = `\nstruct elemento *BuscaElemento(struct elemento *lista, int numero){\n    struct elemento *aux = lista;\n    while (aux != NULL && aux->valor != numero)\n        aux = aux->prox;\n    return aux;\n}`\n\nexport const BUSCA_FUNCAO_SIMPLES_INDICE = `\nstruct elemento *BuscaIndice(struct elemento *lista, int indice){\n    int indiceAtual = 0;\n    struct elemento *aux = lista;\n    while (aux != NULL && indiceAtual != indice){\n        aux = aux->prox;\n        indiceAtual++;\n    return aux;\n}`\n\nexport const REMOVE_FUNCAO_SIMPLES = `\nstruct elemento *RemoveElemento(struct elemento *lista, int numero){\n    if (lista == NULL) return NULL;\n    struct elemento *ant = lista;\n    struct elemento *aux = ant->prox;\n    if (ant->valor == numero){\n        lista = aux;\n        free(ant);\n    }\n    else{\n        while (aux != NULL && aux->valor != numero){\n            ant = aux;\n            aux = aux->prox;\n        }\n        if (aux != NULL){\n            ant->prox = aux->prox;\n            free(aux);\n        }\n    }\n    return lista;\n}`\n\nexport const REMOVE_FUNCAO_SIMPLES_INDICE = `\nstruct elemento *RemoveIndice(struct elemento *lista, int indice){\n    if (lista == NULL) return NULL;\n    int indiceAtual = 1;\n    struct elemento *ant = lista;\n    struct elemento *aux = ant->prox;\n    if (indice == 0){\n        lista = aux;\n        free(ant);\n    }\n    else{\n        while (aux != NULL && indiceAtual != indice){\n            ant = aux;\n            aux = aux->prox;\n            indiceAtual++;\n        }\n        if (aux != NULL){\n            ant->prox = aux->prox;\n            free(aux);\n        }\n    }\n    return lista;\n}`\n\nexport const DESTROI_LISTA_FUNCAO_SIMPLES = `\nstruct elemento *DestroiLista(struct elemento *lista){\n    struct elemento *aux;\n    while (lista != NULL){\n        aux = lista->prox;\n        free(lista);\n        lista = aux;\n    }\n    return NULL;\n}`\n\n"],"mappings":"AAAA;AACA,OAAO,IAAMA,cAAc,uEAIxB;AAEH,OAAO,IAAMC,oBAAoB,mGAMhC;AAED,OAAO,IAAMC,yBAAyB,yDAGpC;AAEF,OAAO,IAAMC,sBAAsB,oDACb;AAEtB,OAAO,IAAMC,4BAA4B,0MAMvC;AAEF,OAAO,IAAMC,4BAA4B,uLAMvC;AAEF,OAAO,IAAMC,yBAAyB,qWAcpC;AAEF,OAAO,IAAMC,4BAA4B,ksBA+BrC;AAEJ,OAAO,IAAMC,oBAAoB,4MAM/B;AAEF,OAAO,IAAMC,2BAA2B,8PAQtC;AAEF,OAAO,IAAMC,qBAAqB,4gBAoBhC;AAEF,OAAO,IAAMC,4BAA4B,wjBAsBvC;AAEF,OAAO,IAAMC,4BAA4B,wNASvC"},"metadata":{},"sourceType":"module"}